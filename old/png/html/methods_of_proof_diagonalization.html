<!DOCTYPE html><html><head><title>Methods of Proof — Diagonalization</title></head><body>
<h1>Methods of Proof — Diagonalization</h1><p><a href="http://jeremykun.com/2015/06/08/methods-of-proof-diagonalization/" target="_new">Original URL</a></p>
<p><blockquote>A while back we featured a post about why learning mathematics can be hard for programmers, and I claimed a major issue was&#xA0;not understanding the basic methods of proof (the lingua franca&hellip;</blockquote></p>
<div><div class="entry-content">
		<p>A while back we featured a post about <a title="Why there is no Hitchhiker&#x2019;s Guide to Mathematics for Programmers" href="http://jeremykun.com/2013/02/08/why-there-is-no-hitchhikers-guide-to-mathematics-for-programmers/">why learning mathematics can be hard for programmers</a>, and I claimed a major issue was&#xA0;not understanding the basic methods of proof (the lingua franca between intuition and rigorous&#xA0;mathematics). I boiled these down to the &#x201C;basic four,&#x201D; <a title="Methods of Proof &#x2014; Direct Implication" href="http://jeremykun.com/2013/02/16/methods-of-proof-direct-implication/">direct implication</a>, <a title="Methods of Proof &#x2014; Contrapositive" href="http://jeremykun.com/2013/02/22/methods-of-proof-contrapositive/">contrapositive</a>, <a title="Methods of Proof &#x2014; Contradiction" href="http://jeremykun.com/2013/02/28/methods-of-proof-contradiction/">contradiction</a>, and <a title="Methods of Proof &#x2014; Induction" href="http://jeremykun.com/2013/03/21/methods-of-proof-induction/">induction</a>.&#xA0;But in mathematics there is an ever growing supply of proof methods. There are books written about the &#x201C;<a href="http://www.amazon.com/gp/product/0470170204/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0470170204&amp;linkCode=as2&amp;tag=mathinterprog-20&amp;linkId=BBL3WJIANJSAYEZ6">probabilistic method</a>,&#x201D; and I recently went to a lecture where the &#x201C;linear algebra method&#x201D; was displayed. There has been recent talk of a &#x201C;quantum method&#x201D; for proving theorems&#xA0;unrelated to quantum mechanics, and many more.</p>
<p>So in continuing our series of methods of proof, we&#x2019;ll move up to&#xA0;some of the more advanced methods of proof. And in keeping with the spirit of the series, we&#x2019;ll spend most of our time discussing the structural form of the proofs. This time, diagonalization.</p>
<h2>Diagonalization</h2>
<p>Perhaps one of the most famous methods of proof after the basic four is proof by diagonalization. Why do they call it diagonalization? Because the idea behind diagonalization is to write out a table that describes how a collection of objects behaves, and then to manipulate the &#x201C;diagonal&#x201D; of that table to get a new object&#xA0;that you can prove&#xA0;isn&#x2019;t&#xA0;in the table.</p>
<p>The simplest and most famous example of this is the proof that there is no bijection between the natural numbers and the real numbers. We defined <a href="http://jeremykun.com/2013/02/22/methods-of-proof-contrapositive/">injections</a>, and <a href="http://jeremykun.com/2013/02/28/methods-of-proof-contradiction/">surjections and bijections</a>, in two earlier posts in this series, but for new readers a bijection is just a one-to-one mapping between two collections of things. For example, one can construct a bijection between all positive integers and all&#xA0;<em>even</em> positive integers by mapping <img src="http://s0.wp.com/latex.php?latex=n&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="n" title="n" class="latex"> to <img src="http://s0.wp.com/latex.php?latex=2n&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="2n" title="2n" class="latex">. If there is a bijection between two (perhaps infinite) sets, then we&#xA0;say they have the same size or <i>cardinality</i>. And so to say there is no bijection between the natural numbers and the real numbers is to say that one of these two sets (the real numbers) is somehow &#x201C;larger&#x201D; than the other, despite both being infinite in size. It&#x2019;s deep, it used to be very controversial, and&#xA0;it made the method of diagonalization famous. Let&#x2019;s see how it works.</p>
<p><strong>Theorem:&#xA0;</strong>There is no bijection from the natural numbers <img src="http://s0.wp.com/latex.php?latex=%5Cmathbb%7BN%7D&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="\mathbb{N}" title="\mathbb{N}" class="latex"> to the real numbers <img src="http://s0.wp.com/latex.php?latex=%5Cmathbb%7BR%7D&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="\mathbb{R}" title="\mathbb{R}" class="latex">.</p>
<p><em>Proof.</em>&#xA0;Suppose to the contrary (i.e., we&#x2019;re about to&#xA0;do proof by contradiction) that there is a bijection <img src="http://s0.wp.com/latex.php?latex=f%3A+%5Cmathbb%7BN%7D+%5Cto+%5Cmathbb%7BR%7D&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="f: \mathbb{N} \to \mathbb{R}" title="f: \mathbb{N} \to \mathbb{R}" class="latex">. That is, you give me a positive integer <img src="http://s0.wp.com/latex.php?latex=k&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="k" title="k" class="latex"> and I will spit out <img src="http://s0.wp.com/latex.php?latex=f%28k%29&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="f(k)" title="f(k)" class="latex">, with the property that different <img src="http://s0.wp.com/latex.php?latex=k&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="k" title="k" class="latex"> give different <img src="http://s0.wp.com/latex.php?latex=f%28k%29&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="f(k)" title="f(k)" class="latex">, and every real number is hit by some natural number <img src="http://s0.wp.com/latex.php?latex=k&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="k" title="k" class="latex"> (this is just what it means to be a one-to-one mapping).</p>
<p>First let me just do some setup. I&#xA0;claim that all we need to do is show that there is no bijection between <img src="http://s0.wp.com/latex.php?latex=%5Cmathbb%7BN%7D&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="\mathbb{N}" title="\mathbb{N}" class="latex"> and the real numbers&#xA0;<em>between 0 and 1</em>. In&#xA0;particular, I claim there is a bijection from <img src="http://s0.wp.com/latex.php?latex=%280%2C1%29&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="(0,1)" title="(0,1)" class="latex"> to all real numbers, so if there is a bijection from <img src="http://s0.wp.com/latex.php?latex=%5Cmathbb%7BN%7D+%5Cto+%280%2C1%29&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="\mathbb{N} \to (0,1)" title="\mathbb{N} \to (0,1)" class="latex"> then we could combine the two bijections. To show there is a bijection from <img src="http://s0.wp.com/latex.php?latex=%280%2C1%29+%5Cto+%5Cmathbb%7BR%7D&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="(0,1) \to \mathbb{R}" title="(0,1) \to \mathbb{R}" class="latex">,&#xA0;I can first make&#xA0;a bijection from the open interval <img src="http://s0.wp.com/latex.php?latex=%280%2C1%29&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="(0,1)" title="(0,1)" class="latex"> to the interval <img src="http://s0.wp.com/latex.php?latex=%28-%5Cinfty%2C+0%29+%5Ccup+%281%2C+%5Cinfty%29&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="(-\infty, 0) \cup (1, \infty)" title="(-\infty, 0) \cup (1, \infty)" class="latex"> by mapping <img src="http://s0.wp.com/latex.php?latex=x&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="x" title="x" class="latex"> to <img src="http://s0.wp.com/latex.php?latex=1%2Fx&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="1/x" title="1/x" class="latex">.&#xA0;With a little bit of extra work (read, messy details) you can&#xA0;extend this&#xA0;to all real numbers. Here&#x2019;s a sketch: make a bijection from <img src="http://s0.wp.com/latex.php?latex=%280%2C1%29&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="(0,1)" title="(0,1)" class="latex"> to <img src="http://s0.wp.com/latex.php?latex=%280%2C2%29&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="(0,2)" title="(0,2)" class="latex"> by doubling; then make a bijection from <img src="http://s0.wp.com/latex.php?latex=%280%2C2%29&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="(0,2)" title="(0,2)" class="latex"> to all real numbers by using the <img src="http://s0.wp.com/latex.php?latex=%280%2C1%29&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="(0,1)" title="(0,1)" class="latex"> part to get <img src="http://s0.wp.com/latex.php?latex=%28-%5Cinfty%2C+0%29+%5Ccup+%281%2C+%5Cinfty%29&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="(-\infty, 0) \cup (1, \infty)" title="(-\infty, 0) \cup (1, \infty)" class="latex">, and use the <img src="http://s0.wp.com/latex.php?latex=%5B1%2C2%29&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="[1,2)" title="[1,2)" class="latex"> part to get <img src="http://s0.wp.com/latex.php?latex=%5B0%2C1%5D&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="[0,1]" title="[0,1]" class="latex"> by subtracting 1 (almost! To be super rigorous you also have to argue that the missing number 1 doesn&#x2019;t change the cardinality, or else write down a more complicated bijection; still, the idea should be clear).</p>
<p>Okay, setup is done. We just have to show there is no bijection between <img src="http://s0.wp.com/latex.php?latex=%280%2C1%29&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="(0,1)" title="(0,1)" class="latex"> and the natural numbers.</p>
<p>The reason I did all that setup is so that I can use the fact that&#xA0;every real number in <img src="http://s0.wp.com/latex.php?latex=%280%2C1%29&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="(0,1)" title="(0,1)" class="latex"> has an infinite binary decimal expansion whose only nonzero digits are after the decimal point.&#xA0;And so I&#x2019;ll write down the expansion of <img src="http://s0.wp.com/latex.php?latex=f%281%29&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="f(1)" title="f(1)" class="latex"> as a row in a table (an infinite row), and below it I&#x2019;ll write down the expansion of <img src="http://s0.wp.com/latex.php?latex=f%282%29&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="f(2)" title="f(2)" class="latex">, below that <img src="http://s0.wp.com/latex.php?latex=f%283%29&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="f(3)" title="f(3)" class="latex">, and so on, and the decimal points will line up. The table looks like this.</p>
<p><a href="https://jeremykun.files.wordpress.com/2014/03/firsttable1.gif"><img class="aligncenter size-full wp-image-5854" src="https://jeremykun.files.wordpress.com/2014/03/firsttable1.gif?w=1800" alt="firsttable"></a>The <img src="http://s0.wp.com/latex.php?latex=d&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="d" title="d" class="latex">&#x2018;s above are either 0 or 1. I need to be a bit more detailed in my table, so I&#x2019;ll index the digits of <img src="http://s0.wp.com/latex.php?latex=f%281%29&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="f(1)" title="f(1)" class="latex"> by <img src="http://s0.wp.com/latex.php?latex=b_%7B1%2C1%7D%2C+b_%7B1%2C2%7D%2C+b_%7B1%2C3%7D%2C+%5Cdots&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="b_{1,1}, b_{1,2}, b_{1,3}, \dots" title="b_{1,1}, b_{1,2}, b_{1,3}, \dots" class="latex">, the digits of <img src="http://s0.wp.com/latex.php?latex=f%282%29&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="f(2)" title="f(2)" class="latex"> by <img src="http://s0.wp.com/latex.php?latex=b_%7B2%2C1%7D%2C+b_%7B2%2C2%7D%2C+b_%7B2%2C3%7D%2C+%5Cdots&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="b_{2,1}, b_{2,2}, b_{2,3}, \dots" title="b_{2,1}, b_{2,2}, b_{2,3}, \dots" class="latex">, and so on. This makes the table look like this</p>
<p><a href="https://jeremykun.files.wordpress.com/2014/03/secondtable.gif"><img class="aligncenter size-full wp-image-5855" src="https://jeremykun.files.wordpress.com/2014/03/secondtable.gif?w=1800" alt="secondtable"></a></p>
<p>It&#x2019;s a bit harder to read, but trust me the notation is helpful.</p>
<p>Now by the assumption that <img src="http://s0.wp.com/latex.php?latex=f&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="f" title="f" class="latex"> is a bijection, I&#x2019;m assuming that&#xA0;<em>every</em> real number shows up as a number in this table, and no real number shows up twice. So if I could construct a number&#xA0;that I can prove is not in the table, I will arrive at a contradiction: the table couldn&#x2019;t have had all real numbers to begin with! And&#xA0;that will prove&#xA0;there is no bijection between the natural numbers and the real numbers.</p>
<p>Here&#x2019;s how I&#x2019;ll come up with such a number <img src="http://s0.wp.com/latex.php?latex=N&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="N" title="N" class="latex"> (this is the diagonalization part). It starts with 0., and it&#x2019;s first&#xA0;digit after the decimal is <img src="http://s0.wp.com/latex.php?latex=1-b_%7B1%2C1%7D&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="1-b_{1,1}" title="1-b_{1,1}" class="latex">. That is, we flip the bit <img src="http://s0.wp.com/latex.php?latex=b_%7B1%2C1%7D&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="b_{1,1}" title="b_{1,1}" class="latex"> to get the first digit of <img src="http://s0.wp.com/latex.php?latex=N&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="N" title="N" class="latex">. The second digit&#xA0;is <img src="http://s0.wp.com/latex.php?latex=1-b_%7B2%2C2%7D&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="1-b_{2,2}" title="1-b_{2,2}" class="latex">, the third is <img src="http://s0.wp.com/latex.php?latex=1-b_%7B3%2C3%7D&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="1-b_{3,3}" title="1-b_{3,3}" class="latex">, and so on. In general, digit <img src="http://s0.wp.com/latex.php?latex=i&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="i" title="i" class="latex"> is&#xA0;<img src="http://s0.wp.com/latex.php?latex=1-b_%7Bi%2Ci%7D&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="1-b_{i,i}" title="1-b_{i,i}" class="latex">.</p>
<p>Now we show that <img src="http://s0.wp.com/latex.php?latex=N&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="N" title="N" class="latex"> isn&#x2019;t in the table. If it were, then it would have to be <img src="http://s0.wp.com/latex.php?latex=N+%3D+f%28m%29&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="N = f(m)" title="N = f(m)" class="latex"> for some <img src="http://s0.wp.com/latex.php?latex=m&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="m" title="m" class="latex">, i.e. be the <img src="http://s0.wp.com/latex.php?latex=m&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="m" title="m" class="latex">-th row&#xA0;in the table. Moreover, by the way we built the table, the <img src="http://s0.wp.com/latex.php?latex=m&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="m" title="m" class="latex">-th digit of <img src="http://s0.wp.com/latex.php?latex=N&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="N" title="N" class="latex"> would be <img src="http://s0.wp.com/latex.php?latex=b_%7Bm%2Cm%7D&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="b_{m,m}" title="b_{m,m}" class="latex">. But we&#xA0;<em>defined&#xA0;</em><img src="http://s0.wp.com/latex.php?latex=N&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="N" title="N" class="latex"> so that it&#x2019;s <img src="http://s0.wp.com/latex.php?latex=m&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="m" title="m" class="latex">-th digit was actually <img src="http://s0.wp.com/latex.php?latex=1-b_%7Bm%2Cm%7D&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="1-b_{m,m}" title="1-b_{m,m}" class="latex">.&#xA0;This is very embarrassing for <img src="http://s0.wp.com/latex.php?latex=N&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="N" title="N" class="latex"> (it&#x2019;s a contradiction!). So <img src="http://s0.wp.com/latex.php?latex=N&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="N" title="N" class="latex"> isn&#x2019;t&#xA0;in the table.</p>
<p><img src="http://s0.wp.com/latex.php?latex=%5Csquare&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="\square" title="\square" class="latex"></p>
<p>It&#x2019;s the kind of proof that blows your mind the first time you see it, because it says that <em>there is more than one kind of infinity</em>. Not something you think about every day, right?</p>
<h2>The Halting Problem</h2>
<p>The second example we&#x2019;ll show of a proof by diagonalization&#xA0;is the Halting Theorem, proved originally by Alan Turing, which says that there are some problems that computers can&#x2019;t solve, even if given&#xA0;unbounded space and time to perform their computations. The formal mathematical model is called a Turing machine, but&#xA0;for simplicity you can&#xA0;think of &#x201C;Turing machines&#x201D; and &#x201C;algorithms described in words&#x201D; as the same thing. Or if you want it can be &#x201C;programs written in programming language X.&#x201D; So we&#x2019;ll&#xA0;use the three words &#x201C;Turing machine,&#x201D; &#x201C;algorithm,&#x201D; and &#x201C;program&#x201D; interchangeably.</p>
<p>The proof works by actually defining&#xA0;a problem&#xA0;and proving it can&#x2019;t be solved. The problem is called <em>the halting problem</em>, and it is the problem of deciding: given&#xA0;a program <img src="http://s0.wp.com/latex.php?latex=P&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="P" title="P" class="latex"> and an input <img src="http://s0.wp.com/latex.php?latex=x&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="x" title="x" class="latex"> to that program, will&#xA0;<img src="http://s0.wp.com/latex.php?latex=P&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="P" title="P" class="latex"> ever stop running when given <img src="http://s0.wp.com/latex.php?latex=x&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="x" title="x" class="latex"> as input? What I mean by &#x201C;decide&#x201D; is that&#xA0;any program that claims to solve the halting problem&#xA0;is itself required to halt for every possible input with the correct answer. A &#x201C;halting problem solver&#x201D; can&#x2019;t loop infinitely!</p>
<p>So&#xA0;first we&#x2019;ll give the standard proof that the halting problem can&#x2019;t be solved, and then we&#x2019;ll inspect the form of the proof more closely to see why it&#x2019;s considered a diagonalization argument.</p>
<p><strong>Theorem:&#xA0;</strong>The halting program cannot be solved by Turing machines.</p>
<p><em>Proof.&#xA0;</em>Suppose to the contrary that&#xA0;<img src="http://s0.wp.com/latex.php?latex=T&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="T" title="T" class="latex">&#xA0;is a&#xA0;program that solves the halting problem. We&#x2019;ll use <img src="http://s0.wp.com/latex.php?latex=T&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="T" title="T" class="latex"> as a black box to come up with a new program I&#x2019;ll call meta-<img src="http://s0.wp.com/latex.php?latex=T&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="T" title="T" class="latex">, defined in pseudo-python as follows.</p>
<pre class="brush: python; title: ; notranslate" title="">
def metaT(P):
 run T on (P,P)
 if T says that P halts:
 loop infinitely
 else:
 halt and output "success!"
</pre>
<p>In words, meta-<img src="http://s0.wp.com/latex.php?latex=T&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="T" title="T" class="latex"> accepts as input the source code of a program <img src="http://s0.wp.com/latex.php?latex=P&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="P" title="P" class="latex">, and then uses <img src="http://s0.wp.com/latex.php?latex=T&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="T" title="T" class="latex"> to tell if <img src="http://s0.wp.com/latex.php?latex=P&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="P" title="P" class="latex"> halts (when given its own source code as input). Based on the result, it behaves&#xA0;the <em>opposite</em> of <img src="http://s0.wp.com/latex.php?latex=P&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="P" title="P" class="latex">; if <img src="http://s0.wp.com/latex.php?latex=P&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="P" title="P" class="latex"> halts then meta-<img src="http://s0.wp.com/latex.php?latex=T&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="T" title="T" class="latex"> loops infinitely and vice versa.&#xA0;It&#x2019;s a little meta, right?</p>
<p>Now let&#x2019;s do something crazy: let&#x2019;s run meta-<img src="http://s0.wp.com/latex.php?latex=T&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="T" title="T" class="latex"> on itself! That is, run</p>
<pre class="brush: python; title: ; notranslate" title="">
metaT(metaT)
</pre>
<p>So meta. The question is what is the output of this call?&#xA0;The meta-<img src="http://s0.wp.com/latex.php?latex=T&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="T" title="T" class="latex"> program uses <img src="http://s0.wp.com/latex.php?latex=T&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="T" title="T" class="latex"> to determine whether meta-<img src="http://s0.wp.com/latex.php?latex=T&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="T" title="T" class="latex"> halts when given itself as input. So let&#x2019;s say that the answer to this question is &#x201C;yes, it does halt.&#x201D; Then by the definition of meta-<img src="http://s0.wp.com/latex.php?latex=T&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="T" title="T" class="latex">, the program proceeds to loop forever. But this is a problem, because it means that <code>metaT(metaT)</code> (which is the original thing we ran) actually does not halt, contradicting <img src="http://s0.wp.com/latex.php?latex=T&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="T" title="T" class="latex">&#x2018;s answer! Likewise, if <img src="http://s0.wp.com/latex.php?latex=T&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="T" title="T" class="latex"> says that <code>metaT(metaT)</code> should loop infinitely, that will cause meta-<img src="http://s0.wp.com/latex.php?latex=T&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="T" title="T" class="latex"> to halt, a contradiction. So <img src="http://s0.wp.com/latex.php?latex=T&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="T" title="T" class="latex"> cannot be correct, and the halting problem can&#x2019;t be solved.</p>
<p><img src="http://s0.wp.com/latex.php?latex=%5Csquare&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="\square" title="\square" class="latex"></p>
<p>This theorem is deep&#xA0;because it says that you can&#x2019;t possibly write a program to which can always detect bugs in other programs. Infinite loops are just one special kind of bug.</p>
<p>But let&#x2019;s take a closer look and see why this is a proof by diagonalization. The first thing we need to convince ourselves is that&#xA0;the set of all programs is countable (that is, there is a bijection&#xA0;from <img src="http://s0.wp.com/latex.php?latex=%5Cmathbb%7BN%7D&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="\mathbb{N}" title="\mathbb{N}" class="latex"> to the set of all programs). This shouldn&#x2019;t be so hard to see: you can list all programs in <a href="http://en.wikipedia.org/wiki/Lexicographical_order">lexicographic</a>&#xA0;order, since the set of all strings is countable, and then throw out any that are not&#xA0;syntactically valid programs. Likewise, the set of all&#xA0;inputs, really just all strings, is countable.</p>
<p>The second thing we need to convince ourselves of is that a&#xA0;<em>problem</em> corresponds to an infinite binary string. To do this, we&#x2019;ll restrict our attention to problems with yes/no answers, that is where the goal of the program is to output a single bit corresponding to yes or no for a given input. Then&#xA0;if we list all possible inputs in increasing&#xA0;lexicographic order,&#xA0;a problem can be represented by the infinite list of bits that are the correct&#xA0;outputs to each input.</p>
<p>For example, if the problem is to determine whether a given binary input string corresponds to an even number, the representation&#xA0;might look like this:</p>
<p><code>010101010101010101...</code></p>
<p>Of course this all depends on the details of how one encodes inputs, but the point is that if you wanted to you could nail all this down precisely. More importantly for us we can represent the halting problem as an infinite <em>table</em> of bits. If the columns of the table are all programs (in lex order), and the rows of the table correspond to inputs (in lex order), then the table would have at entry <img src="http://s0.wp.com/latex.php?latex=%28x%2CP%29&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="(x,P)" title="(x,P)" class="latex"> a 1 if <img src="http://s0.wp.com/latex.php?latex=P%28x%29&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="P(x)" title="P(x)" class="latex"> halts and a 0 otherwise.</p>
<p><a href="https://jeremykun.files.wordpress.com/2014/03/secondtable.gif"><br>
</a> <a href="https://jeremykun.files.wordpress.com/2015/06/haltingtable.gif"><img class="aligncenter size-medium wp-image-5865" src="https://jeremykun.files.wordpress.com/2015/06/haltingtable.gif?w=300&amp;h=195" alt="haltingtable"></a></p>
<p>here <img src="http://s0.wp.com/latex.php?latex=b_%7Bi%2Cj%7D&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="b_{i,j}" title="b_{i,j}" class="latex"> is 1 if <img src="http://s0.wp.com/latex.php?latex=P_j%28x_i%29&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="P_j(x_i)" title="P_j(x_i)" class="latex"> halts and 0 otherwise. The table encodes the answers to the halting problem for all possible inputs.</p>
<p>Now we assume for contradiction sake that some program solves the halting problem, i.e. that every entry of the table is computable. Now we&#x2019;ll construct the answers output by meta-<img src="http://s0.wp.com/latex.php?latex=T&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="T" title="T" class="latex"> by flipping each bit of the diagonal of the table. The point is that meta-<img src="http://s0.wp.com/latex.php?latex=T&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="T" title="T" class="latex">&#xA0;corresponds to some <em>row</em> of the table, because there is some input string that is&#xA0;interpreted as&#xA0;the source code of meta-<img src="http://s0.wp.com/latex.php?latex=T&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="T" title="T" class="latex">.&#xA0;Then we argue that the entry of the table for <img src="http://s0.wp.com/latex.php?latex=%28%5Ctextup%7Bmeta-%7DT%2C+%5Ctextup%7Bmeta-%7DT%29&amp;bg=ffffff&amp;fg=36312d&amp;s=0" alt="(\textup{meta-}T, \textup{meta-}T)" title="(\textup{meta-}T, \textup{meta-}T)" class="latex"> contradicts its definition, and we&#x2019;re done!</p>
<p>So these are two of the most high-profile uses of the method of diagonalization. It&#x2019;s a great tool&#xA0;for&#xA0;your proving repertoire.</p>
<p>Until next time!</p>
					</div>

	
</div>
</body></html>
