<!DOCTYPE html><html><head><title>Dremel made simple with Parquet</title></head><body>
<h1>Dremel made simple with Parquet</h1><p><a href="https://blog.twitter.com/2013/dremel-made-simple-with-parquet" target="_new">Original URL</a></p>
<p><blockquote>Columnar storage is a popular technique to optimize analytical workloads in parallel RDBMs. The performance and compression benefits for storing and processing large amounts of data are well&hellip;</blockquote></p>
<div><div class="Field-items-item even "><p>Columnar storage is a popular technique to optimize analytical workloads in parallel RDBMs. The performance and compression benefits for storing and processing large amounts of data are well documented in academic literature as well as several <a href="http://people.csail.mit.edu/tdanford/6830papers/stonebraker-cstore.pdf">commercial</a><a href="http://vldb.org/pvldb/vol5/p1790_andrewlamb_vldb2012.pdf%E2%80%8E">analytical</a><a href="http://www.monetdb.org/">databases</a>.</p><p>The goal is to keep I/O to a minimum by reading from a disk only the data required for the query. Using <a href="https://blog.twitter.com/2013/announcing-parquet-10-columnar-storage-for-hadoop">Parquet at Twitter</a>, we experienced a reduction in size by one third on our large datasets. Scan times were also reduced to a fraction of the original in the common case of needing only a subset of the columns. The principle is quite simple: instead of a traditional row layout, the data is written one column at a time. While turning rows into columns is straightforward given a flat schema, it is more challenging when dealing with nested data structures.</p><p>We recently <a href="https://blog.twitter.com/2013/announcing-parquet-10-columnar-storage-for-hadoop">introduced Parquet</a>, an open source file format for Hadoop that provides columnar storage. Initially a joint effort between Twitter and Cloudera, it now has <a href="https://github.com/Parquet/parquet-mr/graphs/contributors">many other contributors</a> including companies like Criteo. Parquet stores nested data structures in a flat columnar format using a technique outlined in the <a href="http://research.google.com/pubs/pub36632.html">Dremel paper</a> from Google. Having implemented this model based on the paper, we decided to provide a more accessible explanation. We will first describe the general model used to represent nested data structures. Then we will explain how this model can be represented as a flat list of columns. Finally we&#x2019;ll discuss why this representation is effective.</p><p>To illustrate what columnar storage is all about, here is an example with three columns.</p><p><img src="https://g.twimg.com/blog/blog/image/table.png" width="113" alt=""></p><p>In a row-oriented storage, the data is laid out one row at a time as follows:</p><p><img src="https://g.twimg.com/blog/blog/image/row1.png" width="295" alt=""></p><p>Whereas in a column-oriented storage, it is laid out one column at a time:</p><p><img src="https://g.twimg.com/blog/blog/image/row2.png" width="295" alt=""></p><p>There are several advantages to columnar formats.</p><ul><li>Organizing by column allows for better compression, as data is more homogenous. The space savings are very noticeable at the scale of a Hadoop cluster.</li><li>I/O will be reduced as we can efficiently scan only a subset of the columns while reading the data. Better compression also reduces the bandwidth required to read the input.</li><li>As we store data of the same type in each column, we can use encodings better suited to the modern processors&#x2019; pipeline by making instruction branching more predictable.</li></ul><h5>The model</h5><p>To store in a columnar format we first need to describe the data structures using a <a href="https://github.com/Parquet/parquet-mr/tree/master/parquet-column/src/main/java/parquet/schema">schema</a>. This is done using a model similar to <a href="http://en.wikipedia.org/wiki/Protocol_Buffers">Protocol buffers</a>. This model is minimalistic in that it represents nesting using groups of fields and repetition using repeated fields. There is no need for any other complex types like Maps, List or Sets as they all can be mapped to a combination of repeated fields and groups.</p><p>The root of the schema is a group of fields called a message. Each field has three attributes: a repetition, a type and a name. The type of a field is either a group or a primitive type (e.g., int, float, boolean, string) and the repetition can be one of the three following cases:</p><ul><li><strong>required</strong>: exactly one occurrence</li><li><strong>optional</strong>: 0 or 1 occurrence</li><li><strong>repeated</strong>: 0 or more occurrences</li></ul><p>For example, here&#x2019;s a schema one might use for an address book:</p><pre>message AddressBook {<br> required string owner;<br> repeated string ownerPhoneNumbers;<br> repeated group contacts {<br> required string name;<br> optional string phoneNumber;<br> }<br>}</pre><p><span>Lists (or Sets) can be represented by a repeating field.</span></p><p><span><img src="https://g.twimg.com/blog/blog/image/table2_0.png" width="628" alt=""></span></p><p><span><span>A Map is equivalent to a repeating field containing groups of key-value pairs where the key is required.</span></span></p><p><span><span><img src="https://g.twimg.com/blog/blog/image/table3_0.png" width="627" alt=""></span></span></p><h5>Columnar format</h5><p>A columnar format provides more efficient encoding and decoding by storing together values of the same primitive type. To store nested data structures in columnar format, we need to map the schema to a list of columns in a way that we can write records to flat columns and read them back to their original nested data structure. In Parquet, we create one column per primitive type field in the schema. If we represent the schema as a tree, the primitive types are the leaves of this tree.</p><p>AddressBook example as a tree:</p><p><img src="https://g.twimg.com/blog/blog/image/addressbook.png" width="491" alt=""></p><p>To represent the data in columnar format we create one column per primitive type cell shown in blue.</p><p><img src="https://g.twimg.com/blog/blog/image/table4_0.png" width="700" alt=""></p><p>The structure of the record is captured for each value by two integers called repetition level and definition level. Using definition and repetition levels, we can fully reconstruct the nested structures. This will be explained in detail below.</p><h5>Definition levels</h5><p>To support nested records we need to store the level for which the field is null. This is what the definition level is for: from 0 at the root of the schema up to the maximum level for this column. When a field is defined then all its parents are defined too, but when it is null we need to record the level at which it started being null to be able to reconstruct the record.</p><p>In a flat schema, an optional field is encoded on a single bit using 0 for null and 1 for defined. In a nested schema, we use an additional value for each level of nesting (as shown in the example), finally if a field is required it does not need a definition level.</p><p>For example, consider the simple nested schema below:</p><pre>message ExampleDefinitionLevel {<br> optional group a {<br> optional group b {<br> optional string c;<br> }<br> }<br>}</pre><p>It contains one column: <strong>a.b.c</strong> where all fields are optional and can be null. When <strong>c</strong> is defined, then necessarily <strong>a</strong> and <strong>b</strong> are defined too, but when <strong>c</strong> is null, we need to save the level of the null value. There are 3 nested optional fields so the maximum definition level is 3.</p><p>Here is the definition level for each of the following cases:</p><p><img src="https://g.twimg.com/blog/blog/image/table5.png" width="628" alt=""></p><p><img src="https://g.twimg.com/blog/blog/image/definitionlevel.png" width="565" alt=""></p><p>The maximum possible definition level is 3, which indicates that the value is defined. Values 0 to 2 indicate at which level the null field occurs.</p><p>A required field is always defined and does not need a definition level. Let&#x2019;s reuse the same example with the field <strong>b</strong> now <strong>required</strong>:</p><pre>message ExampleDefinitionLevel {<br> optional group a {<br><strong>required</strong> group b {<br> optional string c;<br> }<br> }<br>}</pre><p>The maximum definition level is now 2 as <strong>b</strong> does not need one. The value of the definition level for the fields below b changes as follows:</p><p><img src="https://g.twimg.com/blog/blog/image/table6.png" width="425" alt=""></p><p>Making definition levels small is important as the goal is to store the levels in as few bits as possible.</p><h5>Repetition levels</h5><p>To support repeated fields we need to store when new lists are starting in a column of values. This is what repetition level is for: it is the level at which we have to create a new list for the current value. In other words, the repetition level can be seen as a marker of when to start a new list and at which level.&#xA0;For example consider the following representation of a list of lists of strings:</p><p><img src="https://g.twimg.com/blog/blog/image/table7a.png" width="627" alt=""></p><p>The column will contain the following repetition levels and values:</p><p><img src="https://g.twimg.com/blog/blog/image/table8.png" width="232" alt=""></p><p>The repetition level marks the beginning of lists and can be interpreted as follows:</p><ul><li>0 marks every new record and implies creating a new level1 and level2 list</li><li>1 marks every new level1 list and implies creating a new level2 list as well.</li><li>2 marks every new element in a level2 list.</li></ul><p>On the following diagram we can visually see that it is the level of nesting at which we insert records:</p><p><img src="https://g.twimg.com/blog/blog/image/nestedlists.png" width="545" alt=""></p><p>A repetition level of 0 marks the beginning of a new record. In a flat schema there is no repetition and the repetition level is always 0. <a href="https://github.com/Parquet/parquet-mr/blob/8f93adfd0020939b9a58f092b88a5f62fd14b834/parquet-column/src/main/java/parquet/schema/GroupType.java#L199">Only levels that are repeated need a Repetition level</a>: optional or required fields are never repeated and can be skipped while attributing repetition levels.</p><h5>Striping and assembly</h5><p>Now using the two notions together, let&#x2019;s consider the AddressBook example again.&#xA0;This table shows the maximum repetition and definition levels for each column with explanations on why they are smaller than the depth of the column:</p><p><img src="https://g.twimg.com/blog/blog/image/table9_0.png" width="627" alt=""></p><p>In particular for the column <strong>contacts.phoneNumber</strong>, a defined phone number will have the maximum definition level of 2, and a contact without phone number will have a definition level of 1. In the case where contacts are absent, it will be 0.</p><pre>AddressBook {<br> owner: "Julien Le Dem",<br> ownerPhoneNumbers: "555 123 4567",<br> ownerPhoneNumbers: "555 666 1337",<br> contacts: {<br> name: "Dmitriy Ryaboy",<br> phoneNumber: "555 987 6543",<br> },<br> contacts: {<br> name: "Chris Aniszczyk"<br> }<br>}<br>AddressBook {<br> owner: "A. Nonymous"<br>}</pre><p>We&#x2019;ll now focus on the column <strong>contacts.phoneNumber</strong> to illustrate this.</p><p>Once projected the record has the following structure:</p><pre>AddressBook {<br> contacts: {<br> phoneNumber: "555 987 6543"<br> }<br> contacts: {<br> }<br>}<br>AddressBook {<br>}</pre><p>The data in the column will be as follows (R = Repetition Level, D = Definition Level)</p><p><img src="https://g.twimg.com/blog/blog/image/columns_0.png" width="577" alt=""></p><p>To write the column we iterate through the record data for this column:</p><ul><li>contacts.phoneNumber: &#x201C;555 987 6543&#x201D;
<ul><li>new record: R = 0</li><li>value is defined: D = maximum (2)</li></ul></li><li>contacts.phoneNumber: null
<ul><li>repeated contacts: R = 1</li><li>only defined up to contacts: D = 1</li></ul></li><li>contacts: null
<ul><li>new record: R = 0</li><li>only defined up to AddressBook: D = 0</li></ul></li></ul><p>The columns contains the following data:</p><p><img src="https://g.twimg.com/blog/blog/image/table10.png" width="211" alt=""></p><p>Note that NULL values are represented here for clarity but are not stored at all. A definition level strictly lower than the maximum (here 2) indicates a NULL value.</p><p>To reconstruct the records from the column, we iterate through the column:</p><ul><li><strong>R=0, D=2, Value = &#x201C;555 987 6543&#x201D;</strong>:
<ul><li>R = 0 means a new record. We recreate the nested records from the root until the definition level (here 2)</li><li>D = 2 which is the maximum. The value is defined and is inserted.</li></ul></li><li><strong>R=1, D=1</strong>:
<ul><li>R = 1 means a new entry in the contacts list at level 1.</li><li>D = 1 means contacts is defined but not phoneNumber, so we just create an empty contacts.</li></ul></li><li><strong>R=0, D=0</strong>:
<ul><li>R = 0 means a new record. we create the nested records from the root until the definition level</li><li>D = 0 =&gt; contacts is actually null, so we only have an empty AddressBook</li></ul></li></ul><h5><span>Storing definition levels and repetition levels efficiently</span></h5><p>In regards to storage, this effectively boils down to creating three sub columns for each primitive type. However, the overhead for storing these sub columns is low thanks to the columnar representation. That&#x2019;s because levels are bound by the depth of the schema and can be stored efficiently using only a few bits per value (A single bit stores levels up to 1, 2 bits store levels up to 3, 3 bits can store 7 levels of nesting). In the address book example above, the column <strong>owner</strong> has a depth of one and the column <strong>contacts.name</strong> has a depth of two. The levels will always have zero as a lower bound and the depth of the column as an upper bound. Even better, fields that are not repeated do not need a repetition level and required fields do not need a definition level, bringing down the upper bound.</p><p>In the special case of a flat schema with all fields required (equivalent of NOT NULL in SQL), the repetition levels and definition levels are omitted completely (they would always be zero) and we only store the values of the columns. This is effectively the same representation we would choose if we had to support only flat tables.</p><p>These characteristics make for a very compact representation of nesting that can be efficiently encoded using a combination of <a href="https://github.com/Parquet/parquet-mr/tree/master/parquet-column/src/main/java/parquet/column/values/rle">Run Length Encoding and bit packing</a>. A sparse column with a lot of null values will compress to almost nothing, similarly an optional column which is actually always set will cost very little overhead to store millions of 1s. In practice, space occupied by levels is negligible. This representation is a generalization of how we would represent the simple case of a flat schema: writing all values of a column sequentially and using a bitfield for storing nulls when a field is optional.</p><h5>Get Involved</h5><p>Parquet is still a young project; to learn more about the project see our <a href="https://github.com/Parquet/parquet-mr/blob/master/README.md">README</a> or look for the &#x201C;<a href="https://github.com/Parquet/parquet-mr/issues?labels=pick+me+up%21&amp;state=open">pick me up!</a>&#x201D; label on GitHub. We do our best to review pull requests in a timely manner and give thorough and constructive reviews.</p><p>You can also join our <a href="mailto:dev@parquet.apache.org">mailing list</a> and tweet at <a href="https://twitter.com/intent/user?screen_name=ApacheParquet">@ApacheParquet</a>&#xA0;to join the discussion.</p></div></div>
</body></html>
