<!DOCTYPE html><html><head><title>A Short History of the BTree</title></head><body>
<h1>A Short History of the BTree</h1><p><a href="https://www.perforce.com/blog/110928/short-history-btree" target="_new">Original URL</a></p>
<p><blockquote>You can make a reasonable argument that the BTree is the most important data structure and algorithm that has yet been invented in computer science. It surely is one of the longest-lived and most&hellip;</blockquote></p>
<div><div class="field-item even"><p>You can make a reasonable argument that the BTree is the most important data structure and algorithm that has yet been invented in computer science. It surely is one of the longest-lived and most durable ideas. BTrees are used by every database system in existence, and are also used in file systems, information retrieval applications, and many other places. The Perforce server stores all of your metadata in BTrees, and you know how high-performing and scalable Perforce servers are!</p>
<p>Although BTree implementations date back to the 1960's, the modern history of the BTree begins with Rudolf Bayer and Ed McCreight's paper: <a href="http://www.springerlink.com/content/n9n0754115251238/"><em>Organization and maintenance of large ordered indexes</em></a>. Bayer and McCreight were working at Boeing's Mathematical and Information Sciences Laboratory in the 1960's, trying to develop algorithms for storing and retrieving data from the computers of the time (here's an earlier version of their paper, published as <a href="http://www.dtic.mil/cgi-bin/GetTRDoc?AD=AD0712079&amp;Location=U2&amp;doc=GetTRDoc.pdf">Mathematical and Information Sciences Report No. 20</a> by the Boeing Scientific Research Laboratories in July, 1970).</p>
<p>Although computers have come a long way in forty years, and the terminology has changed dramatically, the basic concepts of the problem are still the same, and are well stated by Bayer and McCreight:</p>
<blockquote>We assume that the index itself is so voluminous that only rather small parts of it can be kept in main store at one time. Thus the bulk of the index must be kept on some backup store. The class of backup stores considered are <em>pseudo random access devices</em> which have a rather long access or wait time -- as opposed to a true random access device like core store -- and a rather high data rate once the transmission of physically sequential data has been initiated. Typical pseudo random access devices are: fixed and moving head discs, drums, and data cells.</blockquote>
<p>The publication of Bayer and McCreight's paper ushered in the First Age of BTrees, and the decade of the 1970's was filled with enthusiastic work to explore, extend, and improve upon the basic ideas. Various teams worked out the details of page formats, key representations, compression and encoding techniques, and so forth. The most important consolidation during this time was the realization that the B+-tree, a variation in which all keys reside in the leaves, and the internal nodes are purely redundant search structures, had substantial benefits compared to the original version; every practical BTree that I have ever studied has been a B+-tree.</p>
<p>All of this work was collected and described by Doug Comer of Purdue University in the paper <a href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.96.6637"><em>The ubiquitous B-tree</em></a> in 1979.</p>
<p>During the 1980's, the emphasis was on DataBase Management Systems (DBMS), and various vendors and researchers explored the issues of concurrency control and recovery in BTrees. The fundamental concurrency control problem in BTrees is that the access patterns aren't consistent:</p>
<ul><li>Search-by-key starts at the root of the tree and descends to the leaf.</li>
 <li>Splitting a leaf (due to insert or update) and merging two leaves (due to delete or update) proceeds upwards from the leaf toward the root.</li>
 <li>Retrieving entries in index order moves sideways from leaf to leaf.</li>
 <li>Retrieving entries in descending index order also moves sideways, but in the opposite direction.</li>
</ul><p>This means that the protocols which enable multiple independent transactions to process a BTree simultaneously are complex.</p>
<p>Similar problems arise during recovery: should the DBMS log the low-level physical changes such as split, join, page allocation, and key re-arrangement? Or should it log only the "logical" operations such as insert, update, and delete? Various DBMS implementations solved these problems in different ways; one of the most successful and best-known methods is the <a href="http://en.wikipedia.org/wiki/Algorithms_for_Recovery_and_Isolation_Exploiting_Semantics">ARIES</a> algorithm.</p>
<p>A very thorough and complete treatment of this Second Age of BTrees can be found in Jim Gray and Andreas Reuter's encyclopedic <a href="http://www.amazon.com/Transaction-Processing-Concepts-Techniques-Management/dp/1558601902"><em>Transaction Processing: Concepts and Techniques</em></a>.</p>
<p>During the 1990's, the Third Age of Btrees found researchers focused on several specialized aspects of BTrees that arose as they were used more universally:</p>
<ul><li>Some applications found that BTree I/O performance created problems. Maintaining the index in real time results in a high number of random I/Os, which can dramatically impact the throughput on most storage media, such as hard disks. Techniques such as <a><em>Log-Structured Merge-Trees</em></a> combined ideas from log-structed file systems into the BTree algorithms, and dramatically improved high-end performance.</li>
 <li>Others looked at the notion of "versioned" BTrees, which don't overwrite entries when changing them, but rather construct new indexes that can include multiple versions of the indexed data over time. These came to be known as the "copy on write" (COW) BTrees, because the basic approach is to make a copy of (part of) the index when it is updated. An early example of COW BTrees is the <a href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.6439">Episode File System</a> built by Transarc in the 1990s.</li>
</ul><p>These powerful, high-performance BTrees found their way outside of traditional DBMS implementations and down into the filesystem; examples of filesystems built atop the BTree include: <a href="http://en.wikipedia.org/wiki/btrfs">btrfs</a>, <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.184.3704">ZFS</a>, and <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.40.3691">WAFL</a>. With their carefully-orchestrated I/O behaviors and their multi-versioned interfaces, these BTree implementations offered sophisticated new features such as: shadowing, snapshotting, and cloning; they work well with modern hardware such as RAID and SSDs.</p>
<p>An excellent description of the concepts in most Third Age BTrees can be found in Ohad Rodeh's <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.161.6863"><em>B-trees, Shadowing, and Clones</em></a>.</p>
<p>Progress never stops, of course, and today's Internet-scale, distributed, virtualized, cloud-aware data centers are pushing to and beyond the limits of the centralized BTree implementations. Recently, interest has shifted to the investigation of distributed BTree implementations, such as the <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.3.5791"><em>Partitioned B-trees</em></a> work done by Microsoft and <a href="http://www.hpl.hp.com/techreports/2007/HPL-2007-193.pdf"><em>A practical scalable distributed B-tree</em></a>, by a team at HP.</p>
<p>Meanwhile, a startup company named Acunu has been gathering a lot of attention this summer for their work on <em>Stratified B-trees</em>, which are designed to address the problems of redundancy and duplication in COW B-trees. In <a href="http://arxiv.org/pdf/1103.2566v2"><em>Versioned external-memory dictionaries with optimal query/update tradeoffs</em></a>, Andrew Byde and Andy Twigg define the problem as follows:</p>
<blockquote>For deep version trees, many keys in the range may not have been updated since the root version, while some may have been updated many times since then. It is easy to see that some elements must be replicated many times for range queries to be asymptotically optimal &#x2013; a construction that achieves this while balancing asymptotically optimal space, query and update costs is our main contribution.</blockquote>
<p>A good paper for starting to study the Acunu technology is last spring's <a href="http://arxiv.org/abs/1103.4282"><em>Stratified B-trees and versioning dictionaries</em></a>.</p>
<p>It seems that we have entered a glorious new Fourth Age of BTrees in the past few years, as researchers and practitioners continue to extend and enhance this 40-year-old basic idea, demonstrating that there is still a lot of life left in one of computing's "old classics."</p>
<p>Have you seen any innovative and novel new improvements or variations on the BTree? Drop me a line and let me know!</p></div></div>
</body></html>
