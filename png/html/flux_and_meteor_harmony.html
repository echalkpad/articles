<!DOCTYPE html><html><head><title>Flux and Meteor harmony</title></head><body>
<h1>Flux and Meteor harmony</h1><p><a href="https://medium.com/@borellvi/flux-and-meteor-harmony-7180680257e8#.o9f27pa28" target="_new">Original URL</a></p>
<p><blockquote>Meteor’s integration with npm is a game changerA month ago I wrote a short article and I did a short</blockquote></p>
<section name="96fe" class=" section--body section--first section--last" score="41.25"><div class="section-content" score="35.0"><div class="section-inner u-sizeFullWidth" score="1.25"><figure name="2362" id="2362" class="graf--figure graf--layoutFillWidth graf--first" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://cdn-images-1.medium.com/max/2000/1*RvDwHF0g2rvMEN-PMXlIFg.jpeg"></div></figure></div><div class="section-inner layoutSingleColumn" score="-2.5"><blockquote name="9bec" id="9bec" class="graf--blockquote graf-after--h3"><strong class="markup--strong markup--blockquote-strong">Meteor’s integration with npm is a game changer</strong></blockquote><p name="9e4e" id="9e4e" class="graf--p graf-after--blockquote">A month ago I wrote a short <a href="https://medium.com/@borellvi/meteor-meets-npm-a5cc48d90abe#.p4fjeukyy" class="markup--anchor markup--p-anchor">article</a> and I did a short <a href="https://www.youtube.com/watch?v=XTEe4kgVTwU" class="markup--anchor markup--p-anchor" rel="nofollow">talk</a> in Meteor London explaining how to use npm with Meteor and how good it will be for any Meteor developer or even any Javascript developer. Today I want to explain how you can build anything that you can imagine using this new feature and I will show you an example using Meteor and Flux.</p><p name="fe77" id="fe77" class="graf--p graf-after--h4"><a href="https://facebook.github.io/flux/" class="markup--anchor markup--p-anchor" rel="nofollow">Flux</a> is an application architecture created by Facebook which encourages one-way data flow. This architecture is really good to keep your application sane with more predictable behaviours.</p><p name="c5b8" id="c5b8" class="graf--p graf-after--p">Flux is probably not the best architecture out there (will we ever have a perfect architecture? probably not) but it is good enough for this example. I have been working with it in production environments and it is better than anything I tried before.</p><p name="b6c8" id="b6c8" class="graf--p graf-after--h4"><a href="https://www.meteor.com/" class="markup--anchor markup--p-anchor" rel="nofollow">Meteor</a> is Javascript full stack application platform that let you build your apps fast. And when I say fast, is very fast. You don’t need to worry anymore about ES2015 and how to set it up. No need to worry about how to create Javascript and CSS bundles or reload your browser tab when your code change. Meteor does it for you. And now you can use npm modules as well, so you have thousands of libraries that you can use.</p><p name="c662" id="c662" class="graf--p graf-after--h4">The app is a shared playlist where you can just copy the SoundCloud URL of a song (e.g. <a href="https://soundcloud.com/dariusofficial/hot-hands" class="markup--anchor markup--p-anchor" rel="nofollow">https://soundcloud.com/dariusofficial/hot-hands</a>) and add it to the list. It will be updated across all clients thanks to the Meteor reactivity. To make this app I have used <a href="https://developers.soundcloud.com/docs/api/sdks" class="markup--anchor markup--p-anchor" rel="nofollow">SoundCloud Javascript SDK</a>. Here is how it looks:</p><figure name="f4e4" id="f4e4" class="graf--figure graf-after--p" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://cdn-images-1.medium.com/max/800/1*IQSYGGYOsA4GmskvMvdP4g.png"></div></figure><p name="9d41" id="9d41" class="graf--p graf-after--figure">You can find it as a Github repo:<br><a href="https://github.com/borellvi/meteor-flux" class="markup--anchor markup--p-anchor" rel="nofollow">https://github.com/borellvi/meteor-flux</a></p><p name="ea2b" id="ea2b" class="graf--p graf-after--p">You may find some bugs and there is a lot of stuff that can be polished. If you think that you can improve it, please, make a pull request or even a fork.</p><p name="1cb4" id="1cb4" class="graf--p graf-after--h4">Meteor npm integration will come in the next Meteor release, but if you want to use it now you will have to run:</p><pre name="9a04" id="9a04" class="graf--pre graf-after--p">meteor update --release 1.3-modules-beta.4</pre><p name="902c" id="902c" class="graf--p graf-after--pre">Now you can install the dependencies that you specified in your <em class="markup--em markup--p-em">package.json</em>.</p><pre name="26cf" id="26cf" class="graf--pre graf-after--p">{<br> “dependencies”: { <br> “flux”: “^2.1.1”, <br> “events”: “^1.1.0”<br> }<br>}</pre><p name="6ab4" id="6ab4" class="graf--p graf-after--pre">And run:</p><pre name="448f" id="448f" class="graf--pre graf-after--p">npm install</pre><p name="6248" id="6248" class="graf--p graf-after--pre">For Flux, I mostly followed the patterns found in the <a href="https://github.com/facebook/flux/tree/master/examples/flux-todomvc/" class="markup--anchor markup--p-anchor" rel="nofollow">TodoMVC</a> example but using ES2015.</p><p name="f98c" id="f98c" class="graf--p graf-after--p">To understand how Flux works you have to take a look at this diagram and keep it in your mind:</p><figure name="e88f" id="e88f" class="graf--figure graf-after--p" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://cdn-images-1.medium.com/max/800/1*AuVQqYolW6O60GTHTSgEyQ.png"></div><figcaption class="imageCaption"><a href="https://facebook.github.io/react/blog/2014/07/30/flux-actions-and-the-dispatcher.html" class="markup--anchor markup--figure-anchor" rel="nofollow">https://facebook.github.io/react/blog/2014/07/30/flux-actions-and-the-dispatcher.html</a></figcaption></figure><p name="e9f0" id="e9f0" class="graf--p graf-after--figure">Lets explain how all this works with examples. First of all we have React components, for example, the play button:</p><pre name="b213" id="b213" class="graf--pre graf-after--p">import PlayerActions from '../actions/PlayerActions';</pre><pre name="4080" id="4080" class="graf--pre graf-after--pre">export default PlayButton = React.createClass({<br> handleClick() {<br> PlayerActions.play();<br> },</pre><pre name="3f0c" id="3f0c" class="graf--pre graf-after--pre"> render() {<br> return (<br> &lt;div className=”play-button” onClick={this.handleClick}&gt;...<br> &lt;/div&gt;<br> );<br> }<br>});</pre><p name="1a80" id="1a80" class="graf--p graf-after--pre">This is a normal React component that on click event calls a function in PlayerActions:</p><pre name="e748" id="e748" class="graf--pre graf-after--p">import AppDispatcher from ‘../dispatcher/AppDispatcher’;</pre><pre name="0171" id="0171" class="graf--pre graf-after--pre">const PlayerActions = {<br> play() {<br> AppDispatcher.dispatch({<br> actionType: ‘PLAY’<br> });<br> },</pre><pre name="815b" id="815b" class="graf--pre graf-after--pre"> pause() {<br> AppDispatcher.dispatch({<br> actionType: ‘PAUSE’<br> });<br> },</pre><pre name="9086" id="9086" class="graf--pre graf-after--pre"> ...<br>};</pre><p name="d110" id="d110" class="graf--p graf-after--pre">PlayerActions simply calls dispatch on the AppDispatcher.</p><p name="51c9" id="51c9" class="graf--p graf-after--p">AppDispatcher handles that call and triggers actions. The store is listening for these dispatched actions. You can listen to the actions that you are interested in:</p><pre name="2191" id="2191" class="graf--pre graf-after--p">...</pre><pre name="9a70" id="9a70" class="graf--pre graf-after--pre">function play() {<br> SoundCloudService.play(currentTrack());<br>}<br>...</pre><pre name="6e16" id="6e16" class="graf--pre graf-after--pre">AppDispatcher.register((action) =&gt; {<br> switch (action.actionType) {<br> case ‘PLAY’:<br> play();<br> PlayerStore.emitChange();<br> break;<br> ...<br>});</pre><p name="0dcd" id="0dcd" class="graf--p graf-after--pre">Then, the one-way flow is finished, because React views listen stores for changes, e.g. the buttons component is listening for changes in isPlaying from the PlayerStore.</p><pre name="835d" id="835d" class="graf--pre graf-after--p">...</pre><pre name="03fc" id="03fc" class="graf--pre graf-after--pre">function getPlayerState() {<br> return {<br> isPlaying: PlayerStore.isPlaying()<br> };<br>}</pre><pre name="0b71" id="0b71" class="graf--pre graf-after--pre">export default Buttons = React.createClass({<br> getInitialState() {<br> return getPlayerState();<br> },</pre><pre name="f3dd" id="f3dd" class="graf--pre graf-after--pre"> componentDidMount() {<br> PlayerStore.addChangeListener(this._onChange);<br> },</pre><pre name="608a" id="608a" class="graf--pre graf-after--pre"> componentWillUnmount() {<br> PlayerStore.removeChangeListener(this._onChange);<br> },</pre><pre name="f3f5" id="f3f5" class="graf--pre graf-after--pre"> _onChange() {<br> this.setState(getPlayerState());<br> },</pre><pre name="d4a2" id="d4a2" class="graf--pre graf-after--pre"> render() {<br> ...</pre><p name="0584" id="0584" class="graf--p graf-after--pre">If you take a look at the diagram again you will see some boxes named “Web API” and “Web API Utils”. These two names are really generic but they can be understood as asynchronous services. In our case our service is SoundCloudService which calls the SDK and triggers some actions.</p><pre name="e564" id="e564" class="graf--pre graf-after--p">SC.stream(`/tracks/${track.id}`).then((player) =&gt; {<br> SC.player = player;<br> SC.player.play();<br> SC.player.on(‘finish’, ()=&gt; {<br> PlayerActions.next();<br> });<br>});</pre><p name="95c2" id="95c2" class="graf--p graf-after--pre">All of this makes tests easy to isolate and the state of the application more predictable.</p><p name="7a79" id="7a79" class="graf--p graf-after--p">How does Meteor fit in to all of this? We need Meteor to dispatch actions like services and React components do. To archive this we need to observe the changes in our collections and dispatch actions. Here is how we do it in this project:</p><pre name="c853" id="c853" class="graf--pre graf-after--p">Tracks.find().observe({<br> added: () =&gt; {<br> ServerActions.tracksChanged();<br> }<br>});</pre><p name="d1aa" id="d1aa" class="graf--p graf-after--pre">Since Meteor can be called globally we don’t need to trigger actions for adding songs. We can just call this from our React component.</p><pre name="e2da" id="e2da" class="graf--pre graf-after--p">Meteor.call(‘addTrack’, text);</pre><p name="6e8a" id="6e8a" class="graf--p graf-after--pre">But we could trigger actions as well.</p><p name="8b85" id="8b85" class="graf--p graf-after--p">Another interesting part is that since we use React as a Meteor package and not as a npm module we don’t need to have the store to populate the component, we can use the build-in method:</p><pre name="ad21" id="ad21" class="graf--pre graf-after--p">getMeteorData() {<br> return {<br> tracks: Tracks.find({}).fetch()<br> };<br>}</pre><p name="8451" id="8451" class="graf--p graf-after--pre">We use ES2015 modules syntax. This is optional but I consider it a good practice.</p><pre name="d0e0" id="d0e0" class="graf--pre graf-after--p">import { Dispatcher } from ‘flux’;</pre><pre name="5727" id="5727" class="graf--pre graf-after--pre">const AppDispatcher = new Dispatcher();</pre><pre name="c6a2" id="c6a2" class="graf--pre graf-after--pre">export default AppDispatcher;</pre><p name="6369" id="6369" class="graf--p graf-after--h3 graf--last">This is just an example of how easy can be to create an app with Meteor and any front-end framework that you can find out there. I think that it is really developer friendly since it require almost no set up compared with any other modern project. Moreover, Meteor still getting better every day and it is a platform to keep in mind, even for more serious projects.</p></div></div></section>
</body></html>
