<!DOCTYPE html><html><head><title>Persisting Go objects to disk</title></head><body>
<h1>Persisting Go objects to disk</h1><p><a href="https://medium.com/@matryer/golang-advent-calendar-day-eleven-persisting-go-objects-to-disk-7caf1ee3d11d" target="_new">Original URL</a></p>
<p><blockquote>Today we’re going to write a simple package that lets us save Go objects to disk, and read them back.We’ll expose two main functions:func Save(path string, v interface{}) errorfunc Load(path string,&hellip;</blockquote></p>
<section name="8495" class=" section--body section--first section--last" score="41.25"><div class="section-content" score="31.25"><div class="section-inner layoutSingleColumn"><p name="1cc0" id="1cc0" class="graf--p graf-after--h3">Today we’re going to write a simple package that lets us save Go objects to disk, and read them back.</p><p name="c271" id="c271" class="graf--p graf-after--p">We’ll expose two main functions:</p><pre name="b0c5" id="b0c5" class="graf--pre graf-after--p">func Save(path string, v interface{}) error</pre><pre name="7b02" id="7b02" class="graf--pre graf-after--pre">func Load(path string, v interface{}) error</pre><p name="0840" id="0840" class="graf--p graf-after--pre">We’ll specify a path and a target object in both cases, and have our package Save and Load that object to the location on disk.</p><p name="d654" id="d654" class="graf--p graf-after--h4">Since we don’t want our users to have to worry about how they use our package (they might well want to be loading and saving things in many goroutines at the same time), we are going to make our code safe.</p><p name="8f8a" id="8f8a" class="graf--p graf-after--p">We’re going to use a mutual exclusion lock provided to us via the sync.Mutex type from the standard library.</p><p name="af88" id="af88" class="graf--p graf-after--p">Inside both of our functions, we’ll lock (and then unlock) this mutex to make sure we don’t try and read and write from files at the same time.</p><p name="d025" id="d025" class="graf--p graf-after--p">Create a file called persist.go, and add the mutex:</p><pre name="aa3c" id="aa3c" class="graf--pre graf-after--p">package persist</pre><pre name="f4fd" id="f4fd" class="graf--pre graf-after--pre">import "sync"</pre><pre name="a912" id="a912" class="graf--pre graf-after--pre">var lock sync.Mutex</pre><p name="e2cf" id="e2cf" class="graf--p graf-after--h4">Let’s get started by writing our Save function:</p><pre name="c6e3" id="c6e3" class="graf--pre graf-after--p">// Save saves a representation of v to the file at path.<br>func Save(path string, v interface{}) error {<br> lock.Lock()<br> defer lock.Unlock()<br>}</pre><p name="8cb2" id="8cb2" class="graf--p graf-after--pre">We are locking our mutex first, and deferring the unlocking for when the function exits.</p><p name="467f" id="467f" class="graf--p graf-after--p">Next, we’re going to create a file using os.Create, and defer the closing of that.</p><pre name="5337" id="5337" class="graf--pre graf-after--p">// Save saves a representation of v to the file at path.<br>func Save(path string, v interface{}) error {<br> lock.Lock()<br> defer lock.Unlock()<br> f, err := os.Create(path)<br> if err != nil {<br> return err<br> }<br> defer f.Close()<br>}</pre><p name="5731" id="5731" class="graf--p graf-after--pre">If an error occurs, we’ll return it. Since we’ve already deferred the unlocking of the mutex, we can be sure that we don’t keep things locked up.</p><p name="cac4" id="cac4" class="graf--p graf-after--h4">Marshalling data refers to encoding it into bytes. Bytes can then be written to the file and unmarshalled later. For now, we’re going to use JSON — because it’s perfect for this sort of thing, but we don’t want our package to insist on that.</p><p name="6a41" id="6a41" class="graf--p graf-after--p">Add the following code to the top of persist.go:</p><pre name="c901" id="c901" class="graf--pre graf-after--p">// Marshal is a function that marshals the object into an<br>// io.Reader.<br>// By default, it uses the JSON marshaller.<br>var Marshal = func(v interface{}) (io.Reader, error) {<br> b, err := json.MarshalIndent(v, "", "\t")<br> if err != nil {<br> return nil, err<br> }<br> return bytes.NewReader(b), nil<br>}</pre><p name="171d" id="171d" class="graf--p graf-after--pre">This is an interesting way of defining functions in Go. Marshal is actually a variable, which can be modified by outside code and which will (provided the function is of the same type) allow people to replace the marshaller with their own.</p><p name="fc9c" id="fc9c" class="graf--p graf-after--p">This one uses json.MarshalIndent which will turn the v object into nicely formatted JSON for us. The ‘interface’ for the function takes an object, and returns an io.Reader — from which the bytes will be read.</p><p name="c255" id="c255" class="graf--p graf-after--p">Let’s update the Save function to use our new Marshal method:</p><pre name="6d56" id="6d56" class="graf--pre graf-after--p">// Save saves a representation of v to the file at path.<br>func Save(path string, v interface{}) error {<br> lock.Lock()<br> defer lock.Unlock()<br> f, err := os.Create(path)<br> if err != nil {<br> return err<br> }<br> defer f.Close()<br> r, err := Marshal(v)<br> if err != nil {<br> return err<br> }<br> _, err = io.Copy(f, r)<br> return err<br>}</pre><p name="c243" id="c243" class="graf--p graf-after--pre">Here we call Marshal, passing in the object and getting back an io.Reader — which we then write into the file using io.Copy.</p><blockquote name="52ac" id="52ac" class="graf--blockquote graf-after--p">The first argument is the number of bytes that were copied, which we’re not interested in — so we use the underscore to dismiss the argument.</blockquote><p name="2c00" id="2c00" class="graf--p graf-after--blockquote">io.Copy is a helper function that copies everything from an io.Reader into an io.Writer.</p><p name="4321" id="4321" class="graf--p graf-after--h4">As you’ve already figured out — unmarshalling is the process of turning bytes back into an object. We’ll use the same trick:</p><pre name="c49d" id="c49d" class="graf--pre graf-after--p">// Unmarshal is a function that unmarshals the data from the<br>// reader into the specified value.<br>// By default, it uses the JSON unmarshaller.<br>var Unmarshal = func(r io.Reader, v interface{}) error {<br> return json.NewDecoder(r).Decode(v)<br>}</pre><p name="5263" id="5263" class="graf--p graf-after--pre">Unmarshal takes an io.Reader (where the bytes will come from), and a target object, and just passes those to the json package of the standard library.</p><p name="0308" id="0308" class="graf--p graf-after--h4">Now we can save data — let’s implement the Load function:</p><pre name="ce00" id="ce00" class="graf--pre graf-after--p">// Load loads the file at path into v.<br>// Use os.IsNotExist() to see if the returned error is due<br>// to the file being missing.<br>func Load(path string, v interface{}) error {<br> lock.Lock()<br> defer lock.Unlock()<br> f, err := os.Open(path)<br> if err != nil {<br> return err<br> }<br> defer f.Close()<br> return Unmarshal(f, v)<br>}</pre><p name="cbae" id="cbae" class="graf--p graf-after--pre">Firstly we lock our mutex (just in case people try to Load data that’s also being Saved at the same time), and defer the unlocking in the same way we did for our Save function.</p><p name="e6f3" id="e6f3" class="graf--p graf-after--p">We use os.Open to open the path for reading, before passing the file to Unmarshal. The closing of the file is deferred, so it will get tidied up once Unmarshal has finished with it.</p><pre name="2b79" id="2b79" class="graf--pre graf-after--h4">type obj struct {<br> Name string<br> Number int<br> When time.Time<br>}</pre><pre name="e5c1" id="e5c1" class="graf--pre graf-after--pre">func main() {</pre><pre name="69af" id="69af" class="graf--pre graf-after--pre"> o := &amp;obj{<br> Name: "Mat",<br> Number: 47,<br> When: time.Now(),<br> }</pre><pre name="abbf" id="abbf" class="graf--pre graf-after--pre"> if err := Save("./file.tmp", o); err != nil {<br> log.Fatalln(err)<br> }</pre><pre name="45f8" id="45f8" class="graf--pre graf-after--pre"> // load it back<br> var o2 obj<br> if err := Load("./file.tmp", o2); err != nil {<br> log.Fatalln(err)<br> }</pre><pre name="98d9" id="98d9" class="graf--pre graf-after--pre"> // o and o2 are now the same<br> // and check out file.tmp - you'll see the JSON file</pre><pre name="9ef6" id="9ef6" class="graf--pre graf-after--pre">}</pre><p name="c049" id="c049" class="graf--p graf-after--h4">I’m one of those teachers at school that gives you homework even though it’s the holidays.</p><p name="d6db" id="d6db" class="graf--p graf-after--p graf--last">See if you can think up a new pair of Marshal/Unmarshal functions that’ll write the data in some different format.</p></div></div></section>
</body></html>
