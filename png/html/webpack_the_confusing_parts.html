<!DOCTYPE html><html><head><title>Webpack — The Confusing Parts</title></head><body>
<h1>Webpack — The Confusing Parts</h1><p><a href="https://medium.com/@rajaraodv/webpack-the-confusing-parts-58712f8fcad9#.1gm9j1689" target="_new">Original URL</a></p>
<p><blockquote>Webpack is the leading module bundler for React and Redux apps. I think folks using Angular 2 and other frameworks are also using it a lot these days.When I first saw a Webpack config file, it looked&hellip;</blockquote></p>
<section name="94c0" class=" section--body section--first section--last" score="41.25"><div class="section-content" score="32.5"><div class="section-inner layoutSingleColumn" score="23.5"><p name="6e1d" id="6e1d" class="graf--p graf-after--h3"><a href="https://webpack.github.io/" class="markup--anchor markup--p-anchor" rel="nofollow">Webpack</a> is the leading module bundler for React and Redux apps. I think folks using <a href="https://github.com/AngularClass/angular2-webpack-starter" class="markup--anchor markup--p-anchor" rel="nofollow">Angular 2</a> and other frameworks are also using it a lot these days.</p><p name="e512" id="e512" class="graf--p graf-after--p">When I first saw a Webpack config file, it looked very alien-y 👽 and confusing 😱. After playing around with it for some time, <em class="markup--em markup--p-em">I now think that it is because Webpack just has a unique syntax and new philosophies that may cause confusion in the beginning. Incidentally, these philosophies are also responsible for making it so popular.</em></p><p name="ec76" id="ec76" class="graf--p graf-after--p"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">Since it’s confusing to get started, I thought I’ll write a few posts that’ll hopefully make it easy for others to get started and use it’s powerful features.</em></strong><em class="markup--em markup--p-em"> </em><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">Here is the 1st installment.</em></strong></p><p name="d1af" id="d1af" class="graf--p graf-after--h3">Two core philosophies of Webpack are:</p><ol class="postList"><li name="efae" id="efae" class="graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Everything is a module</strong> — Just like JS files can be “modules”, everything else (CSS, Images, HTML) can also be modules. That is, you can <strong class="markup--strong markup--li-strong">require(“myJSfile.js”) or require(“myCSSfile.css”)</strong>. This mean we can split any artifact into smaller manageable pieces, reuse them and so on.</li><li name="20c6" id="20c6" class="graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Load only “what” you need and “when” you need</strong> — Typically module bundlers take all the modules and generate a large single output “bundle.js” file. <strong class="markup--strong markup--li-strong">But in many real-world apps, this “bundle.js” could be 10MB-15MB and could take forever to load! </strong>So Webpack has various features to <strong class="markup--strong markup--li-strong">split your code </strong>and generate multiple “bundle” files, and<strong class="markup--strong markup--li-strong"> also load parts of the app asynchronously</strong> so that you just load <em class="markup--em markup--li-em">what you need and when you need it.</em></li></ol><p name="b713" id="b713" class="graf--p graf-after--li">OK, Let’s take a look at various “confusing” parts.</p><p name="3861" id="3861" class="graf--p graf-after--h3">First thing to be aware of is that Webpack has <strong class="markup--strong markup--p-strong">tons</strong> <strong class="markup--strong markup--p-strong">of features</strong>. Some are for “Development-only”, some others are for “Production-only” and some are for both “Production-and-Development”.</p><blockquote name="4c30" id="4c30" class="graf--blockquote graf-after--p">Note: You can click on the pictures to zoom and read.</blockquote><figure name="a106" id="a106" class="graf--figure graf-after--blockquote" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://d262ilb51hltx0.cloudfront.net/max/800/1*WCAdMi04IFEWdngK8bkFcw.png"></div><figcaption class="imageCaption">A sample dev v/s prod Webpack files</figcaption></figure><blockquote name="f21f" id="f21f" class="graf--blockquote graf-after--figure">Typically most projects use so many features that they usually have two large Webpack config files.</blockquote><p name="e55a" id="e55a" class="graf--p graf-after--blockquote">And to create bundles you’ll write scripts in the <strong class="markup--strong markup--p-strong">package.json</strong> like so:</p><pre name="d9c3" id="d9c3" class="graf--pre graf-after--p"> “scripts”: {<br> //<strong class="markup--strong markup--pre-strong">npm run build</strong> to build production bundles<br> “build”: “webpack --config webpack.config.prod.js”,</pre><pre name="ecc2" id="ecc2" class="graf--pre graf-after--pre"> //<strong class="markup--strong markup--pre-strong">npm run dev</strong> to generate development bundles and run dev. server<br> “dev”: “webpack-dev-server”<br> }</pre><p name="3edc" id="3edc" class="graf--p graf-after--h3">It’s important to note that Webpack, the module bundler, provides two interfaces:</p><ol class="postList"><li name="a4aa" id="a4aa" class="graf--li graf-after--p">Webpack CLI tool — the default interface (installed as part of Webpack itself)</li><li name="2bd9" id="2bd9" class="graf--li graf-after--li">webpack-dev-server tool — A Node.js server (You need to install it separately)</li></ol><p name="b75e" id="b75e" class="graf--p graf-after--h4">This tool takes options via CLI and also via a config file (default: webpack.config.js) and gives it to the Webpack for bundling.</p><blockquote name="12fa" id="12fa" class="graf--blockquote graf-after--p">While you may start learning Webpack using the CLI, you’ll only mostly use it for generating production builds afterwards.</blockquote><p name="c353" id="c353" class="graf--p graf-after--blockquote"><strong class="markup--strong markup--p-strong">Usage:</strong></p><pre name="15e1" id="15e1" class="graf--pre graf-after--p">OPTION 1: </pre><pre name="3293" id="3293" class="graf--pre graf-after--pre">//Install it globally<br><strong class="markup--strong markup--pre-strong">npm install webpack --g</strong></pre><pre name="bdef" id="bdef" class="graf--pre graf-after--pre">//Use it at the terminal <br><strong class="markup--strong markup--pre-strong">$ wepback</strong> //&lt;--Generates bundle using webpack.config.js</pre><pre name="1335" id="1335" class="graf--pre graf-after--pre"><br>OPTION 2 :</pre><pre name="0e24" id="0e24" class="graf--pre graf-after--pre">//Install it locally &amp; add it to package.json<br><strong class="markup--strong markup--pre-strong">npm install webpack --save</strong></pre><pre name="0b40" id="0b40" class="graf--pre graf-after--pre">//Add it to package.json's script <br><strong class="markup--strong markup--pre-strong">“scripts”: {<br> “build”: “webpack --config webpack.config.prod.js -p”,<br> ...<br> }</strong></pre><pre name="df38" id="df38" class="graf--pre graf-after--pre">//Use it by running the following:<br>"<strong class="markup--strong markup--pre-strong">npm run build</strong>"</pre><p name="20bc" id="20bc" class="graf--p graf-after--h4">This is an Express node.js server that runs at port <strong class="markup--strong markup--p-strong">8080</strong>. This server internally calls Webpack. The benefit of this is that it provides additional capabilities like reloading the browser <strong class="markup--strong markup--p-strong">i.e.</strong> “<strong class="markup--strong markup--p-strong">Live Reloading</strong>” and/or replacing just the changed module <strong class="markup--strong markup--p-strong">i.e</strong> “<strong class="markup--strong markup--p-strong">Hot Module Replacement” (HMR)</strong>.</p><p name="05a9" id="05a9" class="graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Usage:</strong></p><pre name="8061" id="8061" class="graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong"><em class="markup--em markup--pre-em">OPTION 1:</em></strong></pre><pre name="21c1" id="21c1" class="graf--pre graf-after--pre">//Install it globally<br><strong class="markup--strong markup--pre-strong">npm install webpack-dev-server --save</strong></pre><pre name="6f5a" id="6f5a" class="graf--pre graf-after--pre">//Use it at the terminal<br><strong class="markup--strong markup--pre-strong">$ wepback-dev-server --inline --hot</strong></pre><pre name="3eff" id="3eff" class="graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong"><em class="markup--em markup--pre-em">OPTION 2:</em></strong></pre><pre name="64aa" id="64aa" class="graf--pre graf-after--pre">// Add it to package.json's script <br><br><strong class="markup--strong markup--pre-strong">“scripts”: {<br> “start”: “webpack-dev-server --inline --hot”,<br> ...<br> }</strong></pre><pre name="dba4" id="dba4" class="graf--pre graf-after--pre">// Use it by running <br><strong class="markup--strong markup--pre-strong">$ npm start</strong></pre><pre name="9fe6" id="9fe6" class="graf--pre graf-after--pre">Open browser at:<br><strong class="markup--strong markup--pre-strong">http://localhost:8080</strong></pre><p name="4a0d" id="4a0d" class="graf--p graf-after--h4">It’s worth noting that some of the options like “inline” and “hot” are webpack-dev-server <em class="markup--em markup--p-em">only</em> options. Where as some others like “hide-modules” are CLI only options.</p><p name="fabc" id="fabc" class="graf--p graf-after--h4">The other thing to note is you can pass options to webpack-dev-server in two ways:</p><ol class="postList"><li name="6b0f" id="6b0f" class="graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Through webpack.config.js’s “devserver” object.</strong></li><li name="42a0" id="42a0" class="graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Through </strong>CLI options.</li></ol><pre name="2981" id="2981" class="graf--pre graf-after--li">//Via CLI<br>webpack-dev-server --hot --inline</pre><pre name="5d7d" id="5d7d" class="graf--pre graf-after--pre">//Via webpack.config.js<br>devServer: {<br> inline: true,<br> hot:true<br> }</pre><blockquote name="8e00" id="8e00" class="graf--blockquote graf-after--pre">I’ve found that sometimes the devServer config (hot:true and inline:true) doesn’t work! So I prefer just passing options as CLI options within package.json like so:</blockquote><pre name="e8bf" id="e8bf" class="graf--pre graf-after--blockquote">//package.json<br>{<br>scripts: <br> {“start”: “webpack-dev-server --hot --inline”}<br>}</pre><blockquote name="f4fd" id="f4fd" class="graf--blockquote graf-after--pre"><strong class="markup--strong markup--blockquote-strong">Note: Make sure you are not passing hot:true and -hot both together.</strong></blockquote><p name="aecd" id="aecd" class="graf--p graf--startsWithDoubleQuote graf-after--h4">“inline” option adds “Live reloading” for the entire page. “hot” option enables “Hot Module Reloading” that tries to reload just the component that’s changed (instead of the entire page). If we pass both options, then, when the source changes, the webpack-dev-server will try to HMR first. If that doesn’t work, then it will reload the entire page.</p><pre name="902f" id="902f" class="graf--pre graf-after--p">//When the source changes, all 3 options generates new bundle but,<br> <br>//1. doesn't reload the browser page<br>$ webpack-dev-server</pre><pre name="c715" id="c715" class="graf--pre graf-after--pre">//2. reloads the entire browser page<br>$ webpack-dev-server --inline</pre><pre name="b26f" id="b26f" class="graf--pre graf-after--pre">//3. reloads just the module(HMR), or the entire page if HMR fails<br>$ webpack-dev-server --inline --hot</pre><p name="f990" id="f990" class="graf--p graf-after--h3"><strong class="markup--strong markup--p-strong">Entry</strong> tells the Webpack where the root module or the starting point is. This can be a String, an Array or an Object. This could confuse you but the different types are used for different purposes.</p><p name="2e60" id="2e60" class="graf--p graf-after--p">If you have a single starting point (like most apps), you can use any format and the result will be the same.</p><figure name="c79a" id="c79a" class="graf--figure graf-after--p" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://d262ilb51hltx0.cloudfront.net/max/800/1*OnXpfv4zjL-5zO2Ha6mXDw.png"></div><figcaption class="imageCaption">Different entry types but same output</figcaption></figure><p name="9f68" id="9f68" class="graf--p graf-after--h4">But, if you want to append multiple files that are <strong class="markup--strong markup--p-strong">NOT dependent on each other</strong>, you can use the Array format.</p><p name="6a1d" id="6a1d" class="graf--p graf-after--p">For example: you may need “googleAnalytics.js” in your HTML. You can tell Webpack to append it to the end of the bundle.js like so:</p><figure name="d3e9" id="d3e9" class="graf--figure graf-after--p" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://d262ilb51hltx0.cloudfront.net/max/800/1*yLVdS3oN4Xo8KInoTIfi0A.png"></div></figure><p name="2cf3" id="2cf3" class="graf--p graf-after--h4">Now, let’s say you have <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">true</em></strong> multi-page application, not a SPA w/ multi-views, but with multiple HTML files (index.html and profile.html). You can then tell Webpack<strong class="markup--strong markup--p-strong"> to generate multiple bundles at once by using entry object.</strong></p><p name="0fab" id="0fab" class="graf--p graf-after--p">The below config will generate two JS files: <strong class="markup--strong markup--p-strong">indexEntry.js and profileEntry.js that you can use in index.html and profile.html respectively.</strong></p><figure name="af55" id="af55" class="graf--figure graf-after--p" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://d262ilb51hltx0.cloudfront.net/max/800/1*xB51RRC4ik6BBP2lJ90Iuw.png"></div></figure><p name="bf54" id="bf54" class="graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">Usage:</strong></p><pre name="2634" id="2634" class="graf--pre graf-after--p">//profile.html<br>&lt;script src=”dist/profileEntry.js”&gt;&lt;/script&gt;</pre><pre name="15a0" id="15a0" class="graf--pre graf-after--pre">//index.html<br>&lt;script src=”dist/indexEntry.js”&gt;&lt;/script&gt;</pre><p name="3093" id="3093" class="graf--p graf-after--pre"><em class="markup--em markup--p-em">Note: The name of the file comes from the “entry” object’s keys.</em></p><p name="bb2c" id="bb2c" class="graf--p graf-after--h4">You can also use the Array type entries inside an entry object. For example the below config will generate 3 files: vendor.js that contains three vendor files, an index.js and a profile.js.</p><figure name="eb8a" id="eb8a" class="graf--figure graf-after--p" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://d262ilb51hltx0.cloudfront.net/max/800/1*yz76QY1fVzBGKJ-6X6Eleg.png"></div></figure><p name="1139" id="1139" class="graf--p graf-after--h3"><strong class="markup--strong markup--p-strong">output</strong> tells the Webpack where and how to store the resulting files. It has two properties “path” and “publicPath” that could be confusing.</p><p name="6749" id="6749" class="graf--p graf--startsWithDoubleQuote graf-after--p">“path” simply tells the Webpack where it should store the result. Where as “publicPath” is used by several Webpack’s plugins to update the URLs inside CSS, HTML files when generating <strong class="markup--strong markup--p-strong">production</strong> builds.</p><figure name="6d89" id="6d89" class="graf--figure graf-after--p" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://d262ilb51hltx0.cloudfront.net/max/800/1*63Zta4mbC_3o44QdycrD7Q.png"></div><figcaption class="imageCaption">publicPath in Development vs Production</figcaption></figure><p name="69b0" id="69b0" class="graf--p graf-after--figure">For example, in your CSS, you may have a url to load ‘./test.png’ on your localhost. But in production, the ‘<em class="markup--em markup--p-em">test.png’</em> might actually be located at a CDN while your node.js server might be running on <a href="https://heroku.com" class="markup--anchor markup--p-anchor" rel="nofollow"><strong class="markup--strong markup--p-strong">Heroku</strong></a>. <strong class="markup--strong markup--p-strong">So that means, you’ll have to manually update the URLs in all the files to point to the CDN when running in Production.</strong></p><p name="95ff" id="95ff" class="graf--p graf-after--p">Instead, you can use Webpack’s <strong class="markup--strong markup--p-strong">publicPath</strong> and use bunch of plugins that are publicPath-aware to automatically update URLs when generating production builds.</p><blockquote name="020d" id="020d" class="graf--blockquote graf-after--p">Note: You can click on the pictures to zoom and read</blockquote><figure name="f6d2" id="f6d2" class="graf--figure graf-after--blockquote" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://d262ilb51hltx0.cloudfront.net/max/800/1*aOM5ZF8alWLr4BC0CfZe0w.png"></div><figcaption class="imageCaption">publicPath Production example</figcaption></figure><pre name="cf5c" id="cf5c" class="graf--pre graf-after--figure">// Development: Both Server and the image are on localhost<br>.image { <br> background-image: url(‘./test.png’);<br> }</pre><pre name="61cc" id="61cc" class="graf--pre graf-after--pre">// Production: Server is on Heroku but the image is on a CDN<br>.image { <br> background-image: url(‘https://someCDN/test.png’);<br> }</pre><p name="5fbf" id="5fbf" class="graf--p graf-after--h3">Loaders are additional node modules that help ‘load’ or ‘import’ files of various types into browser acceptable formats like JS, Stylesheets and so on. Further loaders also allow importing such files into JS via “require” or “import” in ES6.</p><p name="4949" id="4949" class="graf--p graf-after--p">For example: You can use <strong class="markup--strong markup--p-strong">babel-loader</strong> to convert JS written in ES6 to browser acceptable ES5 like so:</p><pre name="3a87" id="3a87" class="graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">module: {<br> loaders: [{<br> test: /\.js$/, </strong>←Test for ".js" file, if it passes, use the loader<strong class="markup--strong markup--pre-strong"><br> exclude: /node_modules/, </strong>←Exclude node_modules folder<strong class="markup--strong markup--pre-strong"><br> loader: ‘babel’</strong> ←use babel (short for ‘babel-loader’)<strong class="markup--strong markup--pre-strong"><br> }]</strong></pre><p name="b3c7" id="b3c7" class="graf--p graf-after--h4">Multiple Loaders can be chained and made to work on the same file type. The chaining works from <strong class="markup--strong markup--p-strong">right-to-left and the loader are separated by “!”</strong>.</p><p name="79fe" id="79fe" class="graf--p graf-after--p">For example, Let’s say we have a CSS file “myCssFile.css” and we want to dump it’s content into &lt;script&gt; tag inside our HTML. We can accomplish that using two loaders: css-loader and style-loader.</p><pre name="18b9" id="18b9" class="graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">module: {<br> loaders: [{</strong><br> test: /\.css$/,<br> loader: ‘style!css’ <strong class="markup--strong markup--pre-strong">&lt;--(short for style-loader!css-loader)</strong><br> <strong class="markup--strong markup--pre-strong">}]</strong></pre><p name="04e4" id="04e4" class="graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Here is how it works:</strong></p><figure name="9a9e" id="9a9e" class="graf--figure graf-after--p" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://d262ilb51hltx0.cloudfront.net/max/800/1*nes9iLmskmsD8Fp4Ek3u-A.png"></div></figure><ol class="postList"><li name="bf2a" id="bf2a" class="graf--li graf-after--figure">Webpack searches for CSS files dependencies inside the modules. That is Webpack checks to see if a JS file has “<strong class="markup--strong markup--li-strong">require(myCssFile.css)</strong>”. If it finds the dependency, then the Webpack gives that file <strong class="markup--strong markup--li-strong">first to the</strong> “<strong class="markup--strong markup--li-strong">css-loader”</strong></li><li name="cb70" id="cb70" class="graf--li graf-after--li"><strong class="markup--strong markup--li-strong">css-loader </strong>loads all the CSS and CSS’ own dependencies (i.e @import otherCSS) into JSON. Webpack then passes the result to “style-loader”.</li><li name="6005" id="6005" class="graf--li graf-after--li"><strong class="markup--strong markup--li-strong">style-loader</strong> to take the JSON and add it to a script tag — <strong class="markup--strong markup--li-strong">&lt;script&gt;CSS contents&lt;/script&gt;</strong> and inserts the tag into the index.html file.</li></ol><p name="c8d5" id="c8d5" class="graf--p graf-after--h3">Loaders themselves can be configured to work differently by passing parameters.</p><p name="45de" id="45de" class="graf--p graf-after--p">In the example below, we are configuring <strong class="markup--strong markup--p-strong">url-loader</strong> to use URLs for images larger than 1024 bytes and embed images that are less than 1024 bytes. We can do this by passing “limit” parameter in the <strong class="markup--strong markup--p-strong">following two ways:</strong></p><figure name="7247" id="7247" class="graf--figure graf-after--p" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://d262ilb51hltx0.cloudfront.net/max/800/1*-qVdcA3E8JSdtszxHqfIdA.png"></div></figure><p name="3def" id="3def" class="graf--p graf-after--h3">babel-loader uses “presets” configuration to know how to convert ES6 to ES5 and also how to parse React’s JSX to JS. We can pass the configuration via “query” parameter like below:</p><pre name="f15f" id="f15f" class="graf--pre graf-after--p">module: {<br> loaders: [<br> {<br> test: /<strong class="markup--strong markup--pre-strong">\.</strong>jsx?$/,<br> exclude: /(node_modules|bower_components)/,<br> loader: 'babel',<br> <strong class="markup--strong markup--pre-strong"> query: {<br> presets: ['react', 'es2015']<br> }</strong><br> }<br> ]<br>}</pre><p name="de95" id="de95" class="graf--p graf-after--pre">However in many projects babel’s configuration can become very large. So Webpack let’s us to keep babel-loader’s configuration in babel’s own configuration file called <strong class="markup--strong markup--p-strong">.babelrc</strong> file.</p><p name="9f8f" id="9f8f" class="graf--p graf-after--p">So in many examples, you’ll see:</p><pre name="b605" id="b605" class="graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">//webpack.config.js </strong><br>module: {<br> loaders: [<br> {<br> test: /<strong class="markup--strong markup--pre-strong">\.</strong>jsx?$/,<br> exclude: /(node_modules|bower_components)/,<br> loader: 'babel'<br> }<br> ]<br>}</pre><pre name="866c" id="866c" class="graf--pre graf-after--pre"><br><strong class="markup--strong markup--pre-strong">//.bablerc</strong><br>{<br> “presets”: [“react”, “es2015”]<br>}</pre><p name="60c8" id="60c8" class="graf--p graf-after--h3">Plugins are additional node modules that usually work on the resulting bundle.</p><p name="a27f" id="a27f" class="graf--p graf-after--p">For example, <a href="https://webpack.github.io/docs/list-of-plugins.html#uglifyjsplugin" class="markup--anchor markup--p-anchor" rel="nofollow"><strong class="markup--strong markup--p-strong">uglifyJSPlugin</strong></a> takes the bundle.js and minimizes and obfuscates the contents to decrease the file size.</p><p name="0a88" id="0a88" class="graf--p graf-after--p">Similarly <a href="https://github.com/webpack/extract-text-webpack-plugin" class="markup--anchor markup--p-anchor" rel="nofollow"><strong class="markup--strong markup--p-strong">extract-text-webpack-plugin</strong></a> internally uses <strong class="markup--strong markup--p-strong">css-loader</strong> and <strong class="markup--strong markup--p-strong">style-loader</strong> to gather all the CSS into one place and finally extracts the result into a separate external<strong class="markup--strong markup--p-strong"> styles.css</strong> file and includes the link to <strong class="markup--strong markup--p-strong">style.css</strong> into <strong class="markup--strong markup--p-strong">index.html</strong></p><pre name="b885" id="b885" class="graf--pre graf-after--p">//webpack.config.js<br>//Take all the .css files, combine their contents and it extract them to a single "styles.css"</pre><pre name="49be" id="49be" class="graf--pre graf-after--pre">var ETP = require("extract-text-webpack-plugin");<br><br>module: {<br> loaders: [<br> {test: /<strong class="markup--strong markup--pre-strong">\.</strong>css$/, loader:ETP.extract("style-loader","css-loader") }<br> ]<br>},</pre><pre name="0a6c" id="0a6c" class="graf--pre graf-after--pre">plugins: [<br> new ExtractTextPlugin("styles.css") //Extract to styles.css file<br> ]<br>}</pre><p name="185b" id="185b" class="graf--p graf-after--pre">Note: If you want to just inline CSS as a <strong class="markup--strong markup--p-strong">style</strong> element into HTML, you can do that without the <a href="https://github.com/webpack/extract-text-webpack-plugin" class="markup--anchor markup--p-anchor" rel="nofollow"><strong class="markup--strong markup--p-strong">extract-text-webpack-plugin</strong></a> and by just CSS and Style <strong class="markup--strong markup--p-strong">loaders</strong> like below:</p><pre name="4e02" id="4e02" class="graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">module: {<br> loaders: [{</strong><br> test: /\.css$/,<br> loader: ‘style!css’ <strong class="markup--strong markup--pre-strong">&lt;--(short for style-loader!css-loader)</strong><br> <strong class="markup--strong markup--pre-strong">}]</strong></pre><p name="d1fe" id="d1fe" class="graf--p graf-after--h3">As you might have realized, <strong class="markup--strong markup--p-strong">Loaders</strong> <strong class="markup--strong markup--p-strong">work at the individual file level during or before </strong>the<strong class="markup--strong markup--p-strong"> </strong>bundle is generated.</p><p name="c99f" id="c99f" class="graf--p graf-after--p">Where as <strong class="markup--strong markup--p-strong">Plugins</strong> <strong class="markup--strong markup--p-strong">work at bundle or chunk level and usually work at the end of the bundle generation process</strong>. And some Plugins like <a href="https://webpack.github.io/docs/list-of-plugins.html#commonschunkplugin" class="markup--anchor markup--p-anchor" rel="nofollow">commonsChunksPlugins</a> go even further and modify how the bundles themselves are created.</p><p name="9d4a" id="9d4a" class="graf--p graf-after--h3">Many Webpack config files have a <strong class="markup--strong markup--p-strong">resolve extensions </strong>property that has an <strong class="markup--strong markup--p-strong">empty string </strong>like shown below. The empty string is there to help resolve imports without extensions like:<strong class="markup--strong markup--p-strong"> require(“./myJSFile”) or import myJSFile from ‘./myJSFile’ </strong>without file extensions<strong class="markup--strong markup--p-strong">.</strong></p><pre name="fe00" id="fe00" class="graf--pre graf-after--p">{<br> resolve: {<br> extensions: [<strong class="markup--strong markup--pre-strong">‘’</strong>, ‘.js’, ‘.jsx’]<br> }<br>}</pre><p name="8f62" id="8f62" class="graf--p graf-after--pre">That’s it! 👍</p><p name="c838" id="c838" class="graf--p graf-after--li"><em class="markup--em markup--p-em">🎉🎉🎉 </em><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">If you like this post, please 1. </em></strong>❤❤❤<em class="markup--em markup--p-em"> </em><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">it below on Medium and 2. please share it on Twitter. You may retweet the below card</em></strong><em class="markup--em markup--p-em">🎉🎉🎉</em></p><figure name="82c6" id="82c6" class="graf--figure graf--iframe graf-after--p" score="-13.75"></figure><p name="3192" id="3192" class="graf--p graf-after--figure graf--last">Thank you! 🙏</p></div></div></section>
</body></html>
