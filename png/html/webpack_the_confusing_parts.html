<!DOCTYPE html><html><head><title>Webpack â€” The Confusing Parts</title></head><body>
<h1>Webpack â€” The Confusing Parts</h1><p><a href="https://medium.com/@rajaraodv/webpack-the-confusing-parts-58712f8fcad9#.1gm9j1689" target="_new">Original URL</a></p>
<p><blockquote>Webpack is the leading module bundler for React and Redux apps. I think folks using Angular 2 and other frameworks are also using it a lot these days.When I first saw a Webpack config file, it looked&hellip;</blockquote></p>
<section name="94c0" class=" section--body section--first section--last" score="41.25"><div class="section-content" score="32.5"><div class="section-inner layoutSingleColumn" score="23.5"><p name="6e1d" id="6e1d" class="graf--p graf-after--h3"><a href="https://webpack.github.io/" class="markup--anchor markup--p-anchor" rel="nofollow">Webpack</a> is the leading module bundler for React and Redux apps. I think folks using <a href="https://github.com/AngularClass/angular2-webpack-starter" class="markup--anchor markup--p-anchor" rel="nofollow">Angular 2</a> and other frameworks are also using it a lot these days.</p><p name="e512" id="e512" class="graf--p graf-after--p">When I first saw a Webpack config file, it looked very alien-y ğŸ‘½ and confusing ğŸ˜±. After playing around with it for some time, <em class="markup--em markup--p-em">I now think that it is because Webpack just has a unique syntax and new philosophies that may cause confusion in the beginning. Incidentally, these philosophies are also responsible for making it so popular.</em></p><p name="ec76" id="ec76" class="graf--p graf-after--p"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">Since itâ€™s confusing to get started, I thought Iâ€™ll write a few posts thatâ€™ll hopefully make it easy for others to get started and use itâ€™s powerful features.</em></strong><em class="markup--em markup--p-em"> </em><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">Here is the 1st installment.</em></strong></p><p name="d1af" id="d1af" class="graf--p graf-after--h3">Two core philosophies of Webpack are:</p><ol class="postList"><li name="efae" id="efae" class="graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Everything is a module</strong>â€Šâ€”â€ŠJust like JS files can be â€œmodulesâ€, everything else (CSS, Images, HTML) can also be modules. That is, you can <strong class="markup--strong markup--li-strong">require(â€œmyJSfile.jsâ€) or require(â€œmyCSSfile.cssâ€)</strong>. This mean we can split any artifact into smaller manageable pieces, reuse them and so on.</li><li name="20c6" id="20c6" class="graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Load only â€œwhatâ€ you need and â€œwhenâ€ you need</strong>â€Šâ€”â€ŠTypically module bundlers take all the modules and generate a large single output â€œbundle.jsâ€ file. <strong class="markup--strong markup--li-strong">But in many real-world apps, this â€œbundle.jsâ€ could be 10MB-15MB and could take forever to load! </strong>So Webpack has various features to <strong class="markup--strong markup--li-strong">split your code </strong>and generate multiple â€œbundleâ€ files, and<strong class="markup--strong markup--li-strong"> also load parts of the app asynchronously</strong> so that you just load <em class="markup--em markup--li-em">what you need and when you need it.</em></li></ol><p name="b713" id="b713" class="graf--p graf-after--li">OK, Letâ€™s take a look at various â€œconfusingâ€ parts.</p><p name="3861" id="3861" class="graf--p graf-after--h3">First thing to be aware of is that Webpack has <strong class="markup--strong markup--p-strong">tons</strong> <strong class="markup--strong markup--p-strong">of features</strong>. Some are for â€œDevelopment-onlyâ€, some others are for â€œProduction-onlyâ€ and some are for both â€œProduction-and-Developmentâ€.</p><blockquote name="4c30" id="4c30" class="graf--blockquote graf-after--p">Note: You can click on the pictures to zoom and read.</blockquote><figure name="a106" id="a106" class="graf--figure graf-after--blockquote" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://d262ilb51hltx0.cloudfront.net/max/800/1*WCAdMi04IFEWdngK8bkFcw.png"></div><figcaption class="imageCaption">A sample dev v/s prod Webpack files</figcaption></figure><blockquote name="f21f" id="f21f" class="graf--blockquote graf-after--figure">Typically most projects use so many features that they usually have two large Webpack config files.</blockquote><p name="e55a" id="e55a" class="graf--p graf-after--blockquote">And to create bundles youâ€™ll write scripts in the <strong class="markup--strong markup--p-strong">package.json</strong> like so:</p><pre name="d9c3" id="d9c3" class="graf--pre graf-after--p"> â€œscriptsâ€: {<br> //<strong class="markup--strong markup--pre-strong">npm run build</strong> to build production bundles<br> â€œbuildâ€: â€œwebpack --config webpack.config.prod.jsâ€,</pre><pre name="ecc2" id="ecc2" class="graf--pre graf-after--pre"> //<strong class="markup--strong markup--pre-strong">npm run dev</strong> to generate development bundles and run dev. server<br> â€œdevâ€: â€œwebpack-dev-serverâ€<br> }</pre><p name="3edc" id="3edc" class="graf--p graf-after--h3">Itâ€™s important to note that Webpack, the module bundler, provides two interfaces:</p><ol class="postList"><li name="a4aa" id="a4aa" class="graf--li graf-after--p">Webpack CLI toolâ€Šâ€”â€Šthe default interface (installed as part of Webpack itself)</li><li name="2bd9" id="2bd9" class="graf--li graf-after--li">webpack-dev-server toolâ€Šâ€”â€ŠA Node.js server (You need to install it separately)</li></ol><p name="b75e" id="b75e" class="graf--p graf-after--h4">This tool takes options via CLI and also via a config file (default: webpack.config.js) and gives it to the Webpack for bundling.</p><blockquote name="12fa" id="12fa" class="graf--blockquote graf-after--p">While you may start learning Webpack using the CLI, youâ€™ll only mostly use it for generating production builds afterwards.</blockquote><p name="c353" id="c353" class="graf--p graf-after--blockquote"><strong class="markup--strong markup--p-strong">Usage:</strong></p><pre name="15e1" id="15e1" class="graf--pre graf-after--p">OPTION 1: </pre><pre name="3293" id="3293" class="graf--pre graf-after--pre">//Install it globally<br><strong class="markup--strong markup--pre-strong">npm install webpack --g</strong></pre><pre name="bdef" id="bdef" class="graf--pre graf-after--pre">//Use it at the terminal <br><strong class="markup--strong markup--pre-strong">$ wepback</strong> //&lt;--Generates bundle using webpack.config.js</pre><pre name="1335" id="1335" class="graf--pre graf-after--pre"><br>OPTION 2 :</pre><pre name="0e24" id="0e24" class="graf--pre graf-after--pre">//Install it locally &amp; add it to package.json<br><strong class="markup--strong markup--pre-strong">npm install webpack --save</strong></pre><pre name="0b40" id="0b40" class="graf--pre graf-after--pre">//Add it to package.json's script <br><strong class="markup--strong markup--pre-strong">â€œscriptsâ€: {<br> â€œbuildâ€: â€œwebpack --config webpack.config.prod.js -pâ€,<br> ...<br> }</strong></pre><pre name="df38" id="df38" class="graf--pre graf-after--pre">//Use it by running the following:<br>"<strong class="markup--strong markup--pre-strong">npm run build</strong>"</pre><p name="20bc" id="20bc" class="graf--p graf-after--h4">This is an Express node.js server that runs at port <strong class="markup--strong markup--p-strong">8080</strong>. This server internally calls Webpack. The benefit of this is that it provides additional capabilities like reloading the browser <strong class="markup--strong markup--p-strong">i.e.</strong> â€œ<strong class="markup--strong markup--p-strong">Live Reloading</strong>â€ and/or replacing just the changed module <strong class="markup--strong markup--p-strong">i.e</strong> â€œ<strong class="markup--strong markup--p-strong">Hot Module Replacementâ€ (HMR)</strong>.</p><p name="05a9" id="05a9" class="graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Usage:</strong></p><pre name="8061" id="8061" class="graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong"><em class="markup--em markup--pre-em">OPTION 1:</em></strong></pre><pre name="21c1" id="21c1" class="graf--pre graf-after--pre">//Install it globally<br><strong class="markup--strong markup--pre-strong">npm install webpack-dev-server --save</strong></pre><pre name="6f5a" id="6f5a" class="graf--pre graf-after--pre">//Use it at the terminal<br><strong class="markup--strong markup--pre-strong">$ wepback-dev-server --inline --hot</strong></pre><pre name="3eff" id="3eff" class="graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong"><em class="markup--em markup--pre-em">OPTION 2:</em></strong></pre><pre name="64aa" id="64aa" class="graf--pre graf-after--pre">// Add it to package.json's script <br><br><strong class="markup--strong markup--pre-strong">â€œscriptsâ€: {<br> â€œstartâ€: â€œwebpack-dev-server --inline --hotâ€,<br> ...<br> }</strong></pre><pre name="dba4" id="dba4" class="graf--pre graf-after--pre">// Use it by running <br><strong class="markup--strong markup--pre-strong">$ npm start</strong></pre><pre name="9fe6" id="9fe6" class="graf--pre graf-after--pre">Open browser at:<br><strong class="markup--strong markup--pre-strong">http://localhost:8080</strong></pre><p name="4a0d" id="4a0d" class="graf--p graf-after--h4">Itâ€™s worth noting that some of the options like â€œinlineâ€ and â€œhotâ€ are webpack-dev-server <em class="markup--em markup--p-em">only</em> options. Where as some others like â€œhide-modulesâ€ are CLI only options.</p><p name="fabc" id="fabc" class="graf--p graf-after--h4">The other thing to note is you can pass options to webpack-dev-server in two ways:</p><ol class="postList"><li name="6b0f" id="6b0f" class="graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Through webpack.config.jsâ€™s â€œdevserverâ€ object.</strong></li><li name="42a0" id="42a0" class="graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Through </strong>CLI options.</li></ol><pre name="2981" id="2981" class="graf--pre graf-after--li">//Via CLI<br>webpack-dev-server --hot --inline</pre><pre name="5d7d" id="5d7d" class="graf--pre graf-after--pre">//Via webpack.config.js<br>devServer: {<br> inline: true,<br> hot:true<br> }</pre><blockquote name="8e00" id="8e00" class="graf--blockquote graf-after--pre">Iâ€™ve found that sometimes the devServer config (hot:true and inline:true) doesnâ€™t work! So I prefer just passing options as CLI options within package.json like so:</blockquote><pre name="e8bf" id="e8bf" class="graf--pre graf-after--blockquote">//package.json<br>{<br>scripts: <br> {â€œstartâ€: â€œwebpack-dev-server --hot --inlineâ€}<br>}</pre><blockquote name="f4fd" id="f4fd" class="graf--blockquote graf-after--pre"><strong class="markup--strong markup--blockquote-strong">Note: Make sure you are not passing hot:true and -hot both together.</strong></blockquote><p name="aecd" id="aecd" class="graf--p graf--startsWithDoubleQuote graf-after--h4">â€œinlineâ€ option adds â€œLive reloadingâ€ for the entire page. â€œhotâ€ option enables â€œHot Module Reloadingâ€ that tries to reload just the component thatâ€™s changed (instead of the entire page). If we pass both options, then, when the source changes, the webpack-dev-server will try to HMR first. If that doesnâ€™t work, then it will reload the entire page.</p><pre name="902f" id="902f" class="graf--pre graf-after--p">//When the source changes, all 3 options generates new bundle but,<br> <br>//1. doesn't reload the browser page<br>$ webpack-dev-server</pre><pre name="c715" id="c715" class="graf--pre graf-after--pre">//2. reloads the entire browser page<br>$ webpack-dev-server --inline</pre><pre name="b26f" id="b26f" class="graf--pre graf-after--pre">//3. reloads just the module(HMR), or the entire page if HMR fails<br>$ webpack-dev-server --inline --hot</pre><p name="f990" id="f990" class="graf--p graf-after--h3"><strong class="markup--strong markup--p-strong">Entry</strong> tells the Webpack where the root module or the starting point is. This can be a String, an Array or an Object. This could confuse you but the different types are used for different purposes.</p><p name="2e60" id="2e60" class="graf--p graf-after--p">If you have a single starting point (like most apps), you can use any format and the result will be the same.</p><figure name="c79a" id="c79a" class="graf--figure graf-after--p" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://d262ilb51hltx0.cloudfront.net/max/800/1*OnXpfv4zjL-5zO2Ha6mXDw.png"></div><figcaption class="imageCaption">Different entry types but same output</figcaption></figure><p name="9f68" id="9f68" class="graf--p graf-after--h4">But, if you want to append multiple files that are <strong class="markup--strong markup--p-strong">NOT dependent on each other</strong>, you can use the Array format.</p><p name="6a1d" id="6a1d" class="graf--p graf-after--p">For example: you may need â€œgoogleAnalytics.jsâ€ in your HTML. You can tell Webpack to append it to the end of the bundle.js like so:</p><figure name="d3e9" id="d3e9" class="graf--figure graf-after--p" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://d262ilb51hltx0.cloudfront.net/max/800/1*yLVdS3oN4Xo8KInoTIfi0A.png"></div></figure><p name="2cf3" id="2cf3" class="graf--p graf-after--h4">Now, letâ€™s say you have <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">true</em></strong> multi-page application, not a SPA w/ multi-views, but with multiple HTML files (index.html and profile.html). You can then tell Webpack<strong class="markup--strong markup--p-strong"> to generate multiple bundles at once by using entry object.</strong></p><p name="0fab" id="0fab" class="graf--p graf-after--p">The below config will generate two JS files: <strong class="markup--strong markup--p-strong">indexEntry.js and profileEntry.js that you can use in index.html and profile.html respectively.</strong></p><figure name="af55" id="af55" class="graf--figure graf-after--p" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://d262ilb51hltx0.cloudfront.net/max/800/1*xB51RRC4ik6BBP2lJ90Iuw.png"></div></figure><p name="bf54" id="bf54" class="graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">Usage:</strong></p><pre name="2634" id="2634" class="graf--pre graf-after--p">//profile.html<br>&lt;script src=â€dist/profileEntry.jsâ€&gt;&lt;/script&gt;</pre><pre name="15a0" id="15a0" class="graf--pre graf-after--pre">//index.html<br>&lt;script src=â€dist/indexEntry.jsâ€&gt;&lt;/script&gt;</pre><p name="3093" id="3093" class="graf--p graf-after--pre"><em class="markup--em markup--p-em">Note: The name of the file comes from the â€œentryâ€ objectâ€™s keys.</em></p><p name="bb2c" id="bb2c" class="graf--p graf-after--h4">You can also use the Array type entries inside an entry object. For example the below config will generate 3 files: vendor.js that contains three vendor files, an index.js and a profile.js.</p><figure name="eb8a" id="eb8a" class="graf--figure graf-after--p" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://d262ilb51hltx0.cloudfront.net/max/800/1*yz76QY1fVzBGKJ-6X6Eleg.png"></div></figure><p name="1139" id="1139" class="graf--p graf-after--h3"><strong class="markup--strong markup--p-strong">output</strong> tells the Webpack where and how to store the resulting files. It has two properties â€œpathâ€ and â€œpublicPathâ€ that could be confusing.</p><p name="6749" id="6749" class="graf--p graf--startsWithDoubleQuote graf-after--p">â€œpathâ€ simply tells the Webpack where it should store the result. Where as â€œpublicPathâ€ is used by several Webpackâ€™s plugins to update the URLs inside CSS, HTML files when generating <strong class="markup--strong markup--p-strong">production</strong> builds.</p><figure name="6d89" id="6d89" class="graf--figure graf-after--p" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://d262ilb51hltx0.cloudfront.net/max/800/1*63Zta4mbC_3o44QdycrD7Q.png"></div><figcaption class="imageCaption">publicPath in Development vs Production</figcaption></figure><p name="69b0" id="69b0" class="graf--p graf-after--figure">For example, in your CSS, you may have a url to load â€˜./test.pngâ€™ on your localhost. But in production, the â€˜<em class="markup--em markup--p-em">test.pngâ€™</em> might actually be located at a CDN while your node.js server might be running on <a href="https://heroku.com" class="markup--anchor markup--p-anchor" rel="nofollow"><strong class="markup--strong markup--p-strong">Heroku</strong></a>. <strong class="markup--strong markup--p-strong">So that means, youâ€™ll have to manually update the URLs in all the files to point to the CDN when running in Production.</strong></p><p name="95ff" id="95ff" class="graf--p graf-after--p">Instead, you can use Webpackâ€™s <strong class="markup--strong markup--p-strong">publicPath</strong> and use bunch of plugins that are publicPath-aware to automatically update URLs when generating production builds.</p><blockquote name="020d" id="020d" class="graf--blockquote graf-after--p">Note: You can click on the pictures to zoom and read</blockquote><figure name="f6d2" id="f6d2" class="graf--figure graf-after--blockquote" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://d262ilb51hltx0.cloudfront.net/max/800/1*aOM5ZF8alWLr4BC0CfZe0w.png"></div><figcaption class="imageCaption">publicPath Production example</figcaption></figure><pre name="cf5c" id="cf5c" class="graf--pre graf-after--figure">// Development: Both Server and the image are on localhost<br>.image { <br> background-image: url(â€˜./test.pngâ€™);<br> }</pre><pre name="61cc" id="61cc" class="graf--pre graf-after--pre">// Production: Server is on Heroku but the image is on a CDN<br>.image { <br> background-image: url(â€˜https://someCDN/test.pngâ€™);<br> }</pre><p name="5fbf" id="5fbf" class="graf--p graf-after--h3">Loaders are additional node modules that help â€˜loadâ€™ or â€˜importâ€™ files of various types into browser acceptable formats like JS, Stylesheets and so on. Further loaders also allow importing such files into JS via â€œrequireâ€ or â€œimportâ€ in ES6.</p><p name="4949" id="4949" class="graf--p graf-after--p">For example: You can use <strong class="markup--strong markup--p-strong">babel-loader</strong> to convert JS written in ES6 to browser acceptable ES5 like so:</p><pre name="3a87" id="3a87" class="graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">module: {<br> loaders: [{<br> test: /\.js$/, </strong>â†Test for ".js" file, if it passes, use the loader<strong class="markup--strong markup--pre-strong"><br> exclude: /node_modules/, </strong>â†Exclude node_modules folder<strong class="markup--strong markup--pre-strong"><br> loader: â€˜babelâ€™</strong> â†use babel (short for â€˜babel-loaderâ€™)<strong class="markup--strong markup--pre-strong"><br> }]</strong></pre><p name="b3c7" id="b3c7" class="graf--p graf-after--h4">Multiple Loaders can be chained and made to work on the same file type. The chaining works from <strong class="markup--strong markup--p-strong">right-to-left and the loader are separated by â€œ!â€</strong>.</p><p name="79fe" id="79fe" class="graf--p graf-after--p">For example, Letâ€™s say we have a CSS file â€œmyCssFile.cssâ€ and we want to dump itâ€™s content into &lt;script&gt; tag inside our HTML. We can accomplish that using two loaders: css-loader and style-loader.</p><pre name="18b9" id="18b9" class="graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">module: {<br> loaders: [{</strong><br> test: /\.css$/,<br> loader: â€˜style!cssâ€™ <strong class="markup--strong markup--pre-strong">&lt;--(short for style-loader!css-loader)</strong><br> <strong class="markup--strong markup--pre-strong">}]</strong></pre><p name="04e4" id="04e4" class="graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Here is how it works:</strong></p><figure name="9a9e" id="9a9e" class="graf--figure graf-after--p" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://d262ilb51hltx0.cloudfront.net/max/800/1*nes9iLmskmsD8Fp4Ek3u-A.png"></div></figure><ol class="postList"><li name="bf2a" id="bf2a" class="graf--li graf-after--figure">Webpack searches for CSS files dependencies inside the modules. That is Webpack checks to see if a JS file has â€œ<strong class="markup--strong markup--li-strong">require(myCssFile.css)</strong>â€. If it finds the dependency, then the Webpack gives that file <strong class="markup--strong markup--li-strong">first to the</strong> â€œ<strong class="markup--strong markup--li-strong">css-loaderâ€</strong></li><li name="cb70" id="cb70" class="graf--li graf-after--li"><strong class="markup--strong markup--li-strong">css-loader </strong>loads all the CSS and CSSâ€™ own dependencies (i.e @import otherCSS) into JSON. Webpack then passes the result to â€œstyle-loaderâ€.</li><li name="6005" id="6005" class="graf--li graf-after--li"><strong class="markup--strong markup--li-strong">style-loader</strong> to take the JSON and add it to a script tagâ€Šâ€”â€Š<strong class="markup--strong markup--li-strong">&lt;script&gt;CSS contents&lt;/script&gt;</strong> and inserts the tag into the index.html file.</li></ol><p name="c8d5" id="c8d5" class="graf--p graf-after--h3">Loaders themselves can be configured to work differently by passing parameters.</p><p name="45de" id="45de" class="graf--p graf-after--p">In the example below, we are configuring <strong class="markup--strong markup--p-strong">url-loader</strong> to use URLs for images larger than 1024 bytes and embed images that are less than 1024 bytes. We can do this by passing â€œlimitâ€ parameter in the <strong class="markup--strong markup--p-strong">following two ways:</strong></p><figure name="7247" id="7247" class="graf--figure graf-after--p" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://d262ilb51hltx0.cloudfront.net/max/800/1*-qVdcA3E8JSdtszxHqfIdA.png"></div></figure><p name="3def" id="3def" class="graf--p graf-after--h3">babel-loader uses â€œpresetsâ€ configuration to know how to convert ES6 to ES5 and also how to parse Reactâ€™s JSX to JS. We can pass the configuration via â€œqueryâ€ parameter like below:</p><pre name="f15f" id="f15f" class="graf--pre graf-after--p">module: {<br> loaders: [<br> {<br> test: /<strong class="markup--strong markup--pre-strong">\.</strong>jsx?$/,<br> exclude: /(node_modules|bower_components)/,<br> loader: 'babel',<br> <strong class="markup--strong markup--pre-strong"> query: {<br> presets: ['react', 'es2015']<br> }</strong><br> }<br> ]<br>}</pre><p name="de95" id="de95" class="graf--p graf-after--pre">However in many projects babelâ€™s configuration can become very large. So Webpack letâ€™s us to keep babel-loaderâ€™s configuration in babelâ€™s own configuration file calledÂ <strong class="markup--strong markup--p-strong">.babelrc</strong> file.</p><p name="9f8f" id="9f8f" class="graf--p graf-after--p">So in many examples, youâ€™ll see:</p><pre name="b605" id="b605" class="graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">//webpack.config.js </strong><br>module: {<br> loaders: [<br> {<br> test: /<strong class="markup--strong markup--pre-strong">\.</strong>jsx?$/,<br> exclude: /(node_modules|bower_components)/,<br> loader: 'babel'<br> }<br> ]<br>}</pre><pre name="866c" id="866c" class="graf--pre graf-after--pre"><br><strong class="markup--strong markup--pre-strong">//.bablerc</strong><br>{<br> â€œpresetsâ€: [â€œreactâ€, â€œes2015â€]<br>}</pre><p name="60c8" id="60c8" class="graf--p graf-after--h3">Plugins are additional node modules that usually work on the resulting bundle.</p><p name="a27f" id="a27f" class="graf--p graf-after--p">For example, <a href="https://webpack.github.io/docs/list-of-plugins.html#uglifyjsplugin" class="markup--anchor markup--p-anchor" rel="nofollow"><strong class="markup--strong markup--p-strong">uglifyJSPlugin</strong></a> takes the bundle.js and minimizes and obfuscates the contents to decrease the file size.</p><p name="0a88" id="0a88" class="graf--p graf-after--p">Similarly <a href="https://github.com/webpack/extract-text-webpack-plugin" class="markup--anchor markup--p-anchor" rel="nofollow"><strong class="markup--strong markup--p-strong">extract-text-webpack-plugin</strong></a> internally uses <strong class="markup--strong markup--p-strong">css-loader</strong> and <strong class="markup--strong markup--p-strong">style-loader</strong> to gather all the CSS into one place and finally extracts the result into a separate external<strong class="markup--strong markup--p-strong"> styles.css</strong> file and includes the link to <strong class="markup--strong markup--p-strong">style.css</strong> into <strong class="markup--strong markup--p-strong">index.html</strong></p><pre name="b885" id="b885" class="graf--pre graf-after--p">//webpack.config.js<br>//Take all the .css files, combine their contents and it extract them to a single "styles.css"</pre><pre name="49be" id="49be" class="graf--pre graf-after--pre">var ETP = require("extract-text-webpack-plugin");<br><br>module: {<br> loaders: [<br> {test: /<strong class="markup--strong markup--pre-strong">\.</strong>css$/, loader:ETP.extract("style-loader","css-loader") }<br> ]<br>},</pre><pre name="0a6c" id="0a6c" class="graf--pre graf-after--pre">plugins: [<br> new ExtractTextPlugin("styles.css") //Extract to styles.css file<br> ]<br>}</pre><p name="185b" id="185b" class="graf--p graf-after--pre">Note: If you want to just inline CSS as a <strong class="markup--strong markup--p-strong">style</strong> element into HTML, you can do that without the <a href="https://github.com/webpack/extract-text-webpack-plugin" class="markup--anchor markup--p-anchor" rel="nofollow"><strong class="markup--strong markup--p-strong">extract-text-webpack-plugin</strong></a> and by just CSS and Style <strong class="markup--strong markup--p-strong">loaders</strong> like below:</p><pre name="4e02" id="4e02" class="graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">module: {<br> loaders: [{</strong><br> test: /\.css$/,<br> loader: â€˜style!cssâ€™ <strong class="markup--strong markup--pre-strong">&lt;--(short for style-loader!css-loader)</strong><br> <strong class="markup--strong markup--pre-strong">}]</strong></pre><p name="d1fe" id="d1fe" class="graf--p graf-after--h3">As you might have realized, <strong class="markup--strong markup--p-strong">Loaders</strong> <strong class="markup--strong markup--p-strong">work at the individual file level during or before </strong>the<strong class="markup--strong markup--p-strong"> </strong>bundle is generated.</p><p name="c99f" id="c99f" class="graf--p graf-after--p">Where as <strong class="markup--strong markup--p-strong">Plugins</strong> <strong class="markup--strong markup--p-strong">work at bundle or chunk level and usually work at the end of the bundle generation process</strong>. And some Plugins like <a href="https://webpack.github.io/docs/list-of-plugins.html#commonschunkplugin" class="markup--anchor markup--p-anchor" rel="nofollow">commonsChunksPlugins</a> go even further and modify how the bundles themselves are created.</p><p name="9d4a" id="9d4a" class="graf--p graf-after--h3">Many Webpack config files have a <strong class="markup--strong markup--p-strong">resolve extensions </strong>property that has an <strong class="markup--strong markup--p-strong">empty string </strong>like shown below. The empty string is there to help resolve imports without extensions like:<strong class="markup--strong markup--p-strong"> require(â€œ./myJSFileâ€) or import myJSFile from â€˜./myJSFileâ€™ </strong>without file extensions<strong class="markup--strong markup--p-strong">.</strong></p><pre name="fe00" id="fe00" class="graf--pre graf-after--p">{<br> resolve: {<br> extensions: [<strong class="markup--strong markup--pre-strong">â€˜â€™</strong>, â€˜.jsâ€™, â€˜.jsxâ€™]<br> }<br>}</pre><p name="8f62" id="8f62" class="graf--p graf-after--pre">Thatâ€™s it! ğŸ‘</p><p name="c838" id="c838" class="graf--p graf-after--li"><em class="markup--em markup--p-em">ğŸ‰ğŸ‰ğŸ‰ </em><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">If you like this post, please 1. </em></strong>â¤â¤â¤<em class="markup--em markup--p-em"> </em><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">it below on Medium and 2. please share it on Twitter. You may retweet the below card</em></strong><em class="markup--em markup--p-em">ğŸ‰ğŸ‰ğŸ‰</em></p><figure name="82c6" id="82c6" class="graf--figure graf--iframe graf-after--p" score="-13.75"></figure><p name="3192" id="3192" class="graf--p graf-after--figure graf--last">Thank you! ğŸ™</p></div></div></section>
</body></html>
