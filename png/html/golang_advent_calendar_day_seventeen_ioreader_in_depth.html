<!DOCTYPE html><html><head><title>Golang advent calendar: DAY SEVENTEEN — io.Reader in depth</title></head><body>
<h1>Golang advent calendar: DAY SEVENTEEN — io.Reader in depth</h1><p><a href="https://medium.com/@matryer/golang-advent-calendar-day-seventeen-io-reader-in-depth-6f744bb4320b" target="_new">Original URL</a></p>
<p><blockquote>Single method interfaces end up being extremely powerful — more so than even the language creators thought.This article aims to convince you to use io.Reader in your own code wherever you can.Let’s&hellip;</blockquote></p>
<section name="b5ca" class=" section--body section--first section--last" score="41.25"><div class="section-content" score="31.25"><div class="section-inner layoutSingleColumn"><p name="ca02" id="ca02" class="graf--p graf-after--h3">Single method interfaces end up being extremely powerful — more so than even the language creators thought.</p><blockquote name="0139" id="0139" class="graf--pullquote pullquote graf-after--p">This article aims to convince you to use io.Reader in your own code wherever you can.</blockquote><p name="70b0" id="70b0" class="graf--p graf-after--pullquote">Let’s have a look at io.Reader:</p><pre name="813d" id="813d" class="graf--pre graf-after--p">type Reader interface {<br> Read(p []<a href="https://golang.org/pkg/builtin/#byte" class="markup--anchor markup--pre-anchor" rel="nofollow">byte</a>) (n <a href="https://golang.org/pkg/builtin/#int" class="markup--anchor markup--pre-anchor" rel="nofollow">int</a>, err <a href="https://golang.org/pkg/builtin/#error" class="markup--anchor markup--pre-anchor" rel="nofollow">error</a>)<br>}</pre><p name="06db" id="06db" class="graf--p graf-after--pre">Pretty simple; a Reader is any type that implements the `Read` method.</p><blockquote name="c926" id="c926" class="graf--blockquote graf-after--p">Check out the comments from the standard library documentation for a little more context for <a href="https://golang.org/pkg/io/#Reader" class="markup--anchor markup--blockquote-anchor" rel="nofollow">Reader</a>.</blockquote><p name="1c90" id="1c90" class="graf--p graf-after--blockquote">For those unfamiliar with these interfaces; you pass in a slice of bytes, and Read is asked to fill it with its data — which is does until it runs out of data. It returns the number of bytes read (in `n`) or an error if something goes wrong. Additionally, if it has finished reading, it will return a special marker error called `io.EOF` (end of file).</p><p name="ae52" id="ae52" class="graf--p graf-after--h4">There are many kinds of Reader types available in the standard library, and you’ve almost certainly used at least one of them.</p><p name="2153" id="2153" class="graf--p graf-after--p">If you open a file for reading, the object returned is an `os.File`, which is a Reader (it implements the Read method):</p><pre name="df70" id="df70" class="graf--pre graf-after--p">var r io.Reader<br>var err error<br>r, err = os.Open("file.txt")</pre><p name="48e4" id="48e4" class="graf--p graf-after--pre">You can also make a Reader from a normal string using `strings.NewReader`:</p><pre name="b615" id="b615" class="graf--pre graf-after--p">var r io.Reader<br>r = strings.NewReader("Read will return these bytes")</pre><p name="0556" id="0556" class="graf--p graf-after--pre">The body data from an `http.Request` is a Reader:</p><pre name="e967" id="e967" class="graf--pre graf-after--p">var r io.Reader<br>r = request.Body</pre><p name="d7b9" id="d7b9" class="graf--p graf-after--pre">A bytes.Buffer is a Reader:</p><pre name="2d6a" id="2d6a" class="graf--pre graf-after--p">var r io.Reader<br>var buf bytes.Buffer<br>r = &amp;buf</pre><p name="3f31" id="3f31" class="graf--p graf-after--pre">There are many more throughout the standard library — and in most third-party packages too, since it’s good practice to use them wherever you can.</p><p name="d009" id="d009" class="graf--p graf-after--h4">Now we have a few Reader types — let’s explore ways in which they can be used.</p><p name="6db2" id="6db2" class="graf--p graf-after--p">You can read from them directly (this turns out to be the least useful use case):</p><pre name="57e0" id="57e0" class="graf--pre graf-after--p">p := make([]byte, 256)<br>n, err := r.Read(p)</pre><p name="ba01" id="ba01" class="graf--p graf-after--pre">`<a href="https://golang.org/pkg/io/ioutil/#ReadAll" class="markup--anchor markup--p-anchor" rel="nofollow">ioutil.ReadAll</a>` lets you read everything from a Reader, and get the raw []byte data:</p><pre name="c906" id="c906" class="graf--pre graf-after--p">b, err := ioutil.ReadAll(r)</pre><p name="2de9" id="2de9" class="graf--p graf-after--pre">`<a href="https://golang.org/pkg/io/#Copy" class="markup--anchor markup--p-anchor" rel="nofollow">io.Copy</a>` lets you read ALL bytes from an io.Reader, and write it to an io.Writer:</p><pre name="2897" id="2897" class="graf--pre graf-after--p">n, err := io.Copy(w, r)</pre><p name="3afb" id="3afb" class="graf--p graf-after--pre">The JSON decoder lets you decode directly from a Reader:</p><pre name="b027" id="b027" class="graf--pre graf-after--p">err := json.NewDecoder(r).Decode(v)</pre><p name="dda4" id="dda4" class="graf--p graf-after--pre">If you’re reading bytes that have been gzipped, you can wrap the io.Reader in a gzip.Reader:</p><pre name="a8fb" id="a8fb" class="graf--pre graf-after--p">r = gzip.NewReader(r)</pre><p name="0ac6" id="0ac6" class="graf--p graf-after--pre">Now reading from the new reader will decompress as you read.</p><p name="55f2" id="55f2" class="graf--p graf-after--h4">If you’re designing a package or utility (even if it’s an internal thing that nobody will ever see) rather than taking in strings or []byte slices, consider taking in an io.Reader if you can for data sources. Because suddenly, your code will work with every type that implements io.Reader.</p><p name="d83b" id="d83b" class="graf--p graf-after--p">So this:</p><pre name="26e4" id="26e4" class="graf--pre graf-after--p">func Reverse(s string) (string, error)</pre><p name="8101" id="8101" class="graf--p graf-after--pre">Could become:</p><pre name="d4a5" id="d4a5" class="graf--pre graf-after--p">func Reverse(r io.Reader) io.Reader</pre><p name="42b7" id="42b7" class="graf--p graf-after--pre">Then if someone wants to use it with a string, they can:</p><pre name="7ee5" id="7ee5" class="graf--pre graf-after--p">r = Reverse(strings.NewReader("Make me backwards"))</pre><p name="ed0d" id="ed0d" class="graf--p graf-after--pre">But they can also use it with a file:</p><pre name="8aea" id="8aea" class="graf--pre graf-after--p">f, err := os.Open("file.txt")<br>if err != nil {<br> log.Fatalln(err)<br>}<br>r = Reverse(f)</pre><p name="5b7c" id="5b7c" class="graf--p graf-after--pre">Or a web request:</p><pre name="9042" id="9042" class="graf--pre graf-after--p">func handle(w http.ResponseWriter, r *http.Request) {</pre><pre name="eb7b" id="eb7b" class="graf--pre graf-after--pre"> rev := Reverse(r.Body)</pre><pre name="67ae" id="67ae" class="graf--pre graf-after--pre"> // etc...<br>}</pre><p name="1a66" id="1a66" class="graf--p graf-after--pre graf--last">Use io.Reader (and io.Writer) whenever you’re dealing with streams of data. And this goes for all single method interfaces from the standard library.</p></div></div></section>
</body></html>
