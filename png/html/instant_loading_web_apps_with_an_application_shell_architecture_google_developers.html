<!DOCTYPE html><html><head><title>Instant Loading Web Apps With An Application Shell Architecture — Google Developers</title></head><body>
<h1>Instant Loading Web Apps With An Application Shell Architecture — Google Developers</h1><p><a href="https://medium.com/google-developers/instant-loading-web-apps-with-an-application-shell-architecture-7c0c2f10c73" target="_new">Original URL</a></p>
<p><blockquote>By Addy Osmani &amp; Matt GauntProgressive Web Apps (PWAs) describe how a web app can progressively change with use and user consent to give the user a more native-app-like experience with offline&hellip;</blockquote></p>
<section name="4825" class=" section--body section--first section--last" score="41.25"><div class="section-content" score="41.25"><div class="section-inner layoutSingleColumn"><p name="e795" id="e795" class="graf--p graf-after--h3"><em class="markup--em markup--p-em">By Addy Osmani &amp; Matt Gaunt</em></p><p name="34d2" id="34d2" class="graf--p graf-after--p"><a href="https://infrequently.org/2015/06/progressive-apps-escaping-tabs-without-losing-our-soul/" class="markup--anchor markup--p-anchor" rel="nofollow">Progressive Web Apps</a> (PWAs) describe how a web app can <em class="markup--em markup--p-em">progressively</em> change with use and user consent to give the user a more native-app-like experience with offline support, push notifications and being installable to the <a href="https://developers.google.com/web/updates/2015/03/increasing-engagement-with-app-install-banners-in-chrome-for-android" class="markup--anchor markup--p-anchor" rel="nofollow">home-screen</a>. They can also gain<strong class="markup--strong markup--p-strong"> substantial </strong>performance benefits thanks to intelligent <a href="http://www.html5rocks.com/en/tutorials/service-worker/introduction/" class="markup--anchor markup--p-anchor" rel="nofollow"><strong class="markup--strong markup--p-strong">service worker</strong></a><strong class="markup--strong markup--p-strong"> caching of your UI shell</strong> for repeat visits.</p><p name="1e41" id="1e41" class="graf--p graf-after--p">This allows you to focus on <strong class="markup--strong markup--p-strong">speed</strong>, giving your web apps the same <strong class="markup--strong markup--p-strong">instant loading</strong> and regular updates you’re used to seeing in <strong class="markup--strong markup--p-strong">native applications</strong>. It’s all possible using an <strong class="markup--strong markup--p-strong">Application Shell architecture</strong> — a companion to this new way of thinking. Any site can take advantage of <a href="http://www.html5rocks.com/en/tutorials/service-worker/introduction/" class="markup--anchor markup--p-anchor" rel="nofollow">service workers</a>, but PWAs must have them so it’s a natural fit.</p></div><div class="section-inner sectionLayout--outsetColumn" score="1.25"><figure name="677c" id="677c" class="graf--figure graf--layoutOutsetCenter graf-after--p" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://cdn-images-1.medium.com/max/1200/1*6BUS9ahijjPrr4BfV0Oq8g.jpeg"></div></figure></div><div class="section-inner layoutSingleColumn" score="-21.25"><p name="9597" id="9597" class="graf--p graf-after--figure">When we talk about an app’s shell, we mean the minimal HTML, CSS and JavaScript powering the user interface. <strong class="markup--strong markup--p-strong">This should load fast and be cached — and once loaded, dynamic content can populate your view</strong>. It’s the secret to reliably good performance.</p><p name="9bd2" id="9bd2" class="graf--p graf-after--p">Think of your app’s shell like the bundle of code you’d publish to an app store if building a native app — it’s the load needed to get off the ground, but might not be the whole story. Keep your UI local and pull in content dynamically through an API.</p><p name="91d3" id="91d3" class="graf--p graf-after--p">Let’s dive into how to structure your app using a<strong class="markup--strong markup--p-strong"> service worker augmented Application Shell architecture</strong>. We’ll look at both the client and server-side rendering involved and share an end-to-end sample you can try out today.</p><figure name="bdeb" id="bdeb" class="graf--figure graf-after--p" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://cdn-images-1.medium.com/max/800/1*5YMGg10WMLUbx1wav7aZYQ.png"></div></figure><p name="f1eb" id="f1eb" class="graf--p graf-after--figure">Our application has loaded for the first time and displays an ‘App is ready for offline use’ toast. If an update to the shell becomes available later, we can inform the user to refresh for the new version.</p><p name="a008" id="a008" class="graf--p graf-after--h3">A service worker is a script that<strong class="markup--strong markup--p-strong"> runs in the background,</strong> separate from your web page.. It responds to events, including network requests made from pages it serves. A service worker has an intentionally short lifetime. It wakes up when it gets an event and runs only as long as it needs to process it.</p><p name="1f5e" id="1f5e" class="graf--p graf-after--p">Service workers also have a limited set of APIs when compared to JavaScript run from the context of a normal page. This is standard for <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers" class="markup--anchor markup--p-anchor" rel="nofollow">workers</a> on the web. A Service worker can’t access the DOM but access things like the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache" class="markup--anchor markup--p-anchor" rel="nofollow">Cache Storage API</a>, and they can make network requests using the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" class="markup--anchor markup--p-anchor" rel="nofollow">Fetch API</a>. The <a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API" class="markup--anchor markup--p-anchor" rel="nofollow">IndexedDB API</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/Client/postMessage" class="markup--anchor markup--p-anchor" rel="nofollow">postMessage()</a> are also available to use for data persistence and messaging between the service worker and pages it controls.</p><p name="13fe" id="13fe" class="graf--p graf-after--p">A service worker can intercept network requests made from a page (which triggers a fetch event on the service worker) and return a response retrieved from the network, or retrieved from a local cache, or even constructed programmatically. Effectively, it’s an <strong class="markup--strong markup--p-strong">efficient background event handler </strong>in the browser. The neat part is that, regardless of where the response comes from, it looks to the web page as though there were no service worker involvement.</p><p name="cd57" id="cd57" class="graf--p graf-after--p">To learn more about service workers in depth, read an <a href="http://www.html5rocks.com/en/tutorials/service-worker/introduction/" class="markup--anchor markup--p-anchor" rel="nofollow">Introduction to Service Workers</a>.</p><p name="6b2c" id="6b2c" class="graf--p graf-after--h3">Service workers are powerful for offline caching but they also offer significant performance wins in the form of<strong class="markup--strong markup--p-strong"> instant loading</strong> for repeat visits to your site or web app. You can cache your application shell so it works offline and populate its content using JavaScript.</p><p name="17e6" id="17e6" class="graf--p graf-after--p">On repeat visits, this allows you to get <strong class="markup--strong markup--p-strong">meaningful pixels</strong> on the screen without the network, even if your content eventually comes from there. Think of it as displaying regions of the screen where toolbars and cards will eventually be populated very quickly and then loading in the rest of the content <strong class="markup--strong markup--p-strong">progressively</strong>.</p><p name="1cf3" id="1cf3" class="graf--p graf-after--h4">To test this architecture on real devices, we’ve run our <a href="https://github.com/GoogleChrome/application-shell/" class="markup--anchor markup--p-anchor" rel="nofollow">application shell sample</a> on <a href="http://www.webpagetest.org/" class="markup--anchor markup--p-anchor" rel="nofollow">WebPageTest.org</a> and shown the results below.</p><p name="f5c2" id="f5c2" class="graf--p graf-after--p"><a href="http://www.webpagetest.org/result/151113_8S_G68/" class="markup--anchor markup--p-anchor" rel="nofollow"><strong class="markup--strong markup--p-strong">Testing on Cable with a Nexus 5 using Chrome Dev</strong></a></p><p name="ad52" id="ad52" class="graf--p graf-after--p">The first view of the app has to fetch all the resources from the network and doesn’t achieve a meaningful paint until <strong class="markup--strong markup--p-strong">1.2 seconds </strong>in. Thanks to service worker caching, our repeat visit achieves meaningful paint and fully finishes loading in <strong class="markup--strong markup--p-strong">0.5 seconds.</strong></p><figure name="c5b1" id="c5b1" class="graf--figure graf-after--p" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://cdn-images-1.medium.com/max/800/1*V0e9LSWBPFJzDTb1XPDx1g.png"></div></figure><p name="cc7e" id="cc7e" class="graf--p graf-after--figure"><a href="https://youtu.be/bsAefxnSRZU" class="markup--anchor markup--p-anchor" rel="nofollow">Video</a></p><p name="a3ce" id="a3ce" class="graf--p graf-after--p"><a href="http://www.webpagetest.org/result/151112_8R_YQN/" class="markup--anchor markup--p-anchor" rel="nofollow"><strong class="markup--strong markup--p-strong">Testing on 3G with a Nexus 5 using Chrome Dev</strong></a></p><p name="eec6" id="eec6" class="graf--p graf-after--p">We can also test our sample with a slightly slower 3G connection. This time it takes <strong class="markup--strong markup--p-strong">2.5 seconds</strong> on first visit for our first meaningful paint. It takes<a href="http://www.webpagetest.org/video/view.php?id=151112_8R_YQN.3.0" class="markup--anchor markup--p-anchor" rel="nofollow"><strong class="markup--strong markup--p-strong"> 7.1 seconds</strong></a><strong class="markup--strong markup--p-strong"> to fully load the page. With service worker caching, our repeat visit achieves meaningful paint and fully finishes loading in </strong><a href="http://www.webpagetest.org/video/view.php?id=151112_8R_YQN.3.1" class="markup--anchor markup--p-anchor" rel="nofollow">0.8 seconds</a>.</p><figure name="7dc4" id="7dc4" class="graf--figure graf-after--p" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://cdn-images-1.medium.com/max/800/1*k_Ajk7e0ntOGdLpENgBrCQ.png"></div></figure><p name="b528" id="b528" class="graf--p graf-after--figure"><a href="https://youtu.be/488XbwCKf5g" class="markup--anchor markup--p-anchor" rel="nofollow">Video</a></p><p name="079b" id="079b" class="graf--p graf-after--p"><a href="http://www.webpagetest.org/result/151112_HH_11D0/" class="markup--anchor markup--p-anchor" rel="nofollow">Other views</a> tell a similar story.. Compare the <strong class="markup--strong markup--p-strong">3 seconds</strong> it takes to achieve first meaningful paint for our first view of another URL in the application-shell:</p><figure name="6299" id="6299" class="graf--figure graf-after--p" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://cdn-images-1.medium.com/max/800/1*fuXA7JGKlx3IKUrTQ_1ikw.png"></div></figure><p name="9161" id="9161" class="graf--p graf-after--figure">to the<strong class="markup--strong markup--p-strong"> 0.9 seconds </strong>it takes when loaded from our service worker cache. Over 2 seconds of time is saved for our end users.</p><figure name="c607" id="c607" class="graf--figure graf-after--p" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://cdn-images-1.medium.com/max/800/1*EaYEd9V2lbuSzEb9I6Z4LA.png"></div></figure><p name="c13d" id="c13d" class="graf--p graf-after--figure">Similar and reliable performance wins are possible for your own applications using the Application Shell architecture.</p><p name="737b" id="737b" class="graf--p graf-after--h4">Service workers imply some subtle changes in application architecture. Rather than squashing all of your application into an HTML string, it can be beneficial to do things <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" class="markup--anchor markup--p-anchor" rel="nofollow">XHR</a>-style. This is where you have a shell (always cached and can always boot up without the network) and content which is refreshed regularly and managed separately.</p><p name="75d8" id="75d8" class="graf--p graf-after--p">The implications of this split are large. On the first visit you can render content on the server and install the service worker on the client. On subsequent visits you need only request data.</p><p name="5a71" id="5a71" class="graf--p graf-after--h4">While service worker isn’t currently supported by all browsers, the application content shell architecture uses <a href="https://en.wikipedia.org/wiki/Progressive_enhancement" class="markup--anchor markup--p-anchor" rel="nofollow">progressive enhancement</a> to ensure everyone can access the content. For example, take our sample project.</p><p name="4387" id="4387" class="graf--p graf-after--p">Below you can see the full version rendered in Chrome, Firefox Nightly and Safari. On the very left you can see the Safari version where the content is rendered on the server <em class="markup--em markup--p-em">without</em> a service worker. On the right we see the Chrome and Firefox Nightly versions powered by service worker.</p><figure name="f6c5" id="f6c5" class="graf--figure graf-after--p" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://cdn-images-1.medium.com/max/800/1*_3CWMs-v8WpHnfN1t_-Q5A.jpeg"></div></figure><p name="dbe5" id="dbe5" class="graf--p graf-after--h4">The Application Shell architecture makes the most sense for apps and sites that are <strong class="markup--strong markup--p-strong">dynamic</strong>. A number of modern JavaScript frameworks and libraries (already encourage splitting your application logic from the content, making this pattern more straight-forward to apply.</p><p name="cc7d" id="cc7d" class="graf--p graf-after--p">If you’re a very small static site, you probably don’t need an application shell and can simply cache the whole site in a service worker `oninstall` step. Use the approach that makes the most sense for your project.</p><p name="4dd1" id="4dd1" class="graf--p graf-after--h4">The application shell architecture is possible with just a few changes to your overall application’s UI and has worked well for large-scale sites such as Google’s <a href="https://developers.google.com/web/showcase/case-study/service-workers-iowa" class="markup--anchor markup--p-anchor" rel="nofollow">I/O 2015 Progressive Web App</a> and Google’s <a href="http://inbox.google.com" class="markup--anchor markup--p-anchor" rel="nofollow">Inbox</a>.</p><figure name="9267" id="9267" class="graf--figure graf-after--p" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://cdn-images-1.medium.com/max/800/1*G_mS2lPczXcWCUjScXctVQ.png"></div></figure><p name="5d92" id="5d92" class="graf--p graf-after--figure">Offline application shells are a major performance win and are also demonstrated well in Jake Archibald’s <a href="https://wiki-offline.jakearchibald.com/wiki/Rick_and_Morty" class="markup--anchor markup--p-anchor" rel="nofollow">offline Wikipedia app</a>, <a href="http://tech-blog.flipkart.net/2015/11/progressive-web-app/" class="markup--anchor markup--p-anchor" rel="nofollow">Flipkart Lite</a>’s Progressive web app or <a href="https://github.com/googlechrome/voice-memos" class="markup--anchor markup--p-anchor" rel="nofollow">Voice Memos</a> by Paul Lewis.</p></div><div class="section-inner sectionLayout--outsetColumn" score="1.25"><figure name="b34a" id="b34a" class="graf--figure graf--layoutOutsetCenter graf-after--p" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://cdn-images-1.medium.com/max/1200/1*ggPaaogmGO_AavHDZPkGiw.jpeg"></div><figcaption class="imageCaption">For more details on how simple changes to Service Worker can improve startup and load performance, see Jake Archibald’s excellent <a href="https://www.youtube.com/watch?v=d5_6yHixpsQ" class="markup--anchor markup--figure-anchor" rel="nofollow">Supercharging page load</a> video.</figcaption></figure></div><div class="section-inner layoutSingleColumn" score="20.75"><p name="d198" id="d198" class="graf--p graf-after--h3">During the first load experience, your goal is to get meaningful content to the user’s screen as quickly as possible.</p><p name="c597" id="c597" class="graf--p graf-after--p"><strong class="markup--strong markup--p-strong">First Load and Loading Other Pages</strong></p><figure name="3ff0" id="3ff0" class="graf--figure graf-after--p" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://cdn-images-1.medium.com/max/800/1*lIOjh8H7wlsCwOJmUivBMA.png"></div></figure><p name="b0f9" id="b0f9" class="graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">In general the application shell architecture will:</strong></p><ul class="postList"><li name="575a" id="575a" class="graf--li graf-after--p">Prioritise the initial load, but let service worker cache the application shell so repeat visits do not require the shell to be re-fetched from the network.</li><li name="555c" id="555c" class="graf--li graf-after--li">Lazy-load or background load everything else. One good option is to use <a href="https://googlechrome.github.io/samples/service-worker/read-through-caching/" class="markup--anchor markup--li-anchor" rel="nofollow">read-through caching</a> for dynamic content.</li><li name="ed90" id="ed90" class="graf--li graf-after--li">Use service worker tools (sw-precache) for reliable caching and updating of service worker to automatically manage the caching of static content.</li></ul><p name="8b5b" id="8b5b" class="graf--p graf-after--li"><strong class="markup--strong markup--p-strong">To achieve this:</strong></p><ul class="postList"><li name="0475" id="0475" class="graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Server</strong> will send down HTML content the client can render and will use far-future HTTP cache expiration headers to account for browsers without service worker support. It will serve filenames using hashes to enable ‘versioning’ and easy updates for later in the application lifecycle.</li><li name="0e9d" id="0e9d" class="graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Page(s) </strong>will include inline CSS styles in a &lt;style&gt; tag within the document &lt;head&gt; to provide a fast first paint of the application shell. Each page will asynchronously load the JavaScript necessary for the current view. As we all know, CSS cannot yet be asynchronously loaded.. Instead, we can request styles using JavaScript as it IS asynchronous rather than parser-driven and synchronous. We can also take advantage of <a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" class="markup--anchor markup--li-anchor" rel="nofollow">requestAnimationFrame</a> to avoid cases where we might get a fast cache hit and end up with styles accidentally becoming part of the critical rendering path. requestAnimationFrame forces the first frame to be painted and then the styles to get loaded. Another option is to use projects such as Filament Group’s <a href="https://github.com/filamentgroup/loadCSS" class="markup--anchor markup--li-anchor" rel="nofollow">loadCSS</a> to request CSS async using JavaScript.</li><li name="36b0" id="36b0" class="graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Service worker </strong>will store a cached entry of the application shell so that on repeat visits, the shell can be loaded entirely from the service worker cache unless an update is available on the network.</li></ul><figure name="2f8c" id="2f8c" class="graf--figure graf-after--li" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://cdn-images-1.medium.com/max/800/1*f8je16MDSCGbzs4Ckb1qNQ.jpeg"></div></figure><p name="3093" id="3093" class="graf--p graf-after--h3">We’ve written a fully working <a href="https://github.com/GoogleChrome/application-shell" class="markup--anchor markup--p-anchor" rel="nofollow">sample</a> using the Application Shell architecture using vanilla ES2015 JavaScript for the client and <a href="http://expressjs.com/" class="markup--anchor markup--p-anchor" rel="nofollow">Express.js</a> for the server. There is course nothing stopping you from using your <strong class="markup--strong markup--p-strong">own stack </strong>for either the client or the server portions (e.g PHP, Ruby, Python). We found it relatively painless to use JS all the way through example.</p><p name="30bd" id="30bd" class="graf--p graf-after--h4">For our application-shell project, we use <a href="https://github.com/GoogleChrome/sw-precache/" class="markup--anchor markup--p-anchor" rel="nofollow">sw-precache</a> which generates our service worker script and <a href="https://github.com/GoogleChrome/sw-toolbox" class="markup--anchor markup--p-anchor" rel="nofollow">sw-toolbox</a> which handles runtime caching. Together they offer the following service worker lifecycle:</p><figure name="2beb" id="2beb" class="graf--figure graf-after--p" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://cdn-images-1.medium.com/max/800/1*mlR_s0HbEg7VZmJSf-rFhQ.png"></div></figure><p name="df99" id="df99" class="graf--p graf-after--h4">In the architecture, a server side component should be able to treat the content separate from how it’s presented. Content could be added to a HTML layout that results in a static render of the page, or it could be served up on it’s own to dynamically pulled in.</p><p name="f95a" id="f95a" class="graf--p graf-after--p">Understandably, your server-side setup may drastically differ from the one we use for our demo app, but this pattern of web apps is achievable by most server setups, it <strong class="markup--strong markup--p-strong">does</strong> require some re-architecting. We’ve found that the following model works quite well:</p><figure name="673b" id="673b" class="graf--figure graf-after--p" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://cdn-images-1.medium.com/max/800/1*xbR8pdsz-lHRiw4z5CDryQ.png"></div></figure><ul class="postList"><li name="56cb" id="56cb" class="graf--li graf-after--figure">Routes are defined for three parts of your application: the user facing URL’s (index/wildcard), your HTML partials of just content and the application shell itself.</li><li name="1329" id="1329" class="graf--li graf-after--li">Each route has a controller which pulls in a handlebars layout which in turn can pull in handlebar partials and views. Simply put, partials are views are chunks of HTML that are copied into the final page. Note: JavaScript frameworks that do more advanced data synchronisation are often way easier to port to an Application shell architecture. They tend to use data-binding and sync rather than partials.</li><li name="4311" id="4311" class="graf--li graf-after--li">The user is initially served a static page with content. This page registers a service worker if it’s supported which caches the application shell and everything it depends on (CSS, JS etc).</li><li name="7c93" id="7c93" class="graf--li graf-after--li">The app-shell will then act as a single page web app, using javascript to XHR in the content for a specific URL. The XHR calls are made to a /partials/ endpoint which returns the small chunk of HTML, CSS and JS needed to display that content. Note: there’s a many variants on how this can be approached and the above XHR one is just one of them. Some applications will inline their data (maybe using JSON) for initial render and therefore aren’t “static” in the flattened HTML sense.</li><li name="cb9d" id="cb9d" class="graf--li graf-after--li">Browsers <strong class="markup--strong markup--li-strong">without</strong> service worker support should always be served a fall-back experience. In our demo, we fall back to basic static server-side rendering, but this is only one of many options. The service worker aspect provides you with new opportunities for enhancing the performance of your Single-page Application style app using the cached application shell.</li></ul><p name="405f" id="405f" class="graf--p graf-after--h4">One question that arises is how exactly should file versioning/updates be handled. This is application specific and the options are:</p><ul class="postList"><li name="8362" id="8362" class="graf--li graf-after--p">Network first and use the cached version otherwise</li><li name="51d1" id="51d1" class="graf--li graf-after--li">Network only and fail if offline</li><li name="71f3" id="71f3" class="graf--li graf-after--li">Cache the old version and update later</li></ul><p name="7eec" id="7eec" class="graf--p graf-after--li"><strong class="markup--strong markup--p-strong">For the application shell itself, a cache-first approach should be taken for your service worker setup. If you aren’t caching the application shell, you haven’t properly adopted the architecture</strong>.</p><p name="30c1" id="30c1" class="graf--p graf-after--p"><em class="markup--em markup--p-em">Note: The application-shell sample does not (at the time of writing) use file versioning</em><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em"> for the assets referenced in the static render, often used for cache busting</em></strong><em class="markup--em markup--p-em">. We hope to add this in the near future. The service worker is otherwise versioned by sw-precache (covered in the ‘Tooling’ section).</em></p><p name="daa6" id="daa6" class="graf--p graf-after--h4">We maintain a number of different <a href="https://developers.google.com/web/tools/service-worker-libraries/?hl=en" class="markup--anchor markup--p-anchor" rel="nofollow">service worker helper libraries</a> that make the process of precaching your application’s shell or handling common caching patterns more straight-forward to setup.</p><figure name="e4cc" id="e4cc" class="graf--figure graf-after--p" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://cdn-images-1.medium.com/max/800/1*ACE3yLzbAze9M1qCAg81lg.png"></div></figure><p name="b05d" id="b05d" class="graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">Use sw-precache for your application shell</strong></p><p name="7200" id="7200" class="graf--p graf-after--p">Using <a href="https://github.com/GoogleChrome/sw-precache" class="markup--anchor markup--p-anchor" rel="nofollow">sw-precache</a> to cache the application shell should handle the concerns around file revisions, the install/activate questions, and the fetch scenario for the app shell. You can drop sw-precache into your application’s build process and can use configurable wildcards to pick up your static resources. Rather than manually hand-crafting your service worker script, it generates one for you to take care of cache management in a way that is safe and has an efficient, cache-first fetch handler.</p><p name="2c85" id="2c85" class="graf--p graf-after--p">Initial visits to your app trigger pre-caching of the complete set of needed resources. This is very similar to the experience of installing a native app from an app store. <strong class="markup--strong markup--p-strong">When users return to your app, only updated resources are downloaded.</strong> In our demo app, we display an “App updated. Refresh for the new version” message to inform users that a new version of the application shell is available.</p><figure name="dccd" id="dccd" class="graf--figure graf-after--p" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://cdn-images-1.medium.com/max/800/1*mWzNNP0ARzZKK-9jjP9O9Q.jpeg"></div></figure><p name="4d85" id="4d85" class="graf--p graf-after--figure">This pattern is a low-friction way of letting users know they can refresh for the latest version.</p><p name="9e83" id="9e83" class="graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Use sw-toolbox for runtime caching</strong></p><p name="fa89" id="fa89" class="graf--p graf-after--p">Use <a href="https://github.com/GoogleChrome/sw-toolbox" class="markup--anchor markup--p-anchor" rel="nofollow">sw-toolbox</a> for runtime caching with varying strategies depending on the resource:</p><ul class="postList"><li name="487a" id="487a" class="graf--li graf-after--p"><a href="https://github.com/GoogleChrome/sw-toolbox#toolboxcachefirst" class="markup--anchor markup--li-anchor" rel="nofollow">cacheFirst</a> for images, along with a dedicated named cache that has a custom expiration policy of N maxEntries.</li><li name="7eeb" id="7eeb" class="graf--li graf-after--li"><a href="https://github.com/GoogleChrome/sw-toolbox#toolboxnetworkfirst" class="markup--anchor markup--li-anchor" rel="nofollow">networkFirst</a> or fastest for API requests, depending on the desired content freshness. Fastest might be fine, but if there’s a specific API feed that’s updated frequently, use networkFirst.</li></ul><p name="e776" id="e776" class="graf--p graf-after--h3">Application shell architectures comes with several benefits but may only make sense for certain classes of application. The model is still young and it will be worth evaluating how much effort and overall performance benefits you might gain from using this architecture.</p><p name="f606" id="f606" class="graf--p graf-after--p">In our experiments, we took advantage of template sharing between the client and server to minimise the work of building two application layers. This ensures progressive enhancement is still a first-class citizen.</p><p name="e0ae" id="e0ae" class="graf--p graf-after--p"><strong class="markup--strong markup--p-strong">If you’re already considering using service workers in your app, take a look at the architecture and evaluate if it makes sense for your own projects. We welcome any and all feedback on the ideas outlined in this post. Thanks!</strong></p><p name="cfb4" id="cfb4" class="graf--p graf-after--p"><em class="markup--em markup--p-em">With thanks to our reviewers: Jeff Posnick, Alex Russell, Paul Lewis, Seth Thompson, Rob Dodson, Taylor Savage, Peter Beverloo and Joe Medley.</em></p><figure name="27ae" id="27ae" class="graf--figure graf--iframe graf-after--h3" score="-13.75"><figcaption class="imageCaption">Instant Loading with Service Workers (Chrome DevSummit talk)</figcaption></figure><p name="4f08" id="4f08" class="graf--p graf-after--li graf--last"><em class="markup--em markup--p-em">Cross-posted from </em><a href="https://developers.google.com/web/updates/2015/11/app-shell?hl=en" class="markup--anchor markup--p-anchor" rel="nofollow"><em class="markup--em markup--p-em">Web Fundamentals</em></a></p></div></div></section>
</body></html>
