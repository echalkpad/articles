<!DOCTYPE html><html><head><title>Interface Pollution in Go</title></head><body>
<h1>Interface Pollution in Go</h1><p><a href="https://medium.com/@rakyll/interface-pollution-in-go-7d58bccec275" target="_new">Original URL</a></p>
<p><blockquote>If there was a single powerful language feature in Go, it&#x2019;d be the interfaces. The internals of Go contain strong combinations of useful ideas from various type systems and inevitably they&hellip;</blockquote></p>
<div><div class="section-inner layoutSingleColumn"><p name="77a4" class="graf--p"><a id="77a4"></a>If there was a single powerful language feature in Go, it&#x2019;d be the interfaces. The internals of Go contain strong combinations of useful ideas from various type systems and inevitably they ring the curiosity bells. I recently surveyed Github for Go interface declarations, and the results indicated that Go users pollute the environment with interfaces no one needs or will use.</p><p name="05ee" class="graf--p"><a id="05ee"></a>Don&#x2019;t export any interfaces until you have to.</p><p name="bbc7" class="graf--p"><a id="bbc7"></a>Interfaces are great, but interface pollution is not so. You&#x2019;re likely to come to Go from a language (if not from a dynamic language) that generates a static dispatch table during compilation, the compiler require you to explicitly tell the interfaces a type wants to implement. That&#x2019;s how the complier can generate a vtable with pointers to all available virtual functions. If your background is in C++ or Java, you&#x2019;re likely to have some baggage around initiating your codebase with abstract types and work on the concrete implementation as a follow-up exercise. This is not how you do it in Go. Introduce concrete types and don&#x2019;t export any interfaces unless you have to <em class="markup--em markup--p-em">encourage</em> external packages to implement one. <a target="_blank" href="http://golang.org/pkg/io" class="markup--anchor markup--p-anchor" rel="nofollow">io</a> package is a good starting point to study some of the the best practices. It exports interfaces because it also needs to export generic-use functions like Copy.</p><pre name="9d35" class="graf--pre"><a id="9d35"></a>func Copy(dst Writer, src Reader) (written int64, err error)</pre><p name="22b7" class="graf--p"><a id="22b7"></a>Should your package export generic functionality? If the answer is a &#x201C;maybe&#x201D;, you&#x2019;re likely to be polluting your package with an interface declaration. Justify the need of multiple implementations, likeliness of them to interact back with your package and act accordingly.</p><p name="20a4" class="graf--p"><a id="20a4"></a>Go doesn&#x2019;t have a traditional dispatch table, and can rely on the interface values during a method dispatch. It&#x2019;s literally more of a freestyle dispatcher mechanism that requires some work during interface value assignment&#x200A;&#x2014;&#x200A;it generates a tiny lookup hash-table for the concrete type it&#x2019;s pointing to. The assignment is not insanely expensive, so it&#x2019;s a fair exchange for a more pleasant type system. Ian Lance Taylor has <a target="_blank" href="http://www.airs.com/blog/archives/277" class="markup--anchor markup--p-anchor" rel="nofollow">a great blog post about the internals</a> if you&#x2019;re looking for further reading.</p><p name="7622" class="graf--p"><a id="7622"></a>If a user requires some level of &#x201C;inversion of control&#x201D;, an on-the-fly interface definition in their own scope would just work. This possibility minimizes the presumptions you have to make about the way your package is being consumed and the initial abstractions you have to work on.</p><p name="0af0" class="graf--p"><a id="0af0"></a>It also applies to the testability concerns, you don&#x2019;t have to provide interfaces to help the user to write their own stubs. Earlier today, I got a request to export an interface from the <a target="_blank" href="http://godoc.org/google.golang.org/cloud/pubsub" class="markup--anchor markup--p-anchor" rel="nofollow">pubsub</a> package to make it more mockable. Rather than doing so, the preferable way is to tell your user to introduce an interface that focuses on the calls they want to write a stub for. Point to the actual implementation via an interface value.</p><pre name="78cc" class="graf--pre"><a id="78cc"></a>type acknowledger interface {<br> Ack(sub string, id ...string) error<br>}</pre><pre name="2b11" class="graf--pre"><a id="2b11"></a>type mockClient struct{}<br>func (c *mockClient) Ack(sub string, id ...string) error {<br> return nil<br>}</pre><pre name="1722" class="graf--pre"><a id="1722"></a>var acker acknowledger = pubsub.New(...)<br>acker = &amp;mockClient{} // in the test package</pre><p name="6320" class="graf--p"><a id="6320"></a>Noteworthy that, in Go, the standard library defines tiny interfaces you happen to implement without effort and is doing a good job at encouraging the developers to write compatible code with the rest of the standard library&#x200A;&#x2014;&#x200A;and the other third party packages. Adopt what&#x2019;s available in the standard library where possible and document accordingly.</p><p name="0192" class="graf--p graf--last"><a id="0192"></a>Go fascinates me each time I deeply reevaluate my experience with the interfaces. Given the chance of minimal fragmentation in interfaces, this is how a programming language make software, that isn&#x2019;t designed to work together, work well together.</p></div></div>
</body></html>
