<!DOCTYPE html><html><head><title>Tiny abstractions using functions in Go</title></head><body>
<h1>Tiny abstractions using functions in Go</h1><p><a href="https://medium.com/@matryer/tiny-abstractions-using-functions-in-go-39cd7b9a1db2" target="_new">Original URL</a></p>
<p><blockquote>Sometimes you want to abstract a piece of functionality in your code so that you can swap out implementations, like for test code, or based on some configuration.The traditional way to do this is to&hellip;</blockquote></p>
<section name="c13d" class=" section--body section--first section--last" score="41.25"><div class="section-content" score="31.25"><div class="section-inner layoutSingleColumn"><p name="5f03" id="5f03" class="graf--p graf-after--h3">Sometimes you want to abstract a piece of functionality in your code so that you can swap out implementations, like for test code, or based on some configuration.</p><p name="7f70" id="7f70" class="graf--p graf-after--p">The traditional way to do this is to make an interface:</p><pre name="dfd3" id="dfd3" class="graf--pre graf-after--p">type EmailSender interface {<br> Send(*mail.Message) error<br>}</pre><p name="e3fe" id="e3fe" class="graf--p graf-after--pre">Then we could have a SendGrid implementation, an App Engine one, one for test (that just records the activity so we can make assertions against it) and maybe a no-op alternative for when email is disabled via configuration.</p><p name="d830" id="d830" class="graf--p graf-after--p">That is a lot of new types.</p><p name="e9f8" id="e9f8" class="graf--p graf-after--p">While things remain simple (i.e. one method), we can consider just using a function value instead:</p><pre name="3a3b" id="3a3b" class="graf--pre graf-after--p">sendEmailFunc func(*mail.Message) error</pre><p name="2672" id="2672" class="graf--p graf-after--pre">Like this:</p><pre name="6c2d" id="6c2d" class="graf--pre graf-after--p">type Server struct {<br> // SendEmail is a function that sends an email.<br> SendEmail func(*mail.Message) error<br>}</pre><pre name="4eb3" id="4eb3" class="graf--pre graf-after--pre">func NewServer() *Server {<br> return &amp;Server{<br> SendEmail: func(m *mail.Message) error {<br> // default implementation<br> },<br> }<br>}</pre><pre name="622d" id="622d" class="graf--pre graf-after--pre">// or even pass functions into other functions:</pre><pre name="a4a1" id="a4a1" class="graf--pre graf-after--pre">func CreateNewUser(<br> email, password string,<br> sendMailFunc func(*mail.Message) error,<br>) { ... }</pre><p name="1da3" id="1da3" class="graf--p graf-after--pre">Now, we havenâ€™t added lots of types, but we can change our implementation very easily and even make use of closures when doing so for when we need a little state:</p><pre name="3324" id="3324" class="graf--pre graf-after--p">func TestSignup(t *testing.T) {<br> <br> s := NewServer()</pre><pre name="3533" id="3533" class="graf--pre graf-after--pre"> var emails []*mail.Message<br> var emailErr error<br> s.SendEmail = func(m *mail.Message) error {<br> emails = append(emails, m)<br> return emailErr<br> }</pre><pre name="c270" id="c270" class="graf--pre graf-after--pre"> // run sign-up code</pre><pre name="688e" id="688e" class="graf--pre graf-after--pre"> if len(emails) != 1 {<br> t.Errorf("One email expected to be sent")<br> }</pre><pre name="be50" id="be50" class="graf--pre graf-after--pre"> // simulate email error (which will get returned<br> // by SendEmail function above)<br> emailErr = errors.New("nope")</pre><pre name="15b1" id="15b1" class="graf--pre graf-after--pre"> // run sign-up code again and test<br> // error case</pre><pre name="fac8" id="fac8" class="graf--pre graf-after--pre">}</pre><p name="95aa" id="95aa" class="graf--p graf-after--pre graf--last">This pattern is used by the <a href="https://golang.org/pkg/net/http/#Transport" class="markup--anchor markup--p-anchor" rel="nofollow">Dial method of http.Transport</a> in the standard library.</p></div></div></section>
</body></html>
