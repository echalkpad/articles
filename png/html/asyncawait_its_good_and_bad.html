<!DOCTYPE html><html><head><title>async/await: It’s Good and Bad</title></head><body>
<h1>async/await: It’s Good and Bad</h1><p><a href="https://medium.com/@benlesh/async-await-it-s-good-and-bad-15cf121ade40#.qmrf59w0c" target="_new">Original URL</a></p>
<p><blockquote>This might be controversial, as most people I know are huge fans of async/await. If you’re not familiar, it’s this nifty little syntax addition that allows developers to deal with APIs that return&hellip;</blockquote></p>
<section name="f57b" class=" section--body section--first section--last" score="41.25"><div class="section-content" score="36.25"><div class="section-inner layoutSingleColumn" score="19.0"><p name="7fab" id="7fab" class="graf--p graf-after--h3">This might be controversial, as most people I know are <em class="markup--em markup--p-em">huge </em>fans of async/await. If you’re not familiar, it’s this nifty little syntax addition that allows developers to deal with APIs that return Promises in a more “native” way:</p><pre name="9b39" id="9b39" class="graf--pre graf-after--p">async function doSomethingCool() {<br> let someValue = await getSomePromise();<br> console.log(someValue + '!!!');<br>}</pre><p name="d1ad" id="d1ad" class="graf--p graf-after--pre">As opposed to:</p><pre name="84bf" id="84bf" class="graf--pre graf-after--p">function doSomethingCool() {<br> getSomePromise.then(someValue =&gt; someValue + '!!!');<br>}</pre><p name="59c4" id="59c4" class="graf--p graf-after--pre">In the examples above, assume `getSomePromise` is a function that returns a Promise (It’s a huge leap I know).</p><p name="19ac" id="19ac" class="graf--p graf-after--h4">I remember several years ago when async await hit C# and people were very excited about it. It promised to make asynchrony “easier to understand” (at least by some of my coworkers’ estimations). And people liked it because it was “cleaner”. Now we have async await landing in JavaScript and I hear the same sort of chants, but I find its usefulness in making things “easier to understand” dubious.</p><ol class="postList"><li name="8c73" id="8c73" class="graf--li graf-after--h4"><strong class="markup--strong markup--li-strong">Things that would normally take many functions to compose can now be composed in one function! </strong>There isn’t a lot more to say here. Visual complexity is reduced. Instead of 2N curly brackets, there are just 2 curly brackets around one glorious function. It looks and feels <em class="markup--em markup--li-em">simpler</em> somehow.</li><li name="efde" id="efde" class="graf--li graf-after--li"><strong class="markup--strong markup--li-strong">No longer getting stuck with endless `then` chains. </strong>For some people this is a huge turn-off about promises and in some cases functional programming in general: Chains of methods accepting functions. It can honestly be hard for some to wrap their heads around. I don’t mind it at all, I work on a whole library built around that concept, but I get it.</li><li name="3bd2" id="3bd2" class="graf--li graf-after--li"><strong class="markup--strong markup--li-strong">try/catch blocks work smoothly over async code. </strong>This is probably my favorite feature of async await. A way to force Promise errors to act a little more like “regular JavaScript” errors. Consider the following:</li></ol><pre name="5e90" id="5e90" class="graf--pre graf-after--li">let bad = () =&gt; Promise.reject('bad');</pre><pre name="692d" id="692d" class="graf--pre graf-after--pre">async function coolWay() {<br> try {<br> let result = await bad();<br> doSomething(result);<br> } catch (err) {<br> console.error('An error!');<br> }<br>}</pre><pre name="a1c7" id="a1c7" class="graf--pre graf-after--p">let bad = () =&gt; Promise.reject('bad');</pre><pre name="b7b9" id="b7b9" class="graf--pre graf-after--pre">function lameOldWay() {<br> bad()<br> .then(doSomething)<br> .then(null, err =&gt; console.error('An error!'));<br>}</pre><p name="cc44" id="cc44" class="graf--p graf-after--pre">In my opinion, with the first example it’s much more obvious that the error handling in the catch block handles any error that occurs in either the call to `bad()` or `doSomething(result)`. Whereas with the second example, unless you’re really familiar with Promise chaining, it’s not readily, visually apparent where error handling is or what it’s covering. It’s not really a big deal, though, and it’s in the eye of the beholder.</p><ol class="postList"><li name="a0a0" id="a0a0" class="graf--li graf-after--h4"><strong class="markup--strong markup--li-strong">Things that would normally take many functions to compose can now be composed in one function! </strong>(You’ll notice this is the same as the “pro” above) One problem I have with this is when the code is all in one function, it’s easier to allow mutable state to bleed across what are really separate events. Another thing is that when it is broken up into many functions its a better visual queue that “Hey, each part of this is going to happen in it’s own event”. When they’re all munged together into a single function, then any number of individual events are actually handled within that one function. So it’s not really “one function” any more, it’s several functions joined together into one. Many pieces that run at different points in time are glued together without any easy to discern boundaries.</li><li name="e206" id="e206" class="graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Often the transpiled version of the code is quite verbose and ugly. </strong>At this particular point in time, if you really want to use async/await, you need to transpile it with something like <a href="http://babeljs.io" class="markup--anchor markup--li-anchor" rel="nofollow">Babel</a> (which is awesome, BTW). The problem is that often something you could have written in 2–3 lines with the regular promise API can be dozens of lines once transpiled. Take a look at the screen capture below of roughly equivalent async/await and straight promise versions of some logic. Consider the following equivalent uses of async/await and Promise chaining:</li></ol></div><div class="section-inner sectionLayout--outsetColumn" score="-2.5"><figure name="a80a" id="a80a" class="graf--figure graf--layoutOutsetCenter graf-after--li" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://cdn-images-1.medium.com/max/1200/1*9BHTR96pWXQUnwwCRJZGcw.png"></div><figcaption class="imageCaption">Transpiled output of async await in BabelJS</figcaption></figure><figure name="6129" id="6129" class="graf--figure graf--layoutOutsetCenter graf-after--figure" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://cdn-images-1.medium.com/max/1200/1*zcMq_wFztO99Vo9sk_1pFg.png"></div><figcaption class="imageCaption">Transpiled output of comparable promise chain in async await in BabelJS</figcaption></figure></div><div class="section-inner layoutSingleColumn"><p name="7223" id="7223" class="graf--p graf-after--figure">And the generated code isn’t even all of it: You’ll notice a reference to a `regeneratorRuntime` in there. This may change in newer versions of Babel, of course, but that’s not going to change the fact that there is a lot more code to execute to get this abstraction. All abstraction comes at a cost. In this case, I’m not entirely convinced the cost is always worth it.</p><p name="5ddc" id="5ddc" class="graf--p graf-after--p"><strong class="markup--strong markup--p-strong">EDIT:</strong> <a href="https://medium.com/u/86e3df6a6b21" class="markup--user markup--p-user">Stefan Penner</a> <a href="https://twitter.com/stefanpenner/status/702654894126149632" class="markup--anchor markup--p-anchor" rel="nofollow">brought up another valid point</a>, which is that `this` will be carried throughout the life of your async function. I’d lump that in as a “con”, because it’s going to stay in memory and a long-lived await might just result in retaining or even leaking resources you didn’t want to keep around.</p><p name="bfe7" id="bfe7" class="graf--p graf-after--p"><strong class="markup--strong markup--p-strong">EDIT EDIT:</strong> Again, <a href="https://medium.com/u/86e3df6a6b21" class="markup--user markup--p-user">Stefan Penner</a>’s valid point: leaking `this` can happen in any async paradigm, including callbacks. It’s just that here it could end up much “broader”. Also carrying `this` through the function is sort of a “pro” as it’s a feature.</p><p name="2589" id="2589" class="graf--p graf-after--h4">You can use both promise chains and async await, and there’s nothing wrong with that. Since `then` returns a Promise, you can await the promise it returns. I’m not sure what this approach will buy you, but if it suits a particular use-case and makes the code more readable, go for it.</p><p name="44e4" id="44e4" class="graf--p graf-after--h4 graf--last">It’s best to know what’s going on with async/await. I’d wager that in most cases it probably doesn’t matter much whether or not you choose to use a promise chain or async/await. It’s really a matter of knowing the trade-offs and choosing whichever approach makes your code the most readable for your maintainers. If either approach is readable to maintainers, then I’d personally lean toward the promise chaining myself, as it’s more direct, probably more performant, and definitely outputs smaller code to push to the browser. The best feature of async await is making handling unhandled errors from promises much more natural to the language by enabling you to use a simple try/catch block.</p></div></div></section>
</body></html>
