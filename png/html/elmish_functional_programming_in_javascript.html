<!DOCTYPE html><html><head><title>Elmish: Functional Programming in Javascript</title></head><body>
<h1>Elmish: Functional Programming in Javascript</h1><p><a href="https://medium.com/@chetcorcos/elmish-functional-programming-in-javascript-50995f1d4b9e#.lgnk6tq4u" target="_new">Original URL</a></p>
<p><blockquote>For the past few months, I’ve been on adventure learning everything I could about functional programming. It seems like every week there’s a new frontend framework or library claiming some&hellip;</blockquote></p>
<section name="02ef" class=" section--body section--first section--last" score="41.25"><div class="section-content" score="32.5"><div class="section-inner layoutSingleColumn" score="-10.5"><p name="58b9" id="58b9" class="graf--p graf-after--h3">For the past few months, I’ve been on adventure learning everything I could about functional programming. It seems like every week there’s a new frontend framework or library claiming some inspiration from functional programming, so I decided to check it out. One of my explorations was into <a href="http://elm-lang.org" class="markup--anchor markup--p-anchor" rel="nofollow">Elm</a>: an amazing Haskell-inspired language for building web applications. It gave me a taste of what functional programming really means. What really drew me toward Elm was the <a href="http://debug.elm-lang.org" class="markup--anchor markup--p-anchor" rel="nofollow">time-travelling debugger</a> and the amazing abstraction power <a href="https://github.com/evancz/elm-architecture-tutorial" class="markup--anchor markup--p-anchor" rel="nofollow">Elm Architecture Tutorial</a>.</p><p name="c431" id="c431" class="graf--p graf-after--p">It took me a while to understand the Elm language (if you’re interested in learning more , I highly recommend<a href="https://www.edx.org/course/introduction-functional-programming-delftx-fp101x-0" class="markup--anchor markup--p-anchor" rel="nofollow"> this free online class</a> that teaches Haskell). But as I wasn’t entirely fluent in Elm, I found it hard to really get going with my ideas. So thought<strong class="markup--strong markup--p-strong"> I’d try to test my understanding of the Elm Architecture by implementing the same concepts in Javascript</strong>. If you’ve used <a href="https://facebook.github.io/react/" class="markup--anchor markup--p-anchor" rel="nofollow">React</a> before, you’re probably familiar with <a href="https://github.com/reactjs/react-redux" class="markup--anchor markup--p-anchor" rel="nofollow">Redux</a>, which is actually directly <a href="https://github.com/reactjs/redux#influences" class="markup--anchor markup--p-anchor" rel="nofollow">inspired by Elm</a>, so hopefully you’ll notice some similarities.</p><blockquote name="cbe3" id="cbe3" class="graf--blockquote graf-after--p">The following code is all available in my <a href="https://github.com/ccorcos/elmish/tree/master/tutorial" class="markup--anchor markup--blockquote-anchor" rel="nofollow">elmish github repo</a>.</blockquote><p name="4527" id="4527" class="graf--p graf-after--h4">In Elm, everything is a pure function. A component is modeled as a finite state machine using 3 functions:</p><pre name="7455" id="7455" class="graf--pre graf-after--p">init :: () =&gt; state<br>update :: (state, action) =&gt; state<br>view :: (dispatch, state) =&gt; html</pre><p name="4f4d" id="4f4d" class="graf--p graf-after--pre">The update function is a <em class="markup--em markup--p-em">reducer. </em>It gets the current state and an action, and produces the next state which gets rendered using a virtual DOM library such as React. To send actions to update the state, you simply have to call dispatch with the action. And thats basically it! Let me show you a simple counter example:</p><figure name="e8a1" id="e8a1" class="graf--figure graf-after--p" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://cdn-images-1.medium.com/max/800/1*WFb799uyNMvM0cR8OxQufQ.png"></div></figure><p name="aa20" id="aa20" class="graf--p graf-after--figure">Now all thats left to do is connect the pieces. We need to get the initial state of the component and render the component using the view function. Now the dispatch function is tricky. The dispatch function needs to update the state and then re-render. Its a nasty bit of code, but I think it worth looking at and understanding:</p><figure name="4945" id="4945" class="graf--figure graf-after--p" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://cdn-images-1.medium.com/max/800/1*jlKrsIGB1gfkWm6IhAqHUg.png"></div></figure><p name="91ab" id="91ab" class="graf--p graf-after--h4">This section is arguably more stylistic than anything, but it introduces some great functional programming concepts that make this code a lot more readable. However, may take some time to wrap your head around it if this is the first time you’ve heard of <a href="https://hughfdjackson.com/javascript/why-curry-helps/" class="markup--anchor markup--p-anchor" rel="nofollow">function currying</a> or<a href="https://www.youtube.com/watch?v=XE692Clb5LU" class="markup--anchor markup--p-anchor" rel="nofollow"> observable streams</a>.</p><p name="b41b" id="b41b" class="graf--p graf-after--p">To clean things up a little, we get to use my two absolute favorite Javascript libraries, <a href="http://ramdajs%20github" class="markup--anchor markup--p-anchor" rel="nofollow">Ramda</a> and <a href="https://github.com/paldepind/flyd" class="markup--anchor markup--p-anchor" rel="nofollow">Flyd</a>. Ramda is <a href="https://www.youtube.com/watch?v=m3svKOdZijA" class="markup--anchor markup--p-anchor" rel="nofollow">like underscore, but with an eye for function composition</a>, and Flyd is a simple and intuitive observable streams library. Lets see what these tools can do for us:</p><figure name="29da" id="29da" class="graf--figure graf-after--p" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://cdn-images-1.medium.com/max/800/1*fqmEZwjrRrVMXJIvi6e9mA.png"></div></figure><p name="0b97" id="0b97" class="graf--p graf-after--figure">Streams are like lazy arrays. You can map, filter, and reduce (called scan) over them, and you can emit values to them my simply calling them as functions. Its also a convention to keep track of which variables are streams by suffixing with a $.</p><p name="6427" id="6427" class="graf--p graf-after--p">In the code above, we’re creating an action stream, and scanning the action stream over the update function with an initial state. Perhaps the easiest way to understand what scan does is by looking at the <a href="http://reactivex.io/documentation/operators/scan.html" class="markup--anchor markup--p-anchor" rel="nofollow">ReactiveX graphics</a>:</p><figure name="b18a" id="b18a" class="graf--figure graf-after--p" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://cdn-images-1.medium.com/max/800/1*iSQBGG5Kipw57925DWFdLg.png"></div></figure><p name="a344" id="a344" class="graf--p graf-after--figure">Then with a stream of states, we map over the view function to get a stream of virtual DOM trees. But we did something nifty there. We’re partially applying the <em class="markup--em markup--p-em">view</em> function with the action stream. <a href="https://www.youtube.com/watch?v=m3svKOdZijA&amp;app=desktop" class="markup--anchor markup--p-anchor" rel="nofollow">This talk</a> will help you understand currying better, but the point is that when you curry a function and call it with arguments, it will keep returning a function until it has all the arguments the function needs. This is essentially a more generalized concept of partial application. The key thing to realize here is that the dispatch function is really just a way of inputing values back into the action stream.</p><p name="bb5f" id="bb5f" class="graf--p graf-after--p">Enough with this, lets get back to Elmish.</p><p name="d1c0" id="d1c0" class="graf--p graf-after--h4">One benefit of building components using the init-update-view pattern is composition. You may want to look up some of the Ramda functions if you’re unfamiliar with them, but the beauty of Ramda is that once you understand it, this code should read very declaratively:</p><figure name="affa" id="affa" class="graf--figure graf-after--p" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://cdn-images-1.medium.com/max/800/1*xknatibl_SUsJBrhX0dN5A.png"></div></figure><p name="3150" id="3150" class="graf--p graf-after--figure">The <em class="markup--em markup--p-em">listOf </em>component is a higher-order component that creates lists of other components. To insert an item, we simply assign an id to the item and init the state of the subcomponent. The other crucial thing is that we wrap the child actions in a special <em class="markup--em markup--p-em">type: “child”</em> by passing <em class="markup--em markup--p-em">childDispatch</em> function to the child <em class="markup--em markup--p-em">view</em> function that forwards the actions to <em class="markup--em markup--p-em">dispatch. </em>That way, in the update function, we can lookup which child the action belongs to by id, and update that child’s state using the child’s update function.</p><p name="850b" id="850b" class="graf--p graf-after--p">Now this may seem a little bit verbose and I agree that it is, but its the price we pay from amazing abstraction power. If we want a list of counters now, all we need to do is:</p><pre name="b1d8" id="b1d8" class="graf--pre graf-after--p">start(listOf(counter))</pre><p name="a75f" id="a75f" class="graf--p graf-after--pre">What really shows the abstraction capabilities is the fact that you can trivially create a list of a list of counters.</p><pre name="bb3f" id="bb3f" class="graf--pre graf-after--p">start(listOf(listOf(counter)))</pre><p name="e6cb" id="e6cb" class="graf--p graf-after--pre">Notice that this kind of abstraction is something you cannot currently do with Redux. That’s because we aren’t passing the dispatch function all the way down through the components so all actions are global. Anyways, lets check out another higher-order component.</p><p name="0d75" id="0d75" class="graf--p graf-after--h4">My favorite example that shows the abstraction power of the Elm Architecture is the undoable component. It wraps a component and keeps track of a history of states so you can undo and redo the entire history. And again, this code reads very much like a specification to me. Undo is just decrementing time. Redo is incrementing time. And a child action means taking the current state, updating it to get the next state, and concatenating it onto the past while incrementing the time:</p><figure name="0fbc" id="0fbc" class="graf--figure graf-after--p" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://cdn-images-1.medium.com/max/800/1*uyvxcgM7QkfLGGwWRUTf9A.png"></div></figure><p name="f8e8" id="f8e8" class="graf--p graf-after--figure">What really starts to amaze me is how we can start to mix and match these components:</p><pre name="01fc" id="01fc" class="graf--pre graf-after--p">start(undoable(listOf(counter)))</pre><p name="0f78" id="0f78" class="graf--p graf-after--pre">Voila! It just works, and flawlessly.</p><p name="3366" id="3366" class="graf--p graf-after--h4">So that’s it for now. The Elm Architecture is a really cool pattern and gives you magical abstraction power via functional composition. Its not very hard to imagine creating a time-travelling debugger by taking the undoable component and putting a slider at the bottom of the screen.</p><p name="dff9" id="dff9" class="graf--p graf-after--p">Two other features that really excite me are reproducable error reporting and automated testing. If you run into a runtime exception, why not send the initial state and all actions the user took to the server so you can exactly reproduce the exception? And since all these functions are pure, you can record all actions and states as you’re using the app to generate test cases just by clicking around and using the app!</p><p name="0808" id="0808" class="graf--p graf-after--p">There are sadly a couple drawbacks to this approach that I’ve noticed so far:</p><ul class="postList"><li name="0035" id="0035" class="graf--li graf-after--p">There’s an annoying amount of boilerplate needed to wrap child actions. I think <a href="https://github.com/clojure/clojurescript" class="markup--anchor markup--li-anchor" rel="nofollow">Clojurescript</a> is an interesting option to alleviate this pain because of its incredibly powerful macros, but I don’t anticipate doing that anytime soon. Perhaps there’s some Javascript abstraction I haven’t thought of yet.</li><li name="6ebc" id="6ebc" class="graf--li graf-after--li">The entire DOM tree is re-computed after every action. The Elm community would tell you “premature optimization is the root of all evil” and while I don’t disagree, I do think that this will eventually be a problem if you’re running lots of animations through the action-update cycle. It is possible to wrap these Elmish components in React components to introduce lazy evaluation. But in the <em class="markup--em markup--li-em">listOf</em> component, for example, you’ll still be passing a new bound function to the child component on every update, forcing a re-render of every item in the list. It would be <strong class="markup--strong markup--li-strong">amazing</strong> if there was some kind of standard for deducing equality of <em class="markup--em markup--li-em">bound pure functions</em>. That is:</li></ul><pre name="8d25" id="8d25" class="graf--pre graf-after--li">const add = (a,b) =&gt; a + b<br>const f1 = bind(add, 1)<br>const f2 = bind(add, 1)<br>// ideally<br>f1 === f2<br>// pragmatically<br>f1.eq(f2)</pre><p name="f72f" id="f72f" class="graf--p graf-after--pre">The last thing we didn’t talk about yet is <em class="markup--em markup--p-em">side-effects.</em> Side-effects are typically the culprit of making your entire app a mess. Maybe if I have some time next week and people are interested, I’ll write another article about that.</p><p name="c9d8" id="c9d8" class="graf--p graf-after--p graf--last">In the meantime, you can see all these examples, and more in my <a href="https://github.com/ccorcos/elmish/tree/master/tutorial" class="markup--anchor markup--p-anchor" rel="nofollow">Elmish repo</a>. Please let me now what you think! And don’t hesitate to create an issue ticket if you have any questions, ideas, or just want to discuss.</p></div></div></section>
</body></html>
