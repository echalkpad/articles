<!DOCTYPE html><html><head><title>Routing RESTful controllers</title></head><body>
<h1>Routing RESTful controllers</h1><p><a href="https://medium.com/@matryer/golang-advent-calendar-day-five-routing-restful-controllers-edb74e7d4101" target="_new">Original URL</a></p>
<p><blockquote>When building APIs in Go you usually have the same kinds of mappings for many types of data. In particular, if you’re writing RESTful web services, then you’ll probably want to map GET to read, POST&hellip;</blockquote></p>
<section name="266f" class=" section--body section--first section--last" score="41.25"><div class="section-content" score="32.5"><div class="section-inner layoutSingleColumn" score="12.0"><p name="3efd" id="3efd" class="graf--p graf-after--h3">When building APIs in Go you usually have the same kinds of mappings for many types of data. In particular, if you’re writing RESTful web services, then you’ll probably want to map GET to read, POST to create, PUT to update etc.</p><p name="a9eb" id="a9eb" class="graf--p graf-after--p">An interesting approach to this, is to introduce the idea of a controller into your project. A controller is just a collection of methods (on a struct) that do RESTful things for a particular type of data or resource.</p><p name="437c" id="437c" class="graf--p graf-after--p">A typical controller might look like this:</p><pre name="587a" id="587a" class="graf--pre graf-after--p">type PresentsController struct{}</pre><pre name="2022" id="2022" class="graf--pre graf-after--pre">func (p PresentsController) ReadMany(w http.ResponseWriter, r *http.Request) {<br> // TODO: handle read many request<br>}</pre><p name="578f" id="578f" class="graf--p graf-after--pre">The `ReadMany` method would be mapped to `GET /presents`.</p><p name="557c" id="557c" class="graf--p graf-after--p">We aren’t mapping the methods to a pointer of the controller, because we don’t need to share any state between our RESTful methods.</p><p name="bd00" id="bd00" class="graf--p graf-after--p">Once the number of controllers stacks up, our mapping code will quickly become a little ugly and unmanageable. We can instead, add some interfaces and a helper to do the mappings for us.</p><p name="c018" id="c018" class="graf--p graf-after--p">The interface for a `ReadMany` method could look like this:</p><pre name="f63f" id="f63f" class="graf--pre graf-after--p">type RestManyReader interface {<br> ReadMany(w http.ResponseWriter, r *http.Request)<br>}</pre><p name="ee11" id="ee11" class="graf--p graf-after--pre">Then, in a helper function, we can check to see if a controller implements that method and make the appropriate mapping:</p><pre name="7403" id="7403" class="graf--pre graf-after--p">func Route(path string, controller interface{}, router Router) {<br> if c, ok := controller.(RestManyReader); ok {<br> router.Route(path, “GET”, http.HandlerFunc(c.ReadMany))<br> }<br>}</pre><p name="06a0" id="06a0" class="graf--p graf-after--pre">For cases where an ID is required (such as reading an individual resource), we can standardise that too:</p><pre name="f763" id="f763" class="graf--pre graf-after--p">type RestReader interface {<br> Read(w http.ResponseWriter, r *http.Request)<br>}</pre><pre name="25ed" id="25ed" class="graf--pre graf-after--pre">func Route(path string, controller interface{}, router Router) {<br> if c, ok := controller.(RestReader); ok {<br> router.Route(path+”/{id}”, “GET”, http.HandlerFunc(c.Read))<br> }<br> if c, ok := controller.(RestManyReader); ok {<br> router.Route(path, “GET”, http.HandlerFunc(c.ReadMany))<br> }<br>}</pre><p name="0393" id="0393" class="graf--p graf-after--pre">It’s perfectly fine for controllers to only implement either Read or ReadMany depending on what makes sense.</p><p name="5d7d" id="5d7d" class="graf--p graf-after--p">The whole set of interfaces might look like this:</p><pre name="9715" id="9715" class="graf--pre graf-after--p">type RestReader interface {<br> Read(w http.ResponseWriter, r *http.Request)<br>}</pre><pre name="f7a6" id="f7a6" class="graf--pre graf-after--pre">type RestManyReader interface {<br> ReadMany(w http.ResponseWriter, r *http.Request)<br>}</pre><pre name="3465" id="3465" class="graf--pre graf-after--pre">type RestCreator interface {<br> Create(w http.ResponseWriter, r *http.Request)<br>}</pre><pre name="20b9" id="20b9" class="graf--pre graf-after--pre">type RestUpdater interface {<br> Update(w http.ResponseWriter, r *http.Request)<br>}</pre><pre name="a0e0" id="a0e0" class="graf--pre graf-after--pre">type RestReplacer interface {<br> Replace(w http.ResponseWriter, r *http.Request)<br>}</pre><pre name="b62a" id="b62a" class="graf--pre graf-after--pre">type RestDeleter interface {<br> Delete(w http.ResponseWriter, r *http.Request)<br>}</pre><p name="ee18" id="ee18" class="graf--p graf-after--pre">Having each method in its own interface is what allows controllers to only implement a subset.</p><p name="182a" id="182a" class="graf--p graf-after--p">And a more complete Route helper function might go something like this:</p><pre name="d32d" id="d32d" class="graf--pre graf-after--p">func Route(path string, controller interface{}, router Router) {</pre><pre name="837e" id="837e" class="graf--pre graf-after--pre"> if c, ok := controller.(RestReader); ok {<br> router.Route(path+”/{id}”, “GET”, http.HandlerFunc(c.Read))<br> }</pre><pre name="7887" id="7887" class="graf--pre graf-after--pre"> if c, ok := controller.(RestManyReader); ok {<br> router.Route(path, “GET”, http.HandlerFunc(c.ReadMany))<br> }</pre><pre name="f020" id="f020" class="graf--pre graf-after--pre"> if c, ok := controller.(RestCreator); ok {<br> router.Route(path, “POST”, http.HandlerFunc(c.Create))<br> }<br> <br> if c, ok := controller.(RestDeleter); ok {<br> router.Route(path+”/{id}”, “DELETE”, http.HandlerFunc(c.Delete))<br> }</pre><pre name="5bea" id="5bea" class="graf--pre graf-after--pre"> if c, ok := controller.(RestReplacer); ok {<br> router.Route(path+”/{id}”, “PUT”, http.HandlerFunc(c.Replace))<br> }</pre><pre name="d0d5" id="d0d5" class="graf--pre graf-after--pre"> if c, ok := controller.(RestUpdater); ok {<br> router.Route(path+”/{id}”, “PATH”, http.HandlerFunc(c.Update))<br> }</pre><pre name="8524" id="8524" class="graf--pre graf-after--pre"> router.Route(path, “*”, http.NotFoundHandler())</pre><pre name="a0cf" id="a0cf" class="graf--pre graf-after--pre">}</pre><p name="68a7" id="68a7" class="graf--p graf-after--pre">You can tell the router to map all the remaining HTTP methods at that path to a 404 handler, to indicate that it isn’t supported.</p><p name="2948" id="2948" class="graf--p graf-after--p">Other ideas include:</p><ul class="postList"><li name="4405" id="4405" class="graf--li graf-after--p">Extracting the ID path parameter and changing the methods to take it as a parsed argument: `Delete(w http.ResponseWriter, r *http.Request, id string)`</li><li name="4d53" id="4d53" class="graf--li graf-after--li">Count the number of mapping made, and at the end of Route make sure at least one was done. If not, panic — because the developer probably made a mistake.</li><li name="e4ad" id="e4ad" class="graf--li graf-after--li">If you’re looking for a router that supports path parameters (like `{id}`) then check out <a href="http://www.gorillatoolkit.org/pkg/mux" class="markup--anchor markup--li-anchor" rel="nofollow">Gorilla’s mux package</a>.</li><li name="9d28" id="9d28" class="graf--li graf-after--li">Add another method and interface pair that lets your controller map additional routes that go beyond a traditional RESTful design.</li></ul><p name="f93c" id="f93c" class="graf--p graf-after--li graf--last">Check back tomorrow for another festive nugget. :)</p></div></div></section>
</body></html>
