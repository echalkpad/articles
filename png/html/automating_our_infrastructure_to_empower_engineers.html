<!DOCTYPE html><html><head><title>Automating Our Infrastructure to Empower Engineers</title></head><body>
<h1>Automating Our Infrastructure to Empower Engineers</h1><p><a href="https://segment.com/blog/automating-our-infrastructure/" target="_new">Original URL</a></p>
<p><blockquote>Growing a business is hard and growing the engineering team to support that is arguably harder, but doing both of those without a stable infrastructure is basically impossible. Particularly for high&hellip;</blockquote></p>
<div><div class="Article-body">
 <p>Growing a business is hard and growing the engineering team to support that is arguably harder, but doing both of those without a stable infrastructure is basically impossible. Particularly for high growth businesses, where every engineer must be empowered to write, test, and ship code with a high degree of autonomy.</p>
<p>Over the past year, we&#x2019;ve added ~60 new <a href="https://segment.com/integrations">integrations</a> (to over 160), built a <a href="https://segment.com/partners">platform for partners</a> to write their own integrations, released a <a href="https://segment.com/redshift">Redshift integration</a>, and have a few big product announcements on the way. And in that time, we&#x2019;ve had many growing pains around managing multiple environments, deploying code, and general development workflows. Since our engineers are happiest and most productive when their time is spent shipping product, building tooling, and scaling services, it&#x2019;s paramount that the development workflow and its supporting infrastructure are simple to use and flexible.</p>
<p>And that&#x2019;s why we&#x2019;ve automated many facets of our infrastructure. We&#x2019;ll share our current setup in greater detail below, covering these main areas:</p>

<p>Let&#x2019;s dive in!</p>
<h2 id="syncing-dev-environments">Syncing Dev Environments</h2>
<p>As the code complexity and the engineering team grow, it can become harder to keep dev environments consistent across all engineers.</p>
<p>Before our current solution, one big problem our engineering team faced was keeping all dev environments in sync. We had a GitHub repo with a set of shell scripts that all new engineers executed to install the necessary tools and authentication tokens onto their local machines. These scripts would also setup Vagrant and a VM.</p>
<p>But this VM was built locally on each computer. If you modified the state of your VM, then in order to get it back to the same VM as the other engineers, you&#x2019;d have to build everything again from scratch. And when one engineer updates the VM, you have to tell everyone on Slack to pull changes from our GitHub VM repo and rebuild. An awfully painful process, since Vagrant can be slow.</p>
<p>Not a great solution for a growing team that is trying to move fast.</p>
<p>When we first played with <a href="https://www.docker.com">Docker</a>, we liked the ability to run code in a reproducible and isolated environment. We wanted to reuse these Docker principles and experience in maintaining consistent dev environments across a growing engineering team.</p>
<p>We wrote a bunch of tools to set up the VM for new engineers to upgrade or to reset from the basic image state. When our engineers set up the VM for the first time, it asks for their GitHub credentials and AWS tokens, then pulls and builds from the latest image in <a href="https://hub.docker.com/">Docker Hub</a>.</p>
<p><img src="https://segment.com/blog/automating-our-infrastructure/images/docker-vm.png" alt="Docker VM setup"></p>
<p>On each run, we make sure that the VM is up-to-date by querying the Docker Hub API. This process updates packages, tools, etc. that our engineers use everyday. It takes around 5 seconds and is needed in order to make sure that everything is running correctly for the user.</p>
<p>Additionally, since our engineers use Macs, we switched from <a href="https://github.com/boot2docker/boot2docker">boot2docker</a> virtualbox machine to a <a href="https://www.vagrantup.com/">Vagrant</a> hosted boot2docker instance so that we could take advantage of NFS to share the volumes between the host and guest. Using NFS provides <a href="http://mitchellh.com/comparing-filesystem-performance-in-virtual-machines">massive performance gains</a> during local development. Lastly, NFS allows any changes our engineers make outside of the VM to be instantaneously reflected within the VM.</p>
<p>With this solution we have vastly reduced the number of dependencies needed to be installed on the host machine. The only things needed now are Docker, <a href="https://docs.docker.com/compose/">Docker Compose</a>, Go, and a <code>GOPATH</code> set.</p>
<h2 id="mirroring-dev-and-prod-environments">Mirroring Dev and Prod Environments</h2>
<p>The ideal situation is dev and prod environments running the same code, yet separated so code running on dev may never affect code running production.</p>
<p>Before we had the AWS state (generated by <a href="https://terraform.io/">Terraform</a>) stored alongside the Terraform files, but this wasn&#x2019;t a perfect system. For example if two people asynchronously plan and apply different changes, the state will be modified and who pushes last is going to have hard times to figure out the merge collisions.</p>
<p>We achieved mirroring staging and production in the simplest way possible: copying files from one folder to another. Terraform enabled us to reduce the amount of hours taken to modify the infrastructure, deploy new services and making improvements.</p>
<p>We integrated Terraform with <a href="https://circleci.com/">CircleCI</a> writing a custom build process and ensuring that the right amount of security was taken in consideration before applying.</p>
<p><img src="https://segment.com/blog/automating-our-infrastructure/images/staging-and-prod.png" alt="Staging and prod environments"></p>
<p>At the moment, we have one single repository hosted on GitHub named <code>infrastructure</code>, which contains a collection of Terraform scripts that configure environmental variables and settings for each of our containers.</p>
<p>When we want to change something in our infrastructure, we make the necessary changes to the Terraform scripts and run them before opening a new pull request for someone else on the infra-team to review it. Once the pull request gets merged to master, CircleCI will start the deployment process: the state gets pulled, modified locally, and stored again on S3.</p>
<h2 id="developing-locally">Developing Locally</h2>
<h3 id="seeding-databases">Seeding Databases</h3>
<p>When developing locally, it&#x2019;s important to populate local data stores with dummy data, so our app looks more realistic. As such, seeding databases is a common part of setting up the dev environment.</p>
<p>We rely on CircleCI, Docker, and <a href="https://docs.docker.com/engine/userguide/dockervolumes/">volume containers</a> to provide easy access to dummy data. Volume containers are portable images of static data. We decided to use volume containers because the data model and logic becomes less coupled and easier to maintain. Also just in case this data is useful in other places in our infrastructure (testing, etc., who knows).</p>
<p>Loading seed data into our local dev environment occurs automatically when we start the app server in development. For example, when the <code>app</code> (our main application) container is started in a dev environment, <code>app</code>&#x2018;s docker-compose.yml script will pull the latest <code>seed</code> image from Docker Hub and mount the raw data in the VM.</p>
<p>The <code>seed</code> image from Docker Hub is created from a GitHub repo <code>seed</code>, that is just a collection of JSON files as the raw objects we import into our databases. To update the seed data, we have CircleCI setup on the repo so that any publishes to master will build (grabbing our mongodb and redis containers from Docker Hub) and publish a new <code>seed</code> image to Docker Hub, which we can use in the app.</p>
<h3 id="spinning-up-microservices">Spinning Up Microservices</h3>
<p>Due to the data-heavy nature of Segment, our app already relies on several microservices (db service, redis, nsq, etc). In order for our engineers to work on the app, we need to have an easy way to create these services locally.</p>
<p>Again, Docker makes this workflow extremely easy.</p>
<p>Similar to how we use <code>seed</code> volume containers to mount data into the VM locally, we do the same with microservices. We use the docker compose file to grab images from Docker Hub to create locally, set addresses and aliases, and ultimately reduce the complexity to a single terminal command to get everything up and running.</p>
<h2 id="deploying-to-production">Deploying to Production</h2>
<p>If you write code, but never ship it to production, did it ever really happen? &#x1F603;</p>
<p>Deploying code to production is an integral part of the development workflow. At Segment, we prioritize easiness and flexibility around shipping code to production, since that encourages our engineers to move quickly and be productive. We&#x2019;ve also created adequate tooling around safeguarding for errors, rolling back, and monitoring build statuses.</p>
<p>We use Docker, <a href="https://aws.amazon.com/ecs/">ECS</a>, CircleCI, and Terraform to automate as much of the continuous deployment process as possible.</p>
<p><img src="https://segment.com/blog/automating-our-infrastructure/images/deploys.png" alt="Deploying at Segment"></p>
<p>Whenever code is pushed or merged into its <code>master</code> branch, the CircleCI script build the container and push it to Docker Hub.</p>
<p>Then, we have a separate <code>build</code> service that updates the task definition in ECS that is preset for that service that is triggered by a POST request (which lets us deploy via a <a href="https://slack.com/">Slack</a> <a href="https://slack.zendesk.com/hc/en-us/articles/201259356-Using-slash-commands">slash command</a>).</p>
<p>With this setup, we can define the configuration once for any service, making it extremely easy for our engineers to create and deploy new microservices. As <a href="https://www.twitter.com/calvinfo">Calvin</a> mentioned in a previous post, <a href="https://segment.com/blog/rebuilding-our-infrastructure/">&#x201C;Rebuilding Our Infrastructure with Docker, ECS, and Terraform&#x201D;</a>:</p>
<blockquote>
<p>We no longer have a complex set of provisioning scripts or AMIs&#x2014;we just hand the production cluster an image, and it runs. There&#x2019;s no more stateful instances, and we&#x2019;re guaranteed to run the same exact code on both staging and prod.</p>
</blockquote>
<p>The automation and ease of use around deployment have positively impacted more than just our engineers. Our success and marketing teams can update markdown files in a handful of repos that, when merged to master, kick off an auto deploy process so that changes can be live in minutes.</p>
<h2 id="growing-and-moving-fast">Growing and Moving Fast</h2>
<p>Because we chose to invest effort into rethinking and automating our dev workflow and its supporting infrastructure, our engineering team move fasters and more confidently. We spend more time doing high leverage jobs that we love&#x2014;shipping product and building internal tools&#x2014;and less time <a href="http://www.hanselman.com/blog/YakShavingDefinedIllGetThatDoneAsSoonAsIShaveThisYak.aspx">yak shaving</a>.</p>
<p>That said, this is by no means the final iteration of our infrastructure automation. We are constantly playing with new tools and testing new ideas, seeing what further efficiencies we can eek out. </p>
<p>This has been a tremendous learning process for us and we&#x2019;d love to hear what others in the community have done with their dev workflows. If you end up implementing something like this (or have already), <a href="https://www.twitter.com/segment">let us know</a>! We&#x2019;d love to hear what you&#x2019;ve done, and what&#x2019;s worked or hasn&#x2019;t for others with similar problems.</p>

 </div>
 </div>
</body></html>
