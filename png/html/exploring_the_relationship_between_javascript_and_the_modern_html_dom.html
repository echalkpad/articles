<!DOCTYPE html><html><head><title>Exploring the relationship between JavaScript and the modern HTML DOM</title></head><body>
<h1>Exploring the relationship between JavaScript and the modern HTML DOM</h1><p><a href="http://domenlightenment.com/" target="_new">Original URL</a></p>
<p><blockquote>You might also like: JavaScript Enlightenment or jQuery Enlightenment An O'Reilly edited version (printed, epub, mobi, pdf) of this book is now avaliable from O'Reilly or Amazon Warning! This is the&hellip;</blockquote></p>
<div><body>

<div id="otherBooks">
<span>You might also like: <a href="http://www.javascriptenlightenment.com/">JavaScript Enlightenment</a> or <a href="http://jqueryenlightenment.com/">jQuery Enlightenment</a></span>
</div>

<div class="alert">An O'Reilly edited version (printed, epub, mobi, pdf) of this book is now avaliable from <a href="http://shop.oreilly.com/product/0636920027690.do" target="_blank">O'Reilly</a> or <a href="http://www.amazon.com/DOM-Enlightenment-Cody-Lindley/dp/1449342841/" target="_blank">Amazon</a></div>

<p class="warning"><strong>Warning!</strong> This is the free online version of the DOM Enlightenment book in its pre-edited/draft form.</p>


<p id="title">DOM Enlightenment</p>
<p id="subTitle">Exploring the relationship between JavaScript and the modern HTML DOM</p>
<p>By <a href="http://twitter.com/codylindley">Cody Lindley</a> Version: 0.6.0</p>



<h2>Foreword</h2>

<p>I make websites. Sometimes I make music. Over the years, I&#x2019;ve noticed an interesting
pattern of behavior from some musicians&#x2014;often self-taught&#x2014;who think of themselves
as creative types: they display an aversion to learning any music theory. The logic, they
say, is that knowing the theory behind music will somehow constrain their creative
abilities. I&#x2019;ve never understood that logic (and I secretly believe that it&#x2019;s a retroactive
excuse for a lack of discipline). To my mind, I just don&#x2019;t see how any kind of knowledge
or enlightenment could be a bad thing.</p>
<p>Alas, I have seen the same kind of logic at work in the world of web design. There are
designers who not only don&#x2019;t know how to write markup and CSS, they actively refuse
to learn. Again, they cite the fear of somehow being constrained by this knowledge (and
again, I believe that&#x2019;s a self-justifying excuse).</p>
<p>In the world of front-end development, that attitude is fortunately far less prevalent.
Most web devs understand that there&#x2019;s always more to learn. But even amongst developers
who have an encyclopediac knowledge of HTML and CSS, there is often a knowledge
gap when it comes to the Document Object Model. That&#x2019;s understandable. You
don&#x2019;t need to understand the inner workings of the DOM if you&#x2019;re using a library like
jQuery. The whole point of JavaScript libraries is to abstract away the browser&#x2019;s internal
API and provide a different, better API instead.</p>
<p>Nonetheless, I think that many front-end devs have a feeling that they should know
what&#x2019;s going on under the hood. That&#x2019;s the natural reaction of a good geek when presented
with a system they&#x2019;re expected to work with. Now, thanks to DOM Enlightenment,
they can scratch that natural itch.</p>
<p>Douglas Crockford gave us a map to understand the inner workings of the JavaScript
language in his book JavaScript: The Good Parts. Now Cody Lindley has given us the
corresponding map for the Document Object Model. Armed with this map, you&#x2019;ll gain
the knowledge required to navigate the passageways and tunnels of the DOM.
ix</p>
<p>You might not end up using this knowledge in every project. You might decide to use a
library like jQuery instead. But now it will be your decision. Instead of having to use a
library because that&#x2019;s all that you know, you can choose if and when to use a library.
That&#x2019;s a very empowering feeling. That&#x2019;s what knowledge provides. That is true enlightenment.</p>

<p><small>&#x2014;Jeremy Keith, founder and technical director of clearleft.com, and author of
DOM Scripting: Web Design with JavaScript and the Document Object Model</small></p>

<h2>Introduction</h2>
<p>This book is not an exhaustive reference on DOM scripting or <a href="http://javascriptenlightenment.com/">JavaScript</a>. It may, however, be the most exhaustive book written about DOM scripting without the use of a library/framework. The lack of authorship around this topic is not without good reason. Most technical authors are not willing to wrangle this topic because of the differences that exist among legacy browsers and their implementations of the DOM specifications (or lack thereof).</p>
<p>For the purpose of this book (i.e. grokking the concepts), I'm going to sidestep the browser API mess and dying browser discrepancies in an effort to expose the modern DOM. That's right, I'm going to sidestep the ugliness in an effort to focus on the here and now. After all, we have solutions like jQuery to deal with all that browser ugliness, and you should definitely be leveraging something like jQuery when dealing with deprecated browsers. </p>
<p> While I am not promoting the idea of only going native when it comes to DOM scripting, I did write this book in part so that developers may realize that DOM libraries are not always required when scripting the DOM. I also wrote for the lucky few who get to write JavaScript code for a single environment (i.e. one browser, mobile browsers, or HTML+CSS+JavaScript-to-native via something like PhoneGap). What you learn in this book may just make a DOM library unnecessary in ideal situations, say for example, some light DOM scripting for deployment on a Webkit mobile browser only.</p>

<h2>Who should read this book</h2>
<p> As I authored this book, I specifically had two types of developers in mind. I assume both types already have an intermediate to advanced knowledge of JavaScript, HTML, and CSS. The first developer is someone who has a good handle on JavaScript or jQuery, but has really never taken the time to understand the purpose and value of a library like jQuery (the reason for its rhyme, if you will). Equipped with the knowledge from this book, that developer should fully be able to understand the value provided by jQuery for scripting the DOM. And not just the value, but how jQuery abstracts the DOM and where and why jQuery is filling the gaps. The second type of developer is an engineer who is tasked with scripting HTML documents that will only run in modern browsers or that will get ported to native code for multiple OS's and device distributions (e.g. PhoneGap) and needs to avoid the overhead (i.e. size or size v.s. use) of a library.</p>

<h2>Technical intentions, allowances, &amp; limitations</h2>
<ul>
	<li>The content and code contained in this book was written with modern (IE9+, Firefox latest, Chrome latest, Safari latest, Opera latest) browsers in mind. It was my goal to only include concepts and code that are native to modern browsers. If I venture outside of this goal I will bring this fact to the readers attention. I've generally steered away from including anything in this book that is browser specific or implemented in a minority of the modern browsers.</li>
	<li>I'm not attempting in this book to dogmatically focus on a specific DOM, CSS, or HTML specification. Its not my goal here to dogmatically represent a specific specification. This would be too large of an undertaking (with little value IMO) given the number of specifications at work and the history/status of browsers correctly implementing the specifications. I have leverage and balanced in a very subjective manner the content from several specifications (<a href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html">Document Object Model (DOM) Level 3 Core Specification</a>, <a href="http://www.w3.org/TR/dom/">DOM4</a>, <a href="http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/html.html">Document Object Model HTML </a>, <a href="http://www.w3.org/TR/ElementTraversal/">Element Traversal Specification</a>, <a href="http://www.w3.org/TR/selectors-api2/">Selectors API Level 2</a>, <a href="http://html5.org/specs/dom-parsing.html">DOM Parsing and Serialization</a>, <a href="http://dev.w3.org/html5/html-author/">HTML 5 Reference</a>, <a href="http://www.w3.org/TR/html5/">HTML 5 - A vocabulary and associated APIs for HTML and XHTML</a>, <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/">HTML Living Standard</a>, <a href="http://developers.whatwg.org/">HTML 5 - A technical specification for Web Developers</a>, <a href="http://dom.spec.whatwg.org/">DOM
Living Standard</a>). The content for this book is based more on where the community is and less on dogmatically attempting to express a specific spec.</li>
	<li>I'm covering several hand picked topics that are not DOM specific. I've included these topics in this book to help the reader build a proper understanding of the DOM in relationship to CSS and JavaScript.</li>
	<li>I've purposely left out any details as it pertains to XML or XHTML.</li>
	<li>I've purposely excluded the form and table api's to keep the book small. But I can see these sections being added in the future.</li>
</ul>
<h2>License</h2>

<p>The DOM Enlightenment HTML version is released under a <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative Commons Attribution-Noncommercial-No Derivative Works 3.0</a> unported license.</p>

<h2>Hard Copy &amp; eBook</h2>
<p><a href="http://oreilly.com/">O'Reilly</a> will release and sell a hard copy &amp; eBook in the near future.</p>

<h2>Preface</h2>
<p>Before you begin, it is important to understand various styles employed in this book. Please do not skip this section, because it contains important information that will aid you in the unique styles of this book.</p>

<h2>This book is not like other programming books</h2>
<p>The enlightenment series (<a href="http://jqueryenlightenment.com/">jQuery Enlightenment</a> &amp; <a href="http://javascriptenlightenment.com/">JavaScript Enlightenment</a>) is written in a style that favors small, isolated, immediately executable code over wordy explanations and monolithic programs. One of my favorite authors, C.S Lewis, asserts that words are the lowest form of communication that humans traffic in. I totally agree with this assertion and use it as the basis for the style of these books. I feel that technical information is best covered with as few words as possible, in conjunction with just the right amount of executable code and commenting required to express an idea. The style of this book attempts to present a clearly defined idea with as few words as possible, backed with real code. Because of this, when you first start grokking these concepts, you should execute and examine the code, thereby forming the foundation of a mental model for the words used to describe the concepts. Additionally, the format of these books attempts to systematically break ideas down into their smallest possible form and examine each one in an isolated context. All this to say that this is not a book with lengthy explanations or in-depth coverage on broad topics. Consider yourself warned. If it helps, think of it as a cookbook, but even more terse and to the point than usual.</p>

<h2>Color-coding conventions</h2>
<p>In the code examples (example shown below), orange is used to highlight code directly relevant to the concept being discussed. Any additional code used to support the orange colored code will be green. The color gray in the code examples is reserved for comments.</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;
&lt;script&gt;

<em>// this is a comment about a specific part of the code</em><br>var foo = <strong>'calling out this part of the code'</strong>;

&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;
</pre>
<h2>jsFiddle</h2>
<p>The majority of code examples in this book are linked to a corresponding <a href="http://jsfiddle.net/">jsFiddle</a> page, where the code can be tweaked and executed online. The jsFiddle examples have been configured to use the <a href="https://getfirebug.com/firebug-lite-debug.js">Firebug lite-dev plugin</a> to ensure the reader views the console.log prevalent in this book. Before reading this book, make sure you are comfortable with the usage and purpose of <em>console.log</em>.</p>
<p>In situations where jsFiddle caused complications with the code example, I simply chose not to link to a live example.</p>

<h2>About the Author</h2>
<p><a href="http://www.codylindley.com">Cody Lindley</a> is a client-side engineer (aka front-end developer) and recovering Flash developer. He has an extensive background working professionally (11+ years) with HTML, CSS, JavaScript, Flash, and client-side performance techniques as it pertains to web development. If he is not wielding client-side code he is likely toying with interface/interaction design or authoring material and speaking at various conferences. When not sitting in front of a computer, it is a sure bet he is hanging out with his wife and kids in Boise, Idaho &#x2013; training for triathlons, skiing, mountain biking, road biking, alpine climbing, reading, watching movies, or debating the rational evidence for a Christian worldview.</p>

<h2>Table of Contents</h2>







<div id="chapter1" class="chapter">


<h2>Chapter 1 - Node Overview</h2>
<h2>1.1 The Document Object Model (aka the DOM) is a hierarchy/tree of JavaScript node
 objects</h2>
<p>When you write an HTML document you encapsulate HTML content inside of
	other HTML content. By doing this you setup a hierarchy that can be
	expressed as a <a href="http://dvcs.w3.org/hg/domcore/raw-file/tip/Overview.html#trees">tree</a>.
	Often this hierarchy or encapsulation system is indicated visually by indenting
	markup in an HTML document. The browser when loading the HTML document
	interrupts and <a href="http://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#Parsing_general">parses
	this hierarchy to create a tree of node objects</a> that simulates how
	the markup is encapsulated. </p>
<pre class="noCodeLink">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;title&gt;HTML&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
<em>&lt;!-- Add your content here--&gt;</em>
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>The above HTML code when parsed by a browser creates a document that contains nodes structrured in a tree format (i.e. DOM). Below
	I reveal the tree struture from the above HTML document using Opera's Dragonfly DOM inspector. </p>
<p><img src="http://domenlightenment.com/images/c1sec1.png" alt="" width="730"> </p>
<p> On the left you see the HTML document in its tree form. And on the right you see the corresponding JavaScript object that represents the selected element on the left. For example, the selected <em>&lt;body&gt;</em> element highlighted in blue,
is an element node and an instance of the <em>HTMLBodyElement</em> interface.</p>
<p>What you should take away here is that html documents get parsed by a browser and converted into a tree structure of node objects representing a live document. The purpose of the DOM is to provide a programatic interface for scripting (removing, adding, replacing, eventing, modifiying) this live document using JavaScript. </p>
<div class="notes">
 <h3>Notes</h3>
 <p>The DOM originally was an application programming interface for XML documents that has been extended for use in HTML documents.</p>
</div>
<h2>1.2 Node object types</h2>
<p>The most common (I'm not highlighting all of them in the list below) types of nodes (i.e. <em>nodeType</em>/node classifications) one encounters when working with HTML documents are listed below.</p>
<ul>
	<li><em>DOCUMENT_NODE</em> (e.g. <em>window.document</em>)</li>
	<li><em>ELEMENT_NODE</em> (e.g. <em>&lt;body&gt;</em>, <em>&lt;a&gt;</em>, <em>&lt;p&gt;</em>, <em>&lt;script&gt;</em>, <em>&lt;style&gt;</em>, <em>&lt;html&gt;</em>, <em>&lt;h1&gt;</em> etc...)</li>
	<li><em>ATTRIBUTE_NODE</em> (e.g.<em> class="funEdges"</em>)</li>
	<li><em>TEXT_NODE</em> (e.g. text characters in an html document including carriage returns and white space)</li>
	<li><em>DOCUMENT_FRAGMENT_NODE</em> (e.g. <em>document.createDocumentFragment()</em>)</li>
	<li><em>DOCUMENT_TYPE_NODE</em> (e.g. <em>&lt;!DOCTYPE html&gt;</em>)</li>
</ul>
<p> I've listed the node types above formatted (all uppercase with _ separating words)
	exactly as the constant property is written in the JavaScript browser environment as a property of the <em>Node</em> object. These <em>Node</em> properties are constant values
	and are used to store numeric code values which map to a specific type of
	node object. For example in the following code example, <em>Node.ELEMENT_NODE</em> is equal to <em>1</em>.
	And <em>1</em> is the code value used to identify element nodes.</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;
&lt;script&gt;

console.log(<strong>Node.ELEMENT_NODE</strong>) <em>//logs 1, one is the numeric code value for element nodes</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>In the code below
	I log all of the node types and there values.</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;
&lt;script&gt;

for(var key in Node){
&#xA0; &#xA0;&#xA0;console.log(key,' = '+Node[key]); 
};

<em><strong>/* the above code logs to the console the following
ELEMENT_NODE = 1
ATTRIBUTE_NODE = 2
TEXT_NODE = 3
CDATA_SECTION_NODE = 4
ENTITY_REFERENCE_NODE = 5
ENTITY_NODE = 6
PROCESSING_INSTRUCTION_NODE = 7
COMMENT_NODE = 8
DOCUMENT_NODE = 9
DOCUMENT_TYPE_NODE = 10
DOCUMENT_FRAGMENT_NODE = 11
NOTATION_NODE = 12
DOCUMENT_POSITION_DISCONNECTED = 1
DOCUMENT_POSITION_PRECEDING = 2
DOCUMENT_POSITION_FOLLOWING = 4
DOCUMENT_POSITION_CONTAINS = 8
DOCUMENT_POSITION_CONTAINED_BY = 16
DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32 */</strong></em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>The previous code example gives an exhaustive list of all node types. For the purpose of this book I'll be discussing the shorter list of node types listed at the start of this section. These nodes will
	most likely be the ones you come in contact with when scripting an HTML page.</p>
<p> In the table below I list the name given to the interface/constructor that
	instantiates the most common node types and their corresponding <em>nodeType</em> classification by number and name. What I hope you take away from the table below is the <em>nodeType</em> value (i.e. <em>1</em>) is just a numeric classificaiton used to describe a certain type of node constructed from a certain JavaScript interface/constructor. For example, the <em>HTMLBodyElement</em> interface reprsents a node object that has a node type of <em>1</em>, which is a classification for <em>ELEMENT_NODE</em>'s.</p>

<div class="notes">
	<h3>Notes</h3>
	<p>The DOM specification semantically labels nodes like <em>Node</em>, <em>Element</em>, <em>Text</em>, <em>Attr</em>, and <em>HTMLAnchorElement</em> as an
		interface, which it is, but keep in mind its also the name given to the JavaScript
		constructor function that constructs the nodes. As you read this book I
		will be referring to these interfaces (i.e. <em>Element</em>, <em>Text</em>, <em>Attr</em>, <em>HTMLAnchorElement</em>) as objects or constructor
		functions while the specification refers to them as interfaces.</p>
	<p>The <em>ATTRIBUTE_NODE</em> is not actually part of a tree but listed for historical reasons. In this book I do not provide a chapter on attribute nodes and instead discuss them in the <em>Element</em> node chapter given that attributes nodes are sub-like nodes of element nodes with no particiipation in the actual DOM tree structure. Be aware the ATTRIBUTE_NODE is being depreciated in DOM 4.</p>
	<p>I've not included detail in this book on the <em>COMMENT_NODE</em> but you should be aware that comments in an HTML document are <em>Comment</em> nodes and similar in nature to <em>Text</em> nodes.</p>
	<p> As I discuss nodes throughout the book I will rarely refer to a
	specific node using its <em>nodeType</em> name (e.g. <em>ELEMENT_NODE</em>). This is done to be consistent with
	verbiage used in the specifications provided by the W3C &amp; WHATWG. </p>
</div>
<h2>1.3 Sub-node objects inherit from the <em>Node</em> object</h2>
<p>Each node object in a typical DOM tree inherits properties and methods from <em>Node</em>. Depending upon the type of node in the document there are also
	additional sub node object/interfaces that extend the <em>Node</em> object.
	Below I detail the inheritance model implemented by browsers for the most
	common node interfaces (&lt; indicates inherited from).</p>
<ul>
	<li><em>Object </em>&lt;<em> Node</em> &lt;&#xA0; <em>Element</em> &lt; <em>HTMLElement</em> &lt;&#xA0; (e.g. <em>HTML*Element</em>)</li>
	<li><em>Object </em>&lt;<em> </em><em>Node</em> &lt;&#xA0; <em>Attr</em> (This is deprecated in DOM 4)</li>
	<li><em>Object </em>&lt;<em> </em><em>Node</em> &lt;&#xA0; <em>CharacterData</em> &lt;&#xA0; <em>Text</em></li>
	<li><em>Object </em>&lt;<em> </em><em>Node</em> &lt;&#xA0; <em>Document</em> &lt;&#xA0; <em>HTMLDocument</em></li>
	<li><em>Object </em>&lt;<em> </em><em>Node</em> &lt;&#xA0; <em>DocumentFragment</em></li>
</ul>
<p>Its important not only to remember that all nodes types inherit from <em>Node</em> but that the chain of inheritance can be long. For example, all <em>HTMLAnchorElement</em> nodes inherit properties and methods from <em>HTMLElement</em>, <em>Element</em>, <em>Node</em>, and <em>Object</em> objects.</p>
<div class="notes">
	<h3>Notes</h3>
	<p><em>Node</em> is just a JavaScript constructor
		function. And so logically <em>Node</em> inherits from <em>Object.prototype</em> just like all objects in JavaScript</p>
</div>
<p>To verify that all node types inherit properties &amp; methods from the <em>Node</em> object lets loop over an <em>Element</em> node object and examine its
	properties and methods (including inherited).</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

<strong>&lt;a href="#"&gt;Hi&lt;/a&gt;</strong><em> &lt;!-- this is a HTMLAnchorElement which inherits from... --&gt;</em>

&lt;script&gt;

<em>//get reference to element node object</em>
var nodeAnchor = document.querySelector('a');
<em>
//create props array to store property keys for element node object</em>
var props = [];

<em>//loop over element node object getting all properties &amp; methods (inherited too)</em>
for(var key in nodeAnchor){
&#xA0; &#xA0; props.push(key); &#xA0; 
}

<em>//log alphabetical list of properties &amp; methods </em>
console.log(props.sort());

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>If you run the above code in a web browser you will see a long list of
	properties that are available to the element node object. The properties
	&amp; methods inherited from the <em>Node</em> object are in this list as
	well as a great deal of other inherited properties and methods from the <em>Element</em>, <em>HTMLElement</em>, <em>HTMLAnchorElement</em>, <em>Node</em>, and <em>Object</em> object. Its not my point to examine all of these properties and methods
	now but simply to point out that all nodes inherit a set of baseline
	properties and methods from its constructor as well as properties from the prototype chain.</p>
<p>If you are more of visual learner consider the inheritance chain denoted
	from examining the above HTML document with Opera's DOM inspector. </p>
<img src="http://domenlightenment.com/images/c1sec3.png" alt="" width="714">
<p>Notice that the anchor node inherits from <em>HTMLAnchorElement</em>, <em>HTMLElement</em>, <em>Element</em>, <em>Node</em>, and <em>Object</em> all shown in the
	list of properties highlighted with a gray background. This inheritance chain provides a great deal of shared methods and properties to all node types.</p>

<h2>1.4 Properties and methods for working nodes</h2>
<p>Like we have been discussing all node objects (e.g <em>Element</em>, <em>Attr</em>, <em>Text</em> etc...) inherit properties and methods from a primary <em>Node</em> object. These properties and methods are the baseline values and functions
	for manipulating, inspecting, and traversing the DOM. In addtion to the properties and methods provided by the node interface there are a great deal of other relevant properties and methods that are provided by sub node interfaces such as the <em>document</em>, <em>HTMLElement</em>, or <em>HTML*Element</em> interface.</p>
<p>Below I
	list out the most common <em>Node</em> properties and methods inherited by all node objects including the relevant inherited properties for working with nodes from sub-node interfaces.</p>

Node Properties:
<ul>
	<li><em>childNodes</em></li>
	<li><em>firstChild</em></li>
	<li><em>lastChild</em></li>
	<li><em>nextSibling</em></li>
	<li><em>nodeName</em></li>
	<li><em>nodeType</em></li>
	<li><em>nodeValue</em></li>
	<li><em>parentNode</em></li>
	<li><em>previousSibling</em></li>
</ul>
 Node Methods:
	<ul>
	<li><em>appendChild()</em></li>
	<li><em>cloneNode()</em></li>
	<li><em>compareDocumentPosition()</em></li>
	<li><em>contains()</em></li>
	<li><em>hasChildNodes()</em></li>
	<li><em>insertBefore()</em></li>
	<li><em>isEqualNode()</em></li>
	<li><em>removeChild()</em></li>
	<li><em>replaceChild()</em></li>
</ul>
	<p>Document Methods:</p>
	<ul>
		<li><em>document.createElement()</em></li>
		<li><em>document.createTextNode()</em></li>
	</ul>
	<p>HTML 10_misconceptions_about_neural_networks.md a_developer’s_journey_into_linux_containers.md aerofsgockerize.md andrewchildsovercast.md an_introduction_to_visual_programming_using_noflo.md artificial_neural_networks_for_beginners_»_loren_on_the_art_of_matlab.md automating_docker_logging_elasticsearch_logstash_kibana_and_logspout.md a_valid_ssl_certificate_for_every_ip_address__pivotal_pov.md a_walk_through_the_sais_algorithm__screwtapes_notepad.md b2_cloud_storage.md better_logging_in_nodejs_using_bunyan.md binaryjs.md brief_survey_on_methods_for_attacking_tor_hidden_service.md building_frontend_web_apps_with_plain_javascript.md checkpoint_and_restore_docker_container_with_criu.md containers_101.md cooking_with_docker_and_coreos_on_os_x.md coreos__kubernetes_step_by_step.md create_a_rest_api_with_nodejs.md create_your_own_streaming_service_with_emby.md cryptdbcryptdb.md cyrusandgdbdashboard.md dask__parallel_processing_through_blocked_algorithms¶.md data data.json delightimfreegeodb.md develop_command_line_application_using_nodejs.md digitaloceangodo.md document_clustering_with_python.md dosa_by_shon.md dosnapshot.md economic_secrets_of_the_dark_web—the_safe_easy_way_for_anyone_to_be_a_little_drug_lord.md eivind88prm.md even_easier_restful_api_with_nodejs_and_express_framework.md extending_layer_2_across_container_hosts.md file_input_to_gnuplot_through_python.md fix_time_machine_sparsebundle_nas_based_backup_errors.md flaskpotion.md flowchartjs.md free_ssltls_certificates.md gernestutron.md get_coreos_logs_into_elk_in_5_minutes.md getting_started_·_bootstrap_table.md getting_started.md google_project_hosting.md grammarlyrockercompose.md hacker_codex.md headroomjs.md how_can_i_repair_my_hard_drive_if_my_mac_won’t_start.md how_to_create_a_fullscreen_video_opening_animation.md how_to_create_a_network_backup_with_apples_timemachine.md how_to_create_an_os_x_mavericks_install_drive_updated.md html httpie_parse_url.sh httpsmediumcombibblioorg60youtubechannelsthatwillmakeyousmarter44d8315c2548.md icodeforlovedoapi.md imjasonhghfs.md install_sandstorm.md introducing_lemur.md introduction__building_web_apps_with_go.md introduction__getting_started_guide.md introduction.md introduction_to_monte_carlo_tree_search.md intro_to_webgl_with_threejs.md jamiehdigitaloceancsharp.md jmschreipomegranate.md jquery_responsive_lightbox.md jquery_treetable.md json_lines.md jssequencediagrams.md just_a_theory.md keendashboards.md koalalorenzopythondigitalocean.md launching_nginscript_and_looking_ahead__nginx.md let’s_write_a_web_extension.md let_your_applications_fly.md links_list.txt mangoslideout.md many_js_frameworks_but_vuejs_is_different.md mateogianoliosshync.md md meteor_react_tutorial_updated__match_made_in_heaven.md micc83edittable.md mistiomistio.md natural_language_basics_with_textblob.md null.md open_source_slackalternative_adopts_markdown.md openvswitchovs.md opsing_with_packer_and_terraform.md parse_urls_json.sh png prototype_interaction_and_animation.md pyra_full_prototypes_soon.md quintus_javascript_html5_game_engine.md reclaiming_a_timemachine_volume’s_disk_space.md resilient_substructure_for_your_microservice.md selzplyr.md setting_up_nginx_with_docker.md silentbicycleguff.md smdahlenvagrantdigitalocean.md snapcraft_tutorial.md sqljs.md storejs.md tgriesserbookshelf.md the_incomplete_collection_of_nodejs_performance_tips_—_node_and_beyond.md the_javascript_library_for_modern_browsers_and_touch_devices_no jquery.md the_javascript_tutorial.md the_math_i_learned_after_i_thought_had_already_learned_math.md the_new_art_of_war_how_trolls_hackers_and_spies_are_rewriting_the_rules_of conflict.md the_power_of_pcap__retrospection_in_practice.md the_what_how_and_why_of_single_var_pattern_in_javascript.md tidy time_machine_for_every_unix_out_there.md timothycrosleyhug.md top_15_facebook_open_source_projects_you_must_know_and_use_for_your_maker’s_projects.md ˈtræfɪk_·_ˈtræfɪk.md tugboat.md url_to_filename.csv using_an_offline_gnupg_master_key.md using_feathersjs_as_an_open_source_alternative_to_firebase_—_all_about_feathersjs.md using_the_office_ui_fabric_with_angular_js_to_create_an_office_addin.md valerylisaydigitaloceanapi.md webxray.md whose_xterm_is_it_anyway.md wikiimunesexamples_–_imunes.md wmiradropkit.md write_vanilla_comments_that_automagically_convert_into_full_test_spec_files.md wso2_machine_learner_why_would_you care.md yahoogryffin.md yoannmoinetnipplejs.md zenit.md Element Properties:</p>
	<ul>
		<li><em>innerHTML</em></li>
		<li><em>outerHTML</em></li>
		<li><em>textContent</em></li>
		<li><em>innerText</em></li>
		<li><em>outerText</em></li>
		
		<li><em>firstElementChild</em></li>
		<li><em>lastElementChild</em></li>
		<li><em>nextElementChild</em></li>
		<li><em>previousElementChild</em></li>
		<li><em>children</em></li>
	</ul>
	<p>HTML element Methods:</p>
	
<h2>1.5 Identifying the type and name of a node</h2>
<p>Every node has a <em>nodeType</em> and <em>nodeName</em> property that
	is inherited from <em>Node</em>. For example <em>Text</em> nodes have a <em>nodeType</em> code of <em>3</em> and <em>nodeName</em> value of <em>'#text'</em>. As
	previously mentioned the numeric value <em>3</em> is a numeric code representing the type
	of underlying object the node represents (i.e. <em>Node.TEXT_NODE === 3</em>).&#xA0;</p>
<p>
	Below I detail the values returned for <em>nodeType</em> and <em>nodeName</em> for the node objects discussed in this book. It makes sense to simply memorize these numeric code's for the more common nodes given that we are only dealing with 5 numeric codes.</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;a href="#"&gt;Hi&lt;/a&gt;

&lt;script&gt;

<em>//This is DOCUMENT_TYPE_NODE or nodeType 10 because Node.DOCUMENT_TYPE_NODE === 10</em>
console.log(
	<strong>document.doctype.nodeName</strong>, <em>//logs 'html' also try document.doctype to get &lt;!DOCTYPE html&gt;</em>
	<strong>document.doctype.nodeType</strong> <em>//logs 10 which maps to DOCUMENT_TYPE_NODE</em>
);<em></em>
<em>
//This is DOCUMENT_NODE or nodeType 9 because Node.DOCUMENT_NODE === 9</em>
console.log(
	<strong>document.nodeName</strong>, <em>//logs '#document'</em>
	<strong>document.nodeType</strong><em> //logs 9 which maps to DOCUMENT_NODE</em>
);

<em>//This is DOCUMENT_FRAGMENT_NODE or nodeType 11 because Node.DOCUMENT_FRAGMENT_NODE === 11</em>
console.log(
	<strong>document.createDocumentFragment().nodeName</strong>, <em>//logs '#document-fragment'</em>
	<strong>document.createDocumentFragment().nodeType</strong> <em>//logs 11 which maps to DOCUMENT_FRAGMENT_NODE</em>
);

<em>//This is ELEMENT_NODE or nodeType 1 because Node. ELEMENT_NODE === 1</em>
console.log(
	<strong>document.querySelector('a').nodeName</strong>, <em>//logs 'A'</em>
	<strong>document.querySelector('a').nodeType</strong> <em>//logs 1 which maps to ELEMENT_NODE</em>
);<em></em>

<em>//This is TEXT_NODE or nodeType 3 because Node.TEXT_NODE === 3</em>
console.log(
	<strong>document.querySelector('a').firstChild.nodeName</strong>, <em>//logs '#text'</em>
	<strong>document.querySelector('a').firstChild.nodeType</strong> <em>//logs 3 which maps to TEXT_NODE</em>
);<em></em><em></em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>If its not obvious the fastest way to determine if a node is of a
	certain type is too simply check its <em>nodeType</em> property. Below we
	check to see if the anchor element has a node number of 1. If it does than
	we can conclude that its an <em>Element</em> node because <em>Node.ELEMENT_NODE
	=== 1</em>.</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;a href="#"&gt;Hi&lt;/a&gt;

&lt;script&gt;

<em>//is &lt;a&gt; a ELEMENT_NODE?</em>
console.log(document.querySelector('a').<strong>nodeType</strong> === 1); <em>//logs true, &lt;a&gt; is an Element node</em>

<em>//or use Node.ELEMENT_NODE which is a property containg the numerice value of 1</em>
console.log(document.querySelector('a').<strong>nodeType</strong> === Node.ELEMENT_NODE); <em>//logs true, &lt;a&gt; is an Element node</em>

&lt;/script&gt;
&lt;/body&gt; 
&lt;/html&gt;
</pre>
<p>Determining the type of node that you might be scripting becomes very
	handy so that you might know which properties and methods are available to
	script the node.</p>
<div class="notes">
	<h3>Notes</h3>
	<p>The values returned by the <em>nodeName</em> property vary according
		to the node type. Have a look at the <a href="http://www.w3.org/TR/dom/#dom-node-nodename">DOM 4 specification</a> provided for the details.</p>
</div>
<h2>1.6 Getting a nodes value</h2>
<p>The <em>nodeValue</em> property returns <em>null</em> for most of the node types (except <em>Text</em>, and <em>Comment</em>). It's use is centered around extracting actual text strings from <em>Text</em> and <em>Comment</em> nodes. In the code below I demonstrate its use on all the nodes discussed in this book</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;a href="#"&gt;Hi&lt;/a&gt;

&lt;script&gt;

<em>//logs null for DOCUMENT_TYPE_NODE, DOCUMENT_NODE, DOCUMENT_FRAGMENT_NODE, ELEMENT_NODE</em> <em>below</em>
console.log(<strong>document.doctype.nodeValue</strong>);<em></em>
console.log(<strong>document.nodeValue</strong><em></em>);
console.log(<strong>document.createDocumentFragment().nodeValue</strong><em></em>);<em></em>
console.log(<strong>document.querySelector('a').nodeVale</strong><em></em>);

<em>//logs string of text</em>
console.log(<strong>document.querySelector('a').firstChild.nodeValue</strong>);<em></em><em></em> <em>//logs 'Hi'</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

<div class="notes">
	<h3>Notes</h3>
	<p><em>Text</em> or <em>Comment</em> node values can be set by providing new strings values for the <em>nodeValue</em> property(i.e. <em>document.body.firstElementChild.nodeValue = 'hi'</em>).</p>
</div>
<h2>1.7 Creating element and text nodes using JavaScript methods</h2>
<p>When a browser parses an HTML document it constructs the nodes and tree
	based on the contents of the HTML file. The browser deals with the creation of nodes for the intial loading of the HTML document. However its possible to create your own nodes using JavaScript. The following two methods allow us to programatically create <em>Element</em> and <em>Text</em> nodes using JavaScript. </p>
<ul>
	<li><em>createElement()</em></li>
	<li><em>createTextNode()</em></li>
</ul>
<p>Other methods are avaliable but are not commonly used (e.g. <em>createAttribute()</em> and <em>createComment()</em>) . In the code below I show how simple it is to create element and text nodes. </p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;
&lt;script&gt;

var elementNode&#xA0;= <strong>document.createElement('div')</strong>;
console.log(elementNode, elementNode.nodeType); <em>//log &lt;div&gt; 1, and 1 indicates an element node</em>

var textNode&#xA0;= <strong>document.createTextNode('Hi')</strong>;
console.log(textNode, textNode.nodeType); <em>//logs Text {} 3, and 3 indicates a text node</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<div class="notes">
	<h3>Notes</h3>
	<p>The <em>createElement()</em> method accepts one parameter which is a
		string specifying the element to be created. The string is the same
		string that is returned from the <em>tagName</em> property of an <em>Element</em> object. </p>
	<p>The <em>createAttribute()</em> method is depricated and should not be used for creating
		attribute nodes. Instead developers typically use <em>getAttribute()</em>, <em>setAttribute()</em>, and <em>removeAttribute()</em> methods. I will
		discus this in more detail in the <em>Element</em> node chapter.</p>
	<p> The <em>createDocumentFragment()</em> will be discussed in the chapter
		covering this method.</p>
	<p> You should be aware that a <em>createComment()</em> method is
		available for creating comment nodes. Its not discussed in this book but
		is very much available to a developer who finds its usage valuable. </p>
</div>
<h2>1.8 Creating and adding element and text nodes to the DOM using JavaScript strings</h2>
<p>The <em>innerHTML</em>, <em>outerHTML</em>, <em>textContent</em> and <em>insertAdjacentHTML()</em> properties and methods provide the
	functionality to create and add nodes to the DOM using JavaScript strings. </p>
<p> In the code below we are using the <em>innerHTML</em>, <em>outerHTML</em>,
	and <em>textContent</em> properties to create nodes from JavaScript
	strings that are then immediately added to the DOM.</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;div id="A"&gt;&lt;/div&gt;
&lt;span id="B"&gt;&lt;/span&gt;
&lt;div id="C"&gt;&lt;/div&gt;
&lt;div id="D"&gt;&lt;/div&gt;
&lt;div id="E"&gt;&lt;/div&gt;

&lt;script&gt;

<em>//create a strong element and text node and add it to the DOM</em>
document.getElementById('A').<strong>innerHTML</strong> = '&lt;strong&gt;Hi&lt;/strong&gt;'; 

<em>//create a div element and text node to replace &lt;span id="B"&gt;&lt;/div&gt; (notice span#B is replaced)</em>
document.getElementById('B').<strong>outerHTML</strong> = '&lt;div id="B" class="new"&gt;Whats Shaking&lt;/div&gt;'

<em>//create a text node and update the div#C with the text node</em>
document.getElementById('C').<strong>textContent</strong> = 'dude';


<em>//NON standard extensions below i.e. innerText &amp; outerText</em>

<em>//create a text node and update the div#D with the text node</em>
document.getElementById('D').<strong>innerText</strong> = 'Keep it';

<em>//create a text node and replace the div#E with the text node (notice div#E is gone)</em><br>document.getElementById('E').<strong>outerText</strong>&#xA0;=&#xA0;'real!';

console.log(document.body.innerHTML);
<em>/* logs
&lt;div id="A"&gt;&lt;strong&gt;Hi&lt;/strong&gt;&lt;/div&gt;
&lt;div id="B" class="new"&gt;Whats Shaking&lt;/div&gt;
&lt;span id="C"&gt;dude&lt;/span&gt;
&lt;div id="D"&gt;Keep it&lt;/div&gt;
real!
*/</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>The <em>insertAdjacentHTML()</em> method which only works on <em>Element</em> nodes is a good deal more precise than the previously mentioned methods<em></em>.
	Using this method its possible to insert nodes before the beginning tag,
	after the beginning tag, before the end tag, and after the end tag. Below
	I construct a sentence using the <em>insertAdjacentHTML()</em> method. </p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;&lt;i id="elm"&gt;how&lt;/i&gt;

&lt;script&gt;

var elm = document.getElementById('elm');

elm.insertAdjacentHTML('beforebegin',&#xA0;'&lt;span&gt;Hey-&lt;/span&gt;');
elm.insertAdjacentHTML('afterbegin',&#xA0;'&lt;span&gt;dude-&lt;/span&gt;');&#xA0;
elm.insertAdjacentHTML('beforeend',&#xA0;'&lt;span&gt;-are&lt;/span&gt;');&#xA0;
elm.insertAdjacentHTML('afterend',&#xA0;'&lt;span&gt;-you?&lt;/span&gt;');&#xA0;&#xA0;

console.log(document.body.innerHTML);
<em>/* logs
&lt;span&gt;Hey-&lt;/span&gt;&lt;i id="A"&gt;&lt;span&gt;dude-&lt;/span&gt;how&lt;span&gt;-are&lt;/span&gt;&lt;/i&gt;&lt;span&gt;-you?&lt;/span&gt;
*/</em><meta charset="utf-8">

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<div class="notes">
	<h3>Notes</h3>
	<p>The <em>innerHTML</em> property will convert html elements found in
		the string to actual DOM nodes while the <em>textContent</em> can only be used to construct text nodes. If you
		pass <em>textContent</em> a string containing html elements it will
		simply spit it out as text.</p>
	<p> <em>document.write()</em> can also be used to simultaneously create
		and add nodes to the DOM. However its typically not used anymore unless
		its usage is required to accomplish 3rd party scripting tasks. Basically
		the <em>write()</em> method will output the values passed to it into
		the page during page loading/parsing. You should be aware that using the <em>write()</em> method will stall/block the parsing of the html
		document being loaded.</p>
	<p><em>innerHTML</em> invokes a heavy &amp; expensive HTML parser where as text node generation is trivial thus use the innerHTML &amp; friends sparingly</p>
	<p> The <em>insertAdjacentHTML</em> options "beforebegin" and "afterend"
		will only work if the node is in the DOM tree and has a parent
		element.&#xA0;</p>
	<p> Support for <em>outerHTML</em> was not available natively in
		Firefox until version 11. A <a href="https://gist.github.com/1044128">polyfill</a> is avaliable.</p>
	<p><em>textContent</em>&#xA0;gets the content of all elements, including&#xA0;<em>&lt;script&gt;</em>&#xA0;and&#xA0;<em>&lt;style&gt;</em>&#xA0;elements,&#xA0;<em>innerText</em> does not</p>
	<p><em>innerText</em>&#xA0;is aware of style and will not return the text of hidden elements, whereas <em>textContent</em> will</p>
	<p>Avaliable to all modern browser except Firefox is <em>insertAdjacentElement()</em> and <em>insertAdjacentText()</em></p>
</div>
<h2>1.9 Extracting parts of the DOM tree as JavaScript strings </h2>
<p>The same exact properties (<em>innerHTML</em>, <em>outerHTML</em>, <em>textContent</em>)
	that we use to create and add nodes to the DOM can also be used to extract
	parts of the DOM (or really the entire DOM) as a JavaScript string. In the code example below I use these properties to return a string value containing text and html values from the HTML document.</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;div id="A"&gt;&lt;i&gt;Hi&lt;/i&gt;&lt;/div&gt;
&lt;div id="B"&gt;Dude&lt;strong&gt; !&lt;/strong&gt;&lt;/div&gt;

&lt;script&gt;

console.log(document.getElementById('A').<strong>innerHTML</strong>); <em>//logs '&lt;i&gt;Hi&lt;/i&gt;'</em><p>console.log(document.getElementById('A').<strong>outerHTML</strong>);&#xA0;<em>//logs &lt;div id="A"&gt;Hi&lt;/div&gt;</em>

<em>//notice that all text is returned even if its in child element nodes (i.e. &lt;strong&gt; !&lt;/strong&gt;) </em>
console.log(document.getElementById('B').<strong>textContent</strong>); <em>//logs 'Dude !'</em>

<em>//NON standard extensions below i.e. innerText &amp; outerText</em>

console.log(document.getElementById('B').<strong>innerText</strong>);<em>&#xA0;//logs 'Dude !'</em></p><p>console.log(document.getElementById('B').<strong>outerText</strong>);&#xA0;<em>//logs 'Dude !'&#x200B;</em>&#x200B;

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</p></pre>
<div class="notes">
	<h3>Notes</h3>
	<p>The <em>textContent</em>, <em>innerText</em>, <em>outerText</em> property when being read will return all of
		the text nodes contained within the selected node. So for example (not a good idea in practice), <em>document.body.textContent</em> will get all the text nodes contained in the body element not just the
		first text node.</p>
</div>
<h2>1.10 Adding node objects to the DOM using <em>appendChild()</em>&amp; <em>insertBefore() </em></h2>
<p>The <em>appendChild()</em> and <em>insertBefore()</em> <em>Node</em> methods allow us to insert JavaScript node objects into the DOM tree. The <em>appendChild()</em> method will append a node(s) to the end of the
	child node(s) of the node the method is called on. If there are no
	child node(s) then the node being appended is appended as the first
	child.&#xA0; For example in the code below we are creating a element node
	(<em>&lt;strong&gt;</em>) and text node (<em>Dude</em>). Then the <em>&lt;p&gt;</em> is selected from the DOM and our <em>&lt;strong&gt;</em> element is appended using <em>appendChild()</em>.
	Notice that the <em>&lt;strong&gt;</em> element is encapsulated inside of
	the <em>&lt;p&gt;</em> element and added as the last child node. Next the <em>&lt;strong&gt;</em> element is selected and the text <em>'Dude'</em> is appended
	to the <em>&lt;strong&gt;</em> element.</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;p&gt;Hi&lt;/p&gt;

&lt;script&gt;

<em>//create a blink element node and text node</em>
var elementNode = document.createElement('strong');
var textNode = document.createTextNode(' Dude');

<em>//append these nodes to the DOM</em>
document.querySelector('p').<strong>appendChild</strong>(elementNode);
document.querySelector('strong').<strong>appendChild</strong>(textNode);

<em>//log's &lt;p&gt;Hi&lt;strong&gt; Dude&lt;/strong&gt;&lt;/p&gt;</em><meta charset="utf-8">
console.log(document.body.innerHTML);

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>When it becomes necessary to control the location of insertion beyond
	appending nodes to the end of a child list of nodes we can use <em>insertBefore()</em>.
	In the code below I am inserting the <em>&lt;li&gt;</em> element before
	the first child node of the <em>&lt;ul&gt;</em> element. </p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;ul&gt;
&#xA0; &#xA0; &lt;li&gt;2&lt;/li&gt;
&#xA0; &#xA0; &lt;li&gt;3&lt;/li&gt;
&lt;/ul&gt;

&lt;script&gt;

<em>//create a text node and li element node and append the text to the li</em>
var text1&#xA0;= document.createTextNode('1');
var li&#xA0;= document.createElement('li');
li.appendChild(text1);

<em>//select the ul in the document</em>
var ul&#xA0;= document.querySelector('ul');

<em>/* 
add the li element we created above to the DOM, notice I call on &lt;ul&gt; and pass reference to &lt;li&gt;2&lt;/li&gt; using ul.firstChild 
*/</em>
ul.<strong>insertBefore</strong>(li,ul.firstChild);

console.log(document.body.innerHTML);
<em>/*logs
&lt;ul&gt;
&lt;li&gt;1&lt;/li&gt;
&lt;li&gt;2&lt;/li&gt;
&lt;li&gt;3&lt;/li&gt;
&lt;/ul&gt;
*/</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>The <em>insertBefore()</em> requires two parameters, the node to be inserted and the reference node in the document you would like the node inserted before.</p>
<div class="notes">
	<h3>Notes</h3>
	<p>If you do not pass the <em>insertBefore()</em> method a second
		parameter then it functions just like <em>appendChild()</em>. </p>
	<p>We have <a href="http://www.w3.org/TR/dom/#mutation-methods">more methods</a> (e.g. <em>prepend()</em>, <em>append()</em>, <em>before()</em>, <em>after()</em>) to look forward too in DOM 4.</p>
</div>
<h2>1.11 Removing and replacing nodes using <em>removeChild()</em> and <em>replaceChild()</em></h2>
<p>Removing a node from the DOM is a bit of a multi-step process. First you
	have to select the node you want to remove. Then you need to gain access
	to its parent element typically using the <em>parentNode</em> property. Its on the
	parent node that you invoke the <em>removeChild()</em> method passing it
	the reference to the node to be removed. Below I demonstrate its use on an
	element node and text node. </p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;div id="A"&gt;Hi&lt;/div&gt;
&lt;div id="B"&gt;Dude&lt;/div&gt;

&lt;script&gt;

<em>//remove element node</em>
var divA = document.getElementById('A');
divA.parentNode.<strong>removeChild</strong>(divA);

<em>//remove text node</em>
var divB = document.getElementById('B').firstChild;
divB.parentNode.<strong>removeChild</strong>(divB);

<em>//log the new DOM updates, which should only show the remaining empty div#B</em>
console.log(document.body.innerHTML);

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>Replacing an element or text node is not unlike removing one. In the code
	below I use the same html structure used in the previous code example
	except this time I use <em>replaceChild()</em> to update the nodes
	instead of removing them.</p>
 
 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;div id="A"&gt;Hi&lt;/div&gt;
&lt;div id="B"&gt;Dude&lt;/div&gt;

&lt;script&gt;

<em>//replace element node</em>
var divA = document.getElementById('A');
var newSpan = document.createElement('span');
newSpan.textContent = 'Howdy';
divA.parentNode.<strong>replaceChild</strong>(newSpan,divA);

<em>//replace text node</em>
var divB = document.getElementById('B').firstChild;
var newText = document.createTextNode('buddy');
divB.parentNode.<strong>replaceChild</strong>(newText, divB);

<em>//log the new DOM updates,</em> 
console.log(document.body.innerHTML);

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

<div class="notes">
	<h3>Notes</h3>
	<p>Depending upon what you are removing or replacing simply providing the <em> innerHTML</em>, <em>outerHTML</em>, and <em>textContent</em> properties with an empty string might be easier and faster. <a href="http://javascript.crockford.com/memory/leak.html">Careful memory leaks in brwoser might get you however</a>.</p>
	<p> Both <em>replaceChild()</em> and <em>removeChild()</em> return the
		replaced or remove node. Basically its not gone just because you
		replace it or remove. All this does is takes it out of the current live document. You still have a reference to it in memory.</p>
	<p>We have <a href="http://www.w3.org/TR/dom/#mutation-methods">more methods</a> (e.g.<em>replace()</em>, <em>remove()</em>) to look forward too in DOM 4.</p>
</div>
<h2>1.12 Cloning nodes using <em>cloneNode()</em></h2>
<p>Using the <em>cloneNode()</em> method its possible to duplicate a single
	node or a node and all its children nodes. </p>
<p> In the code below I clone only the <em>&lt;ul&gt;</em> (i.e. <em>HTMLUListElement)</em> which once
	cloned can be treated like any node reference.</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;ul&gt;
 &lt;li&gt;Hi&lt;/li&gt;
 &lt;li&gt;there&lt;/li&gt;
&lt;/ul&gt;

&lt;script&gt;

var cloneUL = document.querySelector('ul').<strong>cloneNode</strong>();

console.log(cloneUL.constructor); <em>//logs HTMLUListElement()</em>
console.log(cloneUL.innerHTML); <em>//logs (an empty string) as only the ul was cloned</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>To clone a node and all of its children nodes you pass the <em>cloneNode()</em> method a parameter of of <em>true</em>. Below I use the <em>cloneNode()</em> method again but this time we clone all of the child nodes as well.</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;ul&gt;
 &lt;li&gt;Hi&lt;/li&gt;
 &lt;li&gt;there&lt;/li&gt;
&lt;/ul&gt;

&lt;script&gt;

var cloneUL = document.querySelector('ul').cloneNode(<strong>true</strong>);

console.log(cloneUL.constructor); <em>//logs HTMLUListElement()</em>
console.log(cloneUL.innerHTML); <em>//logs &lt;li&gt;Hi&lt;/li&gt;&lt;li&gt;there&lt;/li&gt;</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<div class="notes">
	<h3>Notes</h3>
	<p>When cloning an <em>Element</em> node all attributes and values are
		also cloned. In fact, only attributes are copied! Everything else you
		can add (e.g. event handlers) to a DOM node is lost when cloning.</p>
	<p> You might think that cloning a node and its children using <em> cloneNode(true)</em> would return a <em>NodeList</em> but it in fact
		does not.</p>
	<p><em>cloneNode()</em>&#xA0;may lead to duplicate element IDs in a document</p>
</div>
<h2>1.13 Grokking node collections (i.e. <em>Nodelist</em> &amp; <em>HTMLcollection</em>)</h2>
<p>When selecting groups of nodes from a tree (cover in chaper 3) or accessing pre-defined sets of nodes, the nodes are either placed in a <a href="http://www.w3.org/TR/dom/#nodelist"><em>NodeList</em></a> (e.g. <em>document.querySelectorAll('*')</em>) or <a href="http://www.w3.org/TR/dom/#htmlcollection"><em>HTMLCollection</em></a> (e.g. <em>document.scripts</em>). These array like (i.e. not a real <em>Array</em>) object collections that have the following characteristics.</p>
<ul>
	<li>A collection can either be live or static. Meaning that the nodes contained in the collection are either literally part of the live document or a snapshot of the live document.</li>
	<li>By default nodes are sorted inside of the collection by tree order. Meaning the order matches the liner path from tree trunk to branches.</li>
	<li>The collections have a <em>length</em> property that reflects the number of elements in the list</li>
</ul>

<h2>1.14 Gettting a list/collection of all immediate child nodes</h2>
<p>Using the <em>childNodes</em> property produces an array like list (i.e. <a href="https://developer.mozilla.org/En/DOM/NodeList">NodeList</a>) of the immediate child nodes. Below I select the <em>&lt;ul&gt;</em> element which I then use to
	create a list of all of the immediate child nodes contained inside of the <em>&lt;ul&gt;</em>.</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;ul&gt;
 &lt;li&gt;Hi&lt;/li&gt;
 &lt;li&gt;there&lt;/li&gt;
&lt;/ul&gt;

&lt;script&gt;

var ulElementChildNodes = document.querySelector('ul').<strong>childNodes</strong>;

console.log(ulElementChildNodes); <em>//logs an array like list of all nodes inside of the ul</em>

<em>/*Call forEach as if its a method of NodeLists so we can loop over the NodeList. Done because NodeLists are array like, but do not directly inherit from Array*/</em>
Array.prototype.forEach.call(ulElementChildNodes,function(item){ 
&#xA0; &#xA0;console.log(item); //logs each item in the array
});&#xA0;

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<div class="notes">
	<h3>Notes</h3>
	<p> The <em>NodeList</em> returned by <em>childNodes</em> only contains
		immediate child nodes</p>
	<p> Be aware <em>childNodes</em> contains not only <em>Element</em> nodes but also all other node types (e.g. <em>Text</em> and <em> Comment</em> nodes)</p>
	<p><em>[].forEach</em> was implemented in ECMAScript 5th edtion</p>
</div>

<h2>1.15 Convert a <em>NodeList</em> or <em>HTMLCollection</em> to JavaScript <em>Array</em></h2>
<p>Node lists and html collections are array like but not a true JavaScript array which inherits array methods. In the code below we programtically confirm this using <em>isArray()</em>.</p>


<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;a href="#"&gt;&lt;/a&gt;

&lt;script&gt;

console.log(Array.<strong>isArray(document.links)</strong>); <em>//returns false, its an HTMLCollection not an Array</em>
console.log(Array.<strong>isArray(document.querySelectorAll('a'))</strong>); <em>//returns false, its an NodeList not an Array</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<div class="notes">
 <h3>Notes</h3>
 <p><em>Array.isArray</em> was implemented in ECMAScript 5th edtion or ES5</p>
</div>
<p>Converting a node list and html collection list to a true JavaScript array can provide a good deal of advantages. For one it gives us the ability to create a snapshot of the list that is not tied to the live DOM considering that <em>NodeList</em> and <em>HTMLCollection</em> are <a href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#td-live">live</a> lists. Secondly, converting a list to a JavaScript array gives access to the methods provided by the <em>Array</em> object (e.g. <em>forEach</em>, <em>pop</em>, <em>map</em>, <em>reduce</em> etc...). </p>
<p>To convert an array like list to a true JavaScript array pass the array-like list to <em>call()</em> or <em>apply()</em>, in which the <em>call()</em> or <em>apply()</em> is calling a method that returns an un-altered true JavaScript array. In the code below I use the <em>.slice()</em> method, which doesn't really slice anything I am just using it to convert the list to a JavaScript <em>Array</em> due to the fact the <em>slice()</em> returns an array.</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;a href="#"&gt;&lt;/a&gt;

&lt;script&gt;

console.log(Array.isArray(<strong>Array.prototype.slice.call(document.links)</strong>)); <em>//returns true</em>
console.log(Array.isArray(<strong>Array.prototype.slice.call(document.querySelectorAll('a'))</strong>)); <em>//returns true</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<div class="notes">
	<h3>Notes</h3>
	<p>In ECMAScript 6th edtion we have<em> Array.from</em> to look forward to which converts a single argument that is an array-like object or list (eg. <em>arguments</em>, <em>NodeList</em>, <em>DOMTokenList</em> (used by <em>classList</em>), <em>NamedNodeMap</em> (used by <em>attributes</em> property)) into a <em>new Array()</em> and returns it</p>
</div>

<h2>1.16 Traversing nodes in the DOM</h2>
<p> From a node reference (i.e. <em>document.querySelector('ul')</em>) its possible to get a different node reference by traversing the DOM using the following properties:</p>
<ul>
	<li><em>parentNode</em></li>
	<li><em>firstChild</em></li>
	<li><em>lastChild</em></li>
	<li><em>nextSibling</em></li>
	<li><em>previousSibling</em></li>
</ul>
<p>In the code example below we examine the <em>Node</em> properties
	providing DOM traversal functionality.</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;&lt;ul&gt;&lt;!-- comment --&gt;
&lt;li id="A"&gt;&lt;/li&gt;
&lt;li id="B"&gt;&lt;/li&gt;
&lt;!-- comment --&gt;
&lt;/ul&gt;

&lt;script&gt;

<em>//cache selection of the ul</em>
var ul = document.querySelector('ul');

<em>//What is the parentNode of the ul?</em>
console.log(ul.<strong>parentNode</strong>.nodeName); <em>//logs body</em><em></em>

<em>//What is the first child of the ul?</em>
console.log(ul.<strong>firstChild</strong>.nodeName); <em>//logs comment</em>

<em>//What is the last child of the ul?</em>
console.log(ul.<strong>lastChild</strong>.nodeName); <em>//logs text not comment, because there is a line break</em>

<em>//What is the nextSibling of the first li?</em>
console.log(ul.querySelector('#A').<strong>nextSibling</strong>.nodeName); <em>//logs text</em>

<em>//What is the previousSibling of the last li?</em>
console.log(ul.querySelector('#B').<strong>previousSibling</strong>.nodeName); <em>//logs text</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>If you have been around the DOM much then it should be no surprise that
	traversing the DOM includes not just traversing element nodes but also
	text and comment nodes. I believe the last code example makes this clear, and this is not exactly ideal. Using the
	following properties we can traverse the DOM ignoring text and comment
	nodes. </p>
<ul>
	<li><em>firstElementChild</em></li>
	<li><em>lastElementChild</em></li>
	<li><em>nextElementChild</em></li>
	<li><em>previousElementChild</em></li>
	<li><em>children</em></li>
</ul>
<div class="notes">
	<h3>Notes</h3>
	<p>The <em>childElementCount</em> is not mentioned but you should be aware of its avaliablity for calculating the number of child elements a node contains. </p>
</div>
<p>Examine our code example again using only element traversing methods.</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;&lt;ul&gt;&lt;!-- comment --&gt;
&lt;li id="A"&gt;&lt;/li&gt;
&lt;li id="B"&gt;&lt;/li&gt;
&lt;!-- comment --&gt;
&lt;/ul&gt;

&lt;script&gt;

<em>//cache selection of the ul</em>
var ul = document.querySelector('ul');

<em>//What is the first child of the ul?</em>
console.log(ul.<strong>firstElementChild</strong>.nodeName); <em>//logs li</em>

<em>//What is the last child of the ul?</em>
console.log(ul.<strong>lastElementChild</strong>.nodeName); <em>//logs li</em>

<em>//What is the nextSibling of the first li?</em>
console.log(ul.querySelector('#A').<strong>nextElementSibling</strong>.nodeName); <em>//logs li</em>

<em>//What is the previousSibling of the last li?</em>
console.log(ul.querySelector('#B').<strong>previousElementSibling</strong>.nodeName); <em>//logs li</em>

<em>//What are the element only child nodes of the ul? </em>
console.log(ul.<strong>children</strong>); <em></em><em>//HTMLCollection, all child nodes including text nodes</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<h2>1.17 Verify a node position in the DOM tree with <em>contains()</em> &amp; <em>compareDocumentPosition()</em></h2>
<p>Its possible to know if a node is contained inside of another node by
	using the <em>contains()</em> <em>Node</em> method. In the code below I
	ask if <em>&lt;body&gt;</em> is contained inside of <em>&lt;html lang="en"&gt;</em>.</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;script&gt;

<em>// is &lt;body&gt; inside &lt;html lang="en"&gt; ?</em>
var inside = document.querySelector('html').<strong>contains</strong>(document.querySelector('body'));

console.log(inside); <em>//logs true</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>If you need more robust information about the position of a node in the
	DOM tree in regards to the nodes around it you can use the <em>compareDocumentPosition()</em> <em>Node</em> method. Basically this method gives you the ability to
	request information about a selected node relative to the node 
	passed in. The information that you get back is a number that corresponds
	to the following information.</p>
<table class="table table-bordered" border="0">
	<thead>
		<tr>
			<th>number code returned from <em>compareDocumentPosition()</em>: </th>
			<th>number code info: </th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>0</td>
			<td> Elements are identical.</td>
		</tr>
		<tr>
			<td>1</td>
			<td> DOCUMENT_POSITION_DISCONNECTED<br>
				Set when selected node and passed in node are not in the same
				document.</td>
		</tr>
		<tr>
			<td> 2</td>
			<td>DOCUMENT_POSITION_PRECEDING<br>
				Set when passed in node is preceding selected node.</td>
		</tr>
		<tr>
			<td>3</td>
			<td>DOCUMENT_POSITION_FOLLOWING<br>
				Set when passed in node is following selected node.</td>
		</tr>
		<tr>
			<td>8</td>
			<td> DOCUMENT_POSITION_CONTAINS<br>
				Set when passed in node is an ancestor of selected node.</td>
		</tr>
		<tr>
			<td> 16, 10</td>
			<td>DOCUMENT_POSITION_CONTAINED_BY (16, 10 in hexadecimal)<br>
				Set when passed in node is a descendant of selected node.</td>
		</tr>
	</tbody>
</table>
<div class="notes">
	<h3>Notes</h3>
	<p><em>contains()</em> will return <em>true</em> if the node selected and
		node passed in are identical.</p>
	<p> <em>compareDocumentPosition()</em> can be rather confusing because
		its possible for a node to have more than one type of relationship with
		another node. For example when a node both contains (16) and precedes
		(4) the returned value from <em>compareDocumentPosition()</em> will be
		20.</p>
</div>
<h2>1.18 How to determine if two nodes are identical</h2>
<p><a href="http://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-isEqualNode">According
	to the DOM 3 specification</a> two nodes are equal if and only if the
	following conditions are satisfied:</p>
<meta charset="utf-8">
<ul>
	<li>The two nodes are of the same type.</li>
	<li>The following string attributes are equal:&#xA0;<em>nodeName</em>,&#xA0;<em>localName</em>,&#xA0;<em>namespaceURI</em>,&#xA0;<em>prefix</em>,&#xA0;<em>nodeValue</em>.
		That is: they are both&#xA0;null, or they have the same length and are
		character for character identical.</li>
	<li>The&#xA0;<em>attributes</em>&#xA0;<em>NamedNodeMaps</em>&#xA0;are
		equal. That is: they are both&#xA0;<em>null</em>, or they have the same
		length and for each node that exists in one map there is a node that
		exists in the other map and is equal, although not necessarily at the
		same index.</li>
	<li>The&#xA0;<em>childNodes</em>&#xA0;<em>NodeLists</em>&#xA0;are equal.
		That is: they are both&#xA0;<em>null</em>, or they have the same length
		and contain equal nodes at the same index. Note that normalization can
		affect equality; to avoid this, nodes should be normalized before being
		compared.</li>
</ul>
<p>Calling the <em>.isEqualNode()</em> method on a node in the DOM will ask
	if that node is equal to the node that you pass it as a parameter.
	Below I exhibt a case of an two equal nodes and two non-identical
	nodes.</p>


<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

<meta charset="utf-8">&lt;input type="text"&gt;
&lt;input type="text"&gt;

&lt;textarea&gt;foo&lt;/textarea&gt;
&lt;textarea&gt;bar&lt;/textarea&gt;

&lt;script&gt;

<em>//logs true, because they are exactly idential</em>
var input = document.querySelectorAll('input');
console.log(input[0].<strong>isEqualNode</strong>(input[1]));

<em>//logs false, because the child text node is not the same</em>
var textarea = document.querySelectorAll('textarea');
console.log(textarea[0].<strong>isEqualNode</strong>(textarea[1]));

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
<div class="notes">
	<h3>Notes</h3>
	<p>If you don't care about two nodes being exactly equal but instead
		want to know if two node references refer to the same node you can
		simply check it using the <em>===</em> opertor (i.e. <em>document.body === document.body</em>). This will tell us if they are identical but no equal.</p>
</div>


</div>




<div id="chapter2" class="chapter">

 <h2>Chapter 2 - Document Nodes</h2>
 <h2>2.1<em>document</em>node overview</h2>
 <p>The <em>HTMLDocument</em>
 constructor (which inherits from <em>document</em>) when instantiated 
 represents specifically a <em>DOCUMENT_NODE</em> (i.e. <em>window.document</em>)
 in the DOM. To verify this we can simply ask which constructor was used in
 the creation of the <em>document</em> node object.</p>
 
 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;
&lt;script&gt;

console.log(window.<strong>document.constructor</strong>); <em>//logs function HTMLDocument() { [native code] }</em>
console.log(window.<strong>document.nodeType</strong>); <strong><em>//logs 9, which is a numeric key mapping to DOCUMENT_NODE</em></strong>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
 <p>The code above concludes that the <em>HTMLDocument</em> constructor
 function constructs the <em>window.document</em> node object and that this node is a <em>DOCUMENT_NODE</em> object.</p>
 <div class="notes">
 <h3>Notes</h3>
 <p>Both <em>Document</em> and <em>HTMLDocument</em> constructors are
 typically instantiated by the browser when you load an HTML document. However, using <em>document.implementation.createHTMLDocument()</em> its possible to create your own HTML document outside of the one currently loaded into the browser. In addtion to <em>createHTMLDocument()</em> its also possible to create a document object which has yet to be setup as an HTML document using <em>createDocument()</em>. Typically the use of theses methods are associated with programatically providing an HTML document to an iframe.</p>
 </div>
 <h2>2.2 <em>HTMLDocument</em> properties and methods (including
 inherited) </h2>
 <p>To get accurate information pertaining to the available properties and
 methods on an <em>HTMLDocument</em> node its best to ignore the
 specification and to ask the browser what is available. Examine the arrays
 created in the code below detailing the properties and methods available
 from an <em>HTMLDocument</em> node (a.k.a. <em>window.document</em>)
 object.</p>
 
 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;
&lt;script&gt;

<em>//document own properties</em>
console.log(Object.keys(document).sort());

<em>//document own properties &amp; inherited properties</em>
var documentPropertiesIncludeInherited = [];
for(var p in document){
	documentPropertiesIncludeInherited.push(p);
}
console.log(documentPropertiesIncludeInherited.sort());

<em>//documment inherited properties only</em>
var documentPropertiesOnlyInherited = [];
for(var p in document){
	if(
		!document.hasOwnProperty(p)){documentPropertiesOnlyInherited.push(p);
	}
}
console.log(documentPropertiesOnlyInherited.sort());

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
 <p>The available properties are many even if the inherited properties were not
 considered. Below I've hand pick a list of noteworthy properties and
 methods for the context of this chapter. 
 </p>
 <ul>
 <li><em>doctype</em></li>
 <li><em>documentElement</em></li>
 <li><em>implementation</em>.*</li>
 <li><em>activeElement</em></li>
 <li><em>body</em></li>
 <li><em>head </em></li>
 <li><em>title</em></li>
 <li><em>lastModified</em></li>
 <li><em>referrer</em></li>
 <li><em>URL</em></li>
 <li><em>defaultview</em> </li>
 <li><em>compatMode</em></li>
 <li><em>ownerDocument</em></li>
 <li><em>hasFocus()</em></li>
 </ul>
 <div class="notes">
 <h3>Notes</h3>
 <p>The <em>HTMLDocument</em> node object is used to access (typically inherit) a great deal
 of the methods and properties available for working with the DOM (i.e. <em>document.querySelectorAll()</em>). You
 will be seeing many of these properties not discussed in this chapter
 discussed in the appropriate chapter's following this chapter.</p>
 </div>
 <h2>2.3 Getting general HTML document information (title, url, referrer, lastModified, compatMode)</h2>
 <p>The <em>document</em> object provides access to some general information
 about the HTML document/DOM being loaded. In the code below I use the <em>document.title</em>,
 <em>document.URL</em>, <em>document.referrer</em>, <em>document.lastModified</em>, and <em>document.compatMode</em> properties to gain some general information about the <em>document</em>.
 Based on the property name the returned values should be obvious.</p>
 
 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;
&lt;script&gt;

var d = document;
console.log('title = ' +d.<strong>title</strong>);
console.log('url = ' +d.<strong>URL</strong>);
console.log('referrer = ' +d.<strong>referrer</strong>);
console.log('lastModified = ' +d.<strong>lastModified</strong>);

<em>//logs either BackCompat (Quirks Mode) or CSS1Compat (Strict Mode)</em>
console.log('compatibility mode = ' +d.<strong>compatMode</strong>);

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
 <h2>2.4 <em>document</em> child nodes</h2>
 <p><em>Document</em> nodes can contain one <em>DocumentType</em> node
 object and one <em>Element</em> node object. This should not be a
 surprise since HTML documents typically contain only one doctype (e.g. <em>&lt;!DOCTYPE html&gt;</em>) and one element (e.g. <em>&lt;html lang="en"&gt;</em>). Thus if you ask for the children (e.g. <em>document.childNodes</em>)
 of the <em>Document</em> object you will get an array containing at the
 very least the documents doctype/DTD and <em>&lt;html lang="en"&gt;</em> element.
 The code below showcases that <em>window.document</em> is a type of node
 object (i.e<em> Document</em>) with child nodes.</p>
 
 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;
&lt;script&gt;
<em>
//This is the doctype/DTD</em>
console.log(document.childNodes[0].nodeType); <strong><em>//logs 10, which is a numeric key mapping to DOCUMENT_TYPE_NODE</em></strong>

<em>//This is the &lt;html&gt; element</em>
console.log(document.childNodes[1].nodeType); <em>//logs 1, which is a numeric key <strong><em>mapping to</em></strong> ELEMENT_TYPE_NODE</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
 <div class="notes">
 <h3>Notes</h3>
 <p>Don't confuse the <em>window.document</em> object created from <em>HTMLDocument</em>
 constructor with the <em>Document</em> object. Just remember <em>window.document</em>
 is the starting point for the DOM interface. That is why <em>document.childNodes</em>
 contains child nodes.</p>
 <p> If a comment node (not discussed in this book) is made outside of the
 <em> &lt;html lang="en"&gt;</em> element then it will become a child node of the <em>window.document</em>. However having comment nodes outside of the &lt;html&gt; element can cause some buggy results in IE and also is a violation of the DOM specification.</p>
 </div>
 <h2>2.5 <em>document</em> provides shortcuts to <em>&lt;!DOCTYPE&gt;</em>,
 <em>&lt;html lang="en"&gt;</em>, <em>&lt;head&gt;</em>, and <em>&lt;body&gt;</em></h2>
 <p>Using the properties listed below we can get a shortcut reference to the
 following nodes:</p>
 <ul>
 <li><em>document.doctype</em> refers to <em>&lt;!DOCTYPE&gt;&#xA0;</em></li>
 <li><em>document.documentElement </em>refers to <em>&lt;html lang="en"&gt;</em></li>
 <li><em>document.head</em> refers to <em>&lt;head&gt; </em></li>
 <li><em>document.body </em>refers to<em> &lt;body&gt;</em></li>
 </ul>
 <p>This is demonstrated in the code below. </p>
 
 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;
&lt;script&gt;
<em></em>
console.log(document.<strong>doctype</strong>); <em>// logs DocumentType {nodeType=10, ownerDocument=document, ...}</em>

console.log(document.<strong>documentElement</strong>); <em>// logs &lt;html&#xA0;lang="en"&gt;</em>

console.log(document.<strong>head</strong>); <em>// logs &lt;head&gt;</em>

console.log(document.<strong>body</strong>); <em>// logs &lt;body&gt;</em>

&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</pre>
 <div class="notes">
 <h3>Notes</h3>
 <p>The doctype or DTD is a <em>nodeType</em> of 10 or <em>DOCUMENT_TYPE_NODE</em>
 and should not be confused with the <em>DOCUMENT_NODE</em> (aka <em>window.document</em>
 constructed from <em>HTMLDocument()</em>). The doctype is constructed
 from the <em>DocumentType()</em> constructor.<br>
 </p>
 <p>In Safari, Chrome, and Opera the <em>document.doctype</em> does not
 appear in the <em>document.childNodes</em> list.</p>
 </div>
 <h2>2.6 Detecting DOM specifications/features using <em>document.implementation.hasFeature()</em>
 </h2>
 <p>Its possible using <em>document.implementation.hasFeature()</em> to ask
 (boolean) the current document what feature and level the browser
 has implemented/supports. For example we can ask if the browser has
 implemented the core DOM level 3 specification by passing the name of the
 feature and the version to the <em>hasFeature()</em> method. In the code
 below I ask if the browser has implemented the Core 2.0 &amp; 3.0 specification. </p>
 
 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;
&lt;script&gt;

console.log(document.<strong>implementation.hasFeature</strong>('Core','2.0'));<em></em>
console.log(document.<strong>implementation.hasFeature</strong>('Core','3.0')); <em></em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
 <p>The following table defines the features (<a href="http://www.w3.org/TR/DOM-Level-2-Core/introduction.html#ID-Conformance">spec
 calls these modules</a>) and versions that you can pass the <em>hasFeature()</em>
 method.</p>
 <table class="table table-bordered" border="0">
 <thead>
 <tr>
 <th>Feature </th>
 <th>Supported Versions </th>
 </tr>
 </thead>
 <tbody>
 <tr>
 <td>Core
 </td>
 <td> 1.0, 2.0, 3.0</td>
 </tr>
 <tr>
 <td>XML
 </td>
 <td>1.0, 2.0, 3.0</td>
 </tr>
 <tr>
 <td>
 HTML
 </td>
 <td>1.0, 2.0</td>
 </tr>
 <tr>
 <td>Views
 </td>
 <td>2.0
 </td>
 </tr>
 <tr>
 <td>StyleSheets
 </td>
 <td> 2.0</td>
 </tr>
 <tr>
 <td>
 CSS
 </td>
 <td>2.0</td>
 </tr>
 <tr>
 <td>CSS2
 </td>
 <td>2.0
 </td>
 </tr>
 <tr>
 <td>Events
 </td>
 <td>2.0, 3.0</td>
 </tr>
 <tr>
 <td>UIEvents
 </td>
 <td>2.0, 3.0
 </td>
 </tr>
 <tr>
 <td>MouseEvents
 </td>
 <td>2.0, 3.0</td>
 </tr>
 <tr>
 <td>MutationEvents
 </td>
 <td>2.0, 3.0
 </td>
 </tr>
 <tr>
 <td>HTMLEvents
 </td>
 <td>2.0
 </td>
 </tr>
 <tr>
 <td>Range
 </td>
 <td>2.0
 </td>
 </tr>
 <tr>
 <td>Traversal
 </td>
 <td>2.0
 </td>
 </tr>
 <tr>
 <td>LS (Loading and saving between files and DOM trees synchronously)
 </td>
 <td>3.0
 </td>
 </tr>
 <tr>
 <td>LS-Asnc (Loading and saving between files and DOM trees
 asynchronously)
 </td>
 <td>3.0
 </td>
 </tr>
 <tr>
 <td>Validation
 </td>
 <td>3.0
 </td>
 </tr>
 </tbody>
 </table>
 <div class="notes">
 <h3>Notes</h3>
 <p>Don't trust <em>hasFeature()</em> alone you should also use <a href="http://dev.opera.com/articles/view/using-capability-detection/">capability
 detection</a> in addition to <em>hasFeature()</em>. </p>
 <p>Using the <em>isSupported</em> method implementation information can
 be gathered for a specific/selected node only (i.e. <em>element.isSupported(feature,version</em>).</p>
 <p>You can determince online what a user agent supports by visiting <a href="http://www.w3.org/2003/02/06-dom-support.html">http://www.w3.org/2003/02/06-dom-support.html</a>. Here you will find a table indicating what the browser loading the url claims to implement.</p>
 </div>
 <h2>2.7 Get a reference to the focus/active node in the <em>document</em> </h2>
 <p>Using the <em>document.activeElement</em> we can quickly get a reference
 to the node in the document that is focused/active. In the code below, on
 page load, I am setting the focus of the document to the <em>&lt;textarea&gt;</em>
 node and then gaining a reference to that node using the <em>activeElement</em>
 property.</p>
 
 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;
&lt;textarea&gt;&lt;/textarea&gt;

&lt;script&gt;

<em>//set focus to &lt;textarea&gt;</em>
document.querySelector('textarea').focus();

<em>&#x200B;//get reference to element that is focused/active in the document</em>
console.log(document.<strong>activeElement</strong>); <em>//logs &lt;textarea&gt;</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
 <div class="notes">
 <h3>Notes</h3>
 <p>The focused/active element returns elements that have the ability to be
 focused. If you visit a web page in a browser and start hitting the tab
 key you will see focus shifting from element to element in that page that can
 get focused. Don't confuse the selection of nodes (highlight sections of
 the HTML page with mouse) with elements that get focus for the purpose
 of inputting something with keystrokes, spacebar, or mouse. </p>
 </div>
 <h2>2.8 Determing if the <em>document </em> or any node inside of the <em>document</em> has focus</h2>
 <p>Using the document.hasFocus() method its possible to know if the user currently is focused on the window that has the HTML document loaded. In the code below you see that if we execute the code and then focus another window, tabe, or application all together the <em>getFocus()</em> will return false.</p>
 
 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;script&gt;<em></em>

<em>//If you keep focus on the window/tab that has the document loaded its true. If not it's false.</em>
setTimeout(function(){console.log(<strong>document.hasFocus(</strong>))},5000);<strong></strong>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
 <h2>2.9 <em>document.defaultview</em> is a shortcut to the head/global object</h2>
 <p>You should be aware that the <em>defaultView</em> property is a shortcut to 
 the JavaScript head object or what some refer to as the global object. The head object in a web browser is the <em>window</em> object and <em>defaultView</em> will point to this object in a JavaScript browser enviroment. The code below demonstrates the value of <em>defaultView</em> in a browser.</p>
 
 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;
&lt;script&gt;

console.log(document.<strong>defaultView</strong>) <em>//reference, head JS object. Would be window object in a browser.</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
 <p>If you are dealing with a DOM that is headless or an JavaScript enviroment that is not running in a web browser (i.e. <a href="http://nodejs.org/">node.js</a>)
 this property can get you access to the head object scope. </p>
<h2>2.9 Getting a reference to the <em>Document</em> from an <em>element</em> using <em>ownerDocument</em></h2>
<p>The <em>ownerDocument</em> property when called on a node returns a reference to the <em>Document</em> the node is contained within. In the code below I get a reference to the <em>Document</em> of the <em>&lt;body&gt;</em> in the HTML document and the <em>Document</em> node for the <em>&lt;body&gt;</em> element contained inside of the iframe.</p>

<p class="codeLink">live code: N/A</p>
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;iframe src="http://someFileServedFromServerOnSameDomain.html"&gt;&lt;/iframe&gt;

&lt;script&gt;

<em>//get the window.document that the &lt;body&gt; is contained within</em>
console.log(document.body.<strong>ownerElement</strong>);

<em>//get the window.document the &lt;body&gt; inside of the iframe is contained within</em>
console.log(window.frames[0].document.body.<strong>ownerElement</strong>);

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
<p>If <em>ownerDocument</em> is called on the <em>Document</em> node the value returned is <em>null</em>.</p>
 
</div>




<div id="chapter3" class="chapter">

 <h2>Chapter 3 - Element Nodes </h2>
 <h2>3.1 <em>HTML*Element</em> object overview</h2>
 <p>Elements in an html document all have a unique nature and as such they
 all have a unique <a href="http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/html.html">JavaScript
 constructor</a> that instantiates the element as a node object in a DOM
 tree. For example an <em>&lt;a&gt;</em> element is created as a DOM node
 from the <em>HTMLAnchorElement()</em> constructor. Below we verify that an
 anchor element is created from <em>HTMLAnchorElement()</em>.</p>
 
 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;a&gt;&lt;/a&gt;

&lt;script&gt;
<em>
// grab &lt;a&gt; element node from DOM and ask for the name of the constructor that constructed it</em>
console.log(document.querySelector('a').<strong>constructor</strong>);
<em>//logs function HTMLAnchorElement() { [native code] }</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
 <p>The point I am trying to express in the previous code example is that each element in the DOM is constructed from a unique JavaScript intefaces/constructor. The list below (not a <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/section-index.html#elements-1">complete list</a>) should give you a good sense of the interfaces/constructors used to create HTML elements.</p>
 <ul>
 	<li><em>HTMLHtmlElement</em></li>
 	<li><em>HTMLHeadElement</em></li>
 	<li><em>HTMLLinkElement</em></li>
 	<li><em>HTMLTitleElement</em></li>
 	<li><em>HTMLMetaElement</em></li>
 	<li><em>HTMLBaseElement</em></li>
 	<li><em>HTMLIsIndexElement</em></li>
 	<li><em>HTMLStyleElement</em></li>
 	<li><em>HTMLBodyElement</em></li>
 	<li><em>HTMLFormElement</em></li>
 	<li><em>HTMLSelectElement</em></li>
 	<li><em>HTMLOptGroupElement</em></li>
 	<li><em>HTMLOptionElement</em></li>
 	<li><em>HTMLInputElement</em></li>
 	<li><em>HTMLTextAreaElement</em></li>
 	<li><em>HTMLButtonElement</em></li>
 	<li><em>HTMLLabelElement</em></li>
 	<li><em>HTMLFieldSetElement</em></li>
 	<li><em>HTMLLegendElement</em></li>
 	<li><em>HTMLUListElement</em></li>
 	<li><em>HTMLOListElement</em></li>
 	<li><em>HTMLDListElement</em></li>
 	<li><em>HTMLDirectoryElement</em></li>
 	<li><em>HTMLMenuElement</em></li>
 	<li><em>HTMLLIElement</em></li>
 	<li><em>HTMLDivElement</em></li>
 	<li><em>HTMLParagraphElement</em></li>
 	<li><em>HTMLHeadingElement</em></li>
 	<li><em>HTMLQuoteElement</em></li>
 	<li><em>HTMLPreElement</em></li>
 	<li><em>HTMLBRElement</em></li>
 	<li><em>HTMLBaseFontElement</em></li>
 	<li><em>HTMLFontElement</em></li>
 	<li><em>HTMLHRElement</em></li>
 	<li><em>HTMLModElement</em></li>
 	<li><em>HTMLAnchorElement</em></li>
 	<li><em>HTMLImageElement</em></li>
 	<li><em>HTMLObjectElement</em></li>
 	<li><em>HTMLParamElement</em></li>
 	<li><em>HTMLAppletElement</em></li>
 	<li><em>HTMLMapElement</em></li>
 	<li><em>HTMLAreaElement</em></li>
 	<li><em>HTMLScriptElement</em></li>
 	<li><em>HTMLTableElement</em></li>
 	<li><em>HTMLTableCaptionElement</em></li>
 	<li><em>HTMLTableColElement</em></li>
 	<li><em>HTMLTableSectionElement</em></li>
 	<li><em>HTMLTableRowElement</em></li>
 	<li><em>HTMLTableCellElement</em></li>
 	<li><em>HTMLFrameSetElement</em></li>
 	<li><em>HTMLFrameElement</em></li>
 	<li><em>HTMLIFrameElement </em></li>
 </ul>
 <p>Keep in mind each <em>HTML*Element </em>above inherits properties and methods from <em>HTMLElement</em>, <em>Element</em>, <em>Node</em>,
 and <em>Object</em>.</p>
	 
 <h2>3.2 <em>HTML*Element</em> object properties and methods
 (including inherited)</h2>
 <p>To get accurate information pertaining to the available properties and
 methods on an <em>HTML*Element</em> node
 its best to ignore the specification and to ask the browser what is
 available. Examine the arrays created in the code below detailing the
 properties and methods available from
 HTMLelement nodes. </p>
 
 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;a href="#"&gt;Hi&lt;/a&gt;

&lt;script&gt;

var anchor = document.querySelector('a');

<em>//element own properties</em>
console.log(Object.keys(anchor).sort());

<em>//element own properties &amp; inherited properties</em>
var documentPropertiesIncludeInherited = [];
for(var p in document){
	documentPropertiesIncludeInherited.push(p);
}
console.log(documentPropertiesIncludeInherited.sort());

<em>//element inherited properties only</em>
var documentPropertiesOnlyInherited = [];
for(var p in document){
	if(!document.hasOwnProperty(p)){
		documentPropertiesOnlyInherited.push(p);
	}
}
console.log(documentPropertiesOnlyInherited.sort());

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
 <p>The available properties are many even if the inherited properties were
 not considered. Below I've hand pick a list of note worthy properties and
 methods (inherited as well) for the context of this chapter. </p>
 <ul>
 <li><em>createElement()</em></li>
 <li><em>tagName</em></li>
 <li><em>children</em> </li>
 <li><em>getAttribute()</em></li>
 <li><em>setAttribute()</em></li>
 <li><em>hasAttribute()</em></li>
 <li><em>removeAttribute()</em></li>
 <li><em>classList()</em></li>
 <li><em>dataset</em></li>
 <li><em>attributes</em></li>
 </ul>
 <p>For a complete list check out the
 MDN documentation which covers the <a href="https://developer.mozilla.org/en/DOM/element">general
 properties and methods</a> available to most HTML elements. </p>
<h2>3.3 Creating Elements</h2>
<p><em>Element</em> nodes are instantiated for us when a browser interputs an HTML document and a corresponding DOM is built based on the contents of the document. After this fact, its also possible to programaticlly create <em>Element</em> nodes using <em>createElement()</em>. In the code below I create a <em>&lt;textarea&gt;</em> element node and then inject that node into the live DOM tree.</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;
&lt;script&gt;

var elementNode = document.<strong>createElement('textarea')</strong>; <em>//HTMLTextAreaElement() constructs &lt;textarea&gt;</em>
document.body.appendChild(elementNode);

console.log(document.querySelector('textarea')); <em>//verify it's now in the DOM</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

<p>The value passed to the <em>createElement()</em> method is a string that specifices the type of element (aka <em><a href="http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-104682815">tagName</a></em>) to be created.</p>

<div class="notes">
 <h3>Notes</h3>
 
 <p>This value passed to createElement is changed to a lower-case string before the element is created.</p></div>
<h2>3.4 Get the tag name of an element</h2>
 <p>Using the
 <em>tagName</em> property we can access the name of an element. The <em>tagName</em>
 property returns the same value that using <em>nodeName</em> would
 return. Both return the value in uppercase regardless of the case in the source HTML document.</p>
 <p>Below we get the name of an <em>&lt;a&gt;</em> element in the DOM.</p>
 
 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;a href="#"&gt;Hi&lt;/a&gt;

&lt;script&gt;

console.log(document.querySelector('a').<strong>tagName</strong>); <em>//logs A</em>

<em>//the nodeName property returns the same value</em>
console.log(document.querySelector('a').<strong>nodeName</strong>); <em>//logs A</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

 <h2>3.5 Getting a list/collection of element attributes and values </h2>
 <p>Using the <em>attributes</em> property (inherited by element nodes from
 <em>Node</em>) we can get a collection of the <em><a href="http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-637646024">Attr</a>
 </em>nodes that an element currently has defined. The list returned is a <em><a href="https://developer.mozilla.org/en/DOM/NamedNodeMap">NameNodeMap</a></em>.
 Below I loop over the attributes collection exposing each <em>Attr</em>
 node object contained in the collection. </p>
 
 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;a href='#' title="title" data-foo="dataFoo" class="yes" style="margin:0;" foo="boo"&gt;&lt;/a&gt;

&lt;script&gt;

var atts =&#xA0;document.querySelector('a').<strong>attributes</strong>;

for(var&#xA0;i=0;&#xA0;i&lt;&#xA0;atts.length;&#xA0;i++){
	console.log(atts[i].nodeName&#xA0;+'='+&#xA0;atts[i].nodeValue);
}

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
 <div class="notes">
 <h3>Notes</h3>
 <p>The array returned from accessing the attributes property should be
 consider live. Meaning that its contents can be changed at anytime.</p>
 <p>The array that is returned inherits from the <em>NameNodeMap</em>
 which provides methods to operate on the array such as <em>getNamtedItem()</em>,
 <em>setNamedItem()</em>, and <em>removeNamedItem()</em>. Operating on <em>attributes</em>
 with these methods should be secondary to using <em>getAttribute()</em>,
 <em>setAttribute()</em>, <em>hasAttribute()</em>, <em>removeAttribute()</em>.
 Its this authors opinion that dealing with <a href="http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-637646024">Attr</a>
 nodes is messy. The only merit in using the <em>attributes</em> is found only in its 
 funcitonaly for returning a list of live attributes.</p>
 <p>The <em>attributes</em> property is an array like collection and has a
 read only <em>length</em> property.</p>
 <p>Boolean attributres (e.g. <em>&lt;option selected&gt;foo&lt;/option&gt;</em>) show up in the <em>attributes</em> list but of course have no value unless you provide one (e.g. <em>&lt;option selected="selected"&gt;foo&lt;/option&gt;</em>).</p>
 </div>
 <h2>3.6 Getting, Setting, &amp; Removing an element's attribute value</h2>
 <p>The most consistent way to get, set, or remove an elements <a href="http://www.whatwg.org/specs/web-apps/current-work/#attributes-1">attribute</a> value is to use the <em>getAttribute(), setAttribute(),</em> and <em>removeAttribute()</em>
 method. In the code below I demonstrate each of these methods for managing element attributes.</p>
 
 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;a href='#' title="title" data-foo="dataFoo" style="margin:0;" class="yes" foo="boo" hidden="hidden"&gt;#link&lt;/a&gt;

&lt;script&gt;

var atts =&#xA0;document.querySelector('a');

<em>//remove attributes</em>
atts.<strong>removeAttribute</strong>('href');
atts.<strong>removeAttribute</strong>('title');
atts.<strong>removeAttribute</strong>('style');
atts.<strong>removeAttribute</strong>('data-foo');
atts.<strong>removeAttribute</strong>('class');
atts.removeAttribute('foo');&#xA0;<em>//custom attribute</em><br>atts.removeAttribute('hidden');&#xA0;<em>//boolean attribute</em>

<em>//set (really re-set) attributes</em>
atts.<strong>setAttribute</strong>('href','#');
atts.<strong>setAttribute</strong>('title','title');
atts.<strong>setAttribute</strong>('style','margin:0;');
atts.<strong>setAttribute</strong>('data-foo','dataFoo');
atts.<strong>setAttribute</strong>('class','yes');
atts.<strong>setAttribute</strong>('foo','boo');
atts.<strong>setAttribute</strong>('hidden','hidden');<em>&#xA0;//boolean attribute requires sending the attribute as the value too</em>

<em>//get attributes</em>
console.log(atts.<strong>getAttribute</strong>('href'));
console.log(atts.<strong>getAttribute</strong>('title'));
console.log(atts.<strong>getAttribute</strong>('style'));
console.log(atts.<strong>getAttribute</strong>('data-foo'));
console.log(atts.<strong>getAttribute</strong>('class'));
console.log(atts.<strong>getAttribute</strong>('foo'));
console.log(atts.<strong>getAttribute</strong>('hidden'));

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
 <div class="notes">
 <h3>Notes</h3>
 <p>Use <em>removeAttribute()</em> instead of setting the attribute value to <em>null</em> or <em>''</em> using <em>setAttribute()</em> </p>
 <p>Some element attributes are available from element nodes as object properties (i.e. <em>document.body.id</em> or <em>document.body.className</em>). This author recommends avoiding these properties and using the remove, set, and get attribute methods.</p>
 </div>
 <h2>3.7 Verifying an element has a specific attribute</h2>
 <p>The best way to determine (i.e. boolean) if an element has an
 attribute is to use the <em>hasAttribute()</em>&#xA0; method. Below I
 verify if the <em>&lt;a&gt;</em> has a <em>href</em>, <em>title</em>, <em>style</em>,
 <em>data-foo</em>, <em> class</em>, and <em>foo</em> attribute.</p>
 
 
 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;a href='#' title="title" data-foo="dataFoo" style="margin:0;" class="yes" goo&gt;&lt;/a&gt;

&lt;script&gt;

var atts =&#xA0;document.querySelector('a');

console.log(
	atts.<strong>hasAttribute</strong>('href'),
	atts.<strong>hasAttribute</strong>('title'),
	atts.<strong>hasAttribute</strong>('style'),
	atts.<strong>hasAttribute</strong>('data-foo'),
	atts.<strong>hasAttribute</strong>('class'),
	atts.<strong>hasAttribute</strong>('goo') <em>//Notice this is true regardless if a value is defined </em>
)

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
 <p>This method will return <em>true</em> if the element contains the attribute even
 if the attribute has no value. For example using <em>hasAttribute()</em> we can get a boolean response for <a href="http://www.w3.org/TR/html4/intro/sgmltut.html#h-3.3.4.2">boolean attributes</a>. In the code example below we check to see if a checkbox is checked.</p>
	 
	 
 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;input type="checkbox" checked&gt;&lt;/input&gt;

&lt;script&gt;

var atts =&#xA0;document.querySelector('input');

console.log(atts.<strong>hasAttribute</strong>('checked'));<em> //logs true</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
	 
 <h2>3.8 Getting a list of class attribute values</h2>
 <p>Using the <em>classList</em> property available on element nodes we can
 access a list (i.e. <em><a href="http://www.w3.org/TR/dom/#interface-domtokenlist">DOMTokenList</a></em>) of class attribute values that is much easier to work with
 than a space-delimited string value returned from the <em>className</em>
 property. In the code below I contrast the use of <em>classList</em> with <em>className</em>.</p>
 
 
 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;div&#xA0;class="big brown bear"&gt;&lt;/div&gt;

&lt;script&gt;

var elm = document.querySelector('div');

console.log(elm.<strong>classList</strong>); <em>//big brown bear {0="big", 1="brown", 2="bear", length=3, ...}</em>
console.log(elm.className); <em>//logs 'big brown bear'</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
 <div class="notes">
 <h3>Notes</h3>
 <p>Given the <em>classList</em> is an array like collection it has a read
 only <em>length</em> property.</p>
 <p><em>classList</em> is read-only but can be modifyied using the <em>add()</em>,<em> remove()</em>, <em>contains()</em>, and <em>toggle()</em> methods</p>
 <p>IE9 does not support <em>classList</em>. Support will land in <a href="http://blogs.msdn.com/b/ie/archive/2012/05/31/windows-release-preview-the-sixth-ie10-platform-preview.aspx">IE10</a>. <a href="https://github.com/eligrey/classList.js">Several</a> <a href="https://gist.github.com/1381839">polyfills</a> are avaliable.</p>
 </div>
<h2>3.9 Adding &amp; removing sub-values to a class attribute</h2>
 <p>Using the <em>classList.add()</em> and <em>classList.remove()</em>
 methods its extremely simple to edit the value of a class attribute. In
 the code below I demonstrated adding and removing class values.</p>
 
 
 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;
&lt;div class="dog"&gt;&lt;/div&gt;&#x200B;

&lt;script&gt;

var elm = document.querySelector('div');

elm.classList.<strong>add</strong>('cat');
elm.classList.<strong>remove</strong>('dog');
console.log(elm.className); <em>//'cat'</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
 <h2>3.10 Toggling a class attribute value</h2>
 <p>Using the <em>classList.toggle()</em> method we can toggle a sub-value
 of the class attribute. This allows us to add a value if its missing or
 remove a value if its already added. In the code below I toggle the <em>'visible'</em>
 value and the <em>'grow'</em> value. Which essentially means I remove <em>'visible'</em>
 and add <em>'grow'</em> to the class attribute value. </p>

 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;
&lt;div class="visible"&gt;&lt;/div&gt;&#x200B;

&lt;script&gt;

var elm = document.querySelector('div');

elm.classList.<strong>toggle</strong>('visible');
elm.classList.<strong>toggle</strong>('grow');
console.log(elm.className);<em> //'grow'</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<h2>3.11 Determining if a class attribute value contains a specific value<br>
 </h2>
<p>Using the <em>classList.contains()</em> method its possible to determine
 (boolean) if a class attribute value contains a specific sub-value.
 In the code below we test weather the <em>&lt;div&gt;</em> class
 attribute contains a sub-value of <em>brown</em>. </p>

 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;
&lt;div class="big brown bear"&gt;&lt;/div&gt;&#x200B;

&lt;script&gt;

var elm = document.querySelector('div');

console.log(elm.classList.<strong>contains</strong>('brown'));<em> //<span>logs true</span></em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<h2>3.12 Getting &amp; Setting data-* attributes</h2>
<p>The <em>dataset</em> property of a element node provides an object
 containing all of the attributes of an element that starts with data-*.
 Because its a simply a JavaScript object we can manipulate <em>dataset</em>
 and have the element in the DOM reflect those changes </p>

 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;div data-foo-foo="foo" data-bar-bar="bar"&gt;&lt;/div&gt;&#x200B;

&lt;script&gt;

var elm = document.querySelector('div');

<em>//get</em><em></em>
console.log(elm.<strong>dataset.fooFoo</strong>); <em>//logs 'foo'</em>
console.log(elm.<strong>dataset.barBar</strong>); <em>//logs 'bar'</em>

<em>//set</em>
<strong>elm.dataset.gooGoo = 'goo';</strong>
console.log(elm.dataset); <em>//logs DOMStringMap {fooFoo="foo", barBar="bar", gooGoo="goo"}</em>

<em>//what the element looks like in the DOM </em>
console.log(elm); <em>//logs &lt;div data-foo-foo="foo" data-bar-bar="bar" data-goo-goo="goo"&gt;</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
 <div class="notes">
 <h3>Notes</h3>
 <p><em>dataset</em> contains camel case versions of data attributes.
 Meaning <em>data-foo-foo</em> will be listed as the property <em>fooFoo</em>
 in the dataset <em>DOMStringMap</em> object. The<em>-</em> is replaced by camel casing.</p>
 <p>Removing a data-* attribute from the DOM is as simple
 using the <em>delete</em> operator on a property of the <em>datset</em>
 (e.g. <em>delete dataset.fooFoo</em>) </p>
 <p><em>dataset</em> is not supported in IE9. A <a href="https://github.com/remy/polyfills/blob/master/dataset.js">polyfill</a> is avaliable. However, you can always just use getAttribute('data-foo'), removeAttribute('data-foo'), setAttribute('data-foo'), hasAttribute('data-foo').</p>
 </div>
 
</div>




<div id="chapter4" class="chapter">

 <h2>Chapter 4 - Element Node Selecting</h2>
 <h2>4.1 Selecting a specific element node</h2>
 <p>The most common methods for getting a reference to a single element node
 are: </p>
 <ul>
 <li><em>querySelector() </em></li>
 <li><em>getElementById()</em> </li>
 </ul>
 <p>In the code below I leverage both of these methods to select an element
 node from the HTML document. </p>
 
 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;ul&gt;
&lt;li&gt;Hello&lt;/li&gt;
&lt;li&gt;big&lt;/li&gt;
&lt;li&gt;bad&lt;/li&gt;
&lt;li id="last"&gt;world&lt;/li&gt;
&lt;/ul&gt;

&lt;script&gt;

console.log(document.<strong>querySelector</strong>('li').textContent); <em>//logs Hello</em>
console.log(document.<strong>getElementById</strong>('last').textContent); <em>//logs world</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
 <p>The <em>getElementById()</em> method is pretty simple compared to the
 more robust <em>querySelector()</em> method. The <em>querySelector()</em>
 method permits a parameter in the form of a <a href="http://www.w3.org/TR/css3-selectors/#selectors">CSS
 selector syntax</a>. Basically you can pass this method a CSS 3
 selector (e.g. <em>'#score&gt;tbody&gt;tr&gt;td:nth-of-type(2)'</em>) which it will use to select a single element in the DOM.</p>
 <div class="notes">
 <h3>Notes</h3>
 <p><em>querySelector()</em> will return the first node element found in
 the document based on the selector. For example, in the code example
 above we pass a selector that would select all the li's in CSS, but only the first one is returned.</p>
 <p> <em>querySelector()</em> is also defined on element nodes. This
 allows for the method to limit (allows for context querying) its results to a specific vein of the DOM
 tree</p>
 </div>
 <h2>4.2 Selecting/creating a list (aka <em>NodeList</em>) of element nodes</h2>
 <p>The most common methods for selecting/creating a list of nodes in an HTML
 document are:</p>
 <ul>
 <li><em>querySelectorAll()</em></li>
 <li><em>getElementsByTagName()</em></li>
 <li><em>getElementsByClassName()</em></li>
 </ul>
 <p>Below we use all three of these methods to create a list of the <em>&lt;li&gt;</em>
 elements in the document.</p>
 
 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;ul&gt;
&lt;li class="liClass"&gt;Hello&lt;/li&gt;
&lt;li class="liClass"&gt;big&lt;/li&gt;
&lt;li class="liClass"&gt;bad&lt;/li&gt;
&lt;li class="liClass"&gt;world&lt;/li&gt;
&lt;/ul&gt;

&lt;script&gt;

<em>//all of the methods below create/select the same list of &lt;li&gt; elements from the DOM</em>
console.log(document.<strong>querySelectorAll</strong>('li'));
console.log(document.<strong>getElementsByTagName</strong>('li'));
console.log(document.<strong>getElementsByClassName</strong>('liClass'));

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
 <p>If its not clear the methods used in the code example above do not select
 a specific element, but instead creates a list (aka <a href="https://developer.mozilla.org/En/DOM/NodeList"><em>NodeLists</em></a>)
 of elements that you can select from.</p>
 <div class="notes">
 <h3>Notes</h3>
 <p><em>NodeLists</em> created from <em>getElementsByTagName()</em> and <em>getElementsByClassName()</em>
 are considered live are will always reflect the state of the document
 even if the document is updated after the list is created/selected.</p>
 <p> The <em>querySelectorAll()</em> method does not return a live list of
 elements. Meaning that the list created from <em>querySelectorAll()</em>
 is a snap shot of the document at the time it was created and is not
 reflective of the document as it changes. The list is static not live.</p>
 <p> <em>querySelectorAll()</em>, <em>getElementsByTagName()</em>, and <em>getElementsByClassName</em>
 are also defined on element nodes. This allows for the method to limit
 its results to specific vein(s) of the DOM tree (e.g. <em>document.getElementById('header').getElementsByClassName('a')</em>).</p>
 <p> I did not mention the <em>getElementsByName()</em> method as it not
 commonly leverage over other solutions but you should be aware of its
 existence for selecting form, img, frame, embed, and object elements
 from a document that all have the same name attribute value.</p>
 <p> Passing either <em>querySelectorAll()</em> or <em>getElementsByTagName()</em>
 the string <em>'*'</em>, which generally means all, will return a list
 of all elements in the document.</p>
 <p>Keep in mind that <em>childNodes</em> will also return a <em>NodeList</em> just like <em>querySelectorAll()</em>, <em>getElementsByTagName()</em>, and <em>getElementsByClassName</em></p>
 <p>The <em>NodeLists</em> are array like (but does not inherit array methods) lists/collections and have a
 read only <em>length</em> property</p>
 </div>
	<h2>4.3 Selecting all immediate child element nodes</h2>
 <p>Using the <em>children</em> property from an element node we can get a
 list (aka <a href="https://developer.mozilla.org/en/DOM/HTMLCollection"><em>HTMLCollection</em></a>)
 of all the immediate children nodes that are element nodes. In the code below I use <em>children</em> to create a selection/list of all of the <em>&lt;li&gt;</em>'s contained wiithin the <em>&lt;ul&gt;</em>.</p>
 
 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Hi&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;there&lt;/li&gt;
&lt;/ul&gt;

&lt;script&gt;

var ulElement = document.querySelector('ul').<strong>children</strong>;

<em>//logs a list/array of all immediate child element nodes</em>
console.log(ulElement); <em>//logs [&lt;li&gt;, &lt;li&gt;]</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
 <p>Notice that using <em>children</em> only gives us the immediate element
 nodes excluding any nodes (e.g. text nodes) that are not elements. If the element has no children then <em>children</em>
 will return an empty array-like-list.</p>
 <div class="notes">
 <h3>Notes</h3>
 <p><em>HTMLCollection</em>'s contain elements in document order, that is they are placed in the array in the order the elements appear in the DOM</p>
 <p><em>HTMLCollection</em>'s are live, which means any change to the document will be reflected dynamically in the collection</p>
 </div>
 <h2>4.4 Contextual element selecting</h2>
 <p>The methods <em>querySelector()</em>, <em>querySelectorAll()</em>, <em>getElementsByTagName()</em>, and <em>getElementsByClassName</em> typically accessed from the <em>document</em> object are also defined on element nodes. This allows for these methods to limit
 its results to specific vein(s) of the DOM tree. Or said another, you can select a specific context in which you would like the methods to search for element nodes by invoking these methods on element node objects.</p>
 
 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;div&gt;<br>&lt;ul&gt;<br>&lt;li&#xA0;class="liClass"&gt;Hello&lt;/li&gt;<br>&lt;li&#xA0;class="liClass"&gt;big&lt;/li&gt;<br>&lt;li&#xA0;class="liClass"&gt;bad&lt;/li&gt;<br>&lt;li&#xA0;class="liClass"&gt;world&lt;/li&gt;<br>&lt;/ul&gt;<br>&lt;/div&gt;

&lt;ul&gt;<br>&lt;li&#xA0;class="liClass"&gt;Hello&lt;/li&gt;<br>&lt;/ul&gt;

&lt;script&gt;

<em>//select a div as the context to run the selecting methods only on the contents of the div</em>
<strong>var&#xA0;div&#xA0;=&#xA0;document.querySelector('div');</strong>

console.log(<strong>div</strong>.querySelector('ul'));
console.log(<strong>div</strong>.querySelectorAll('li'));
console.log(<strong>div</strong>.getElementsByTagName('li'));
console.log(<strong>div</strong>.getElementsByClassName('liClass'));

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
 <p>These methods not only operate on the live dom but programatic DOM structures that are created in code as well.</p>
	
	
 
 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;script&gt;
<em>
//create DOM structure</em>
var divElm = document.createElement('div');
var ulElm = document.createElement('ul');
var liElm = document.createElement('li');
liElm.setAttribute('class','liClass');
ulElm.appendChild(liElm);
divElm.appendChild(ulElm);

<em>//use selecting methods on DOM structure</em>
console.log(<strong>divElm</strong>.querySelector('ul'));
console.log(<strong>divElm</strong>.querySelectorAll('li'));
console.log(<strong>divElm</strong>.getElementsByTagName('li'));
console.log(<strong>divElm</strong>.getElementsByClassName('liClass'));

&lt;/body&gt;
&lt;/html&gt;
</pre>
 <h2>4.5 Pre-configured selections/lists of element nodes</h2>
 <p>You should be aware that there are some legacy, pre-configured
 arrays-like-lists, containing element nodes from an HTML document. Below I
 list a couple of these (not the complete list) that might be handy to be
 aware of.</p>
 <ul>
 <li><em>document.all</em> - all elements in HTML document</li>
 <li><em>document.forms</em> - all <em>&lt;form&gt;</em> elements in HTML
 document</li>
 <li><em>document.images</em> - all <em>&lt;img&gt;</em> elements in HTML
 document</li>
 <li><em>document.links</em> - all <em>&lt;a&gt;</em> elements in HTML
 document </li>
 <li><em>document.scripts</em> - all <em>&lt;script&gt;</em> elements in HTML
 document </li>
 <li><em>document.styleSheets</em> - all <em>&lt;link&gt;</em> or <em>&lt;style&gt;</em> objects in HTML document</li>
 </ul>
 <div class="notes">
 <h3>Notes</h3>
 <p>These pre-configured arrays are constucted from the <a href="https://developer.mozilla.org/en/DOM/HTMLCollection">HTMLCollection</a>
 interface/object, except <em>document.styleSheets</em> it uses <em>StyleSheetList</em></p>
 <p><em><a href="https://developer.mozilla.org/en-US/docs/DOM/HTMLCollection">HTMLCollection</a></em>'s are live just like <em><a href="https://developer.mozilla.org/En/DOM/NodeList">NodeList</a></em>'s.
 </p>
 <p>Oddly <em>document.all</em> is constucted from a<em> HTMLAllCollection</em> not an <em>HTMLCollection</em> and is not supported in Firefox</p>
 </div>
 <h2>4.6 Verify an element will be selected using <em>matchesSelector()</em></h2>
 <p>Using the <em>matchesSelector()</em> method we can determine if an
 element will match a selector string. For example say we want to determine if
 an <em>&lt;li&gt;</em> is the first child element of a <em>&lt;ul&gt;</em>.
 In the code example below I select the first <em>&lt;li&gt;</em> inside of the <em>&lt;ul&gt;</em> and then ask if that element matches the selector, <em>li:first-child</em>. Because it in fact does, the <em>matchesSelector()</em> method returns <em>true</em>.</p>
 
 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;ul&gt;
&lt;li&gt;Hello&lt;/li&gt;
&lt;li&gt;world&lt;/li&gt;
&lt;/ul&gt;

&lt;script&gt;

<em>//fails in modern browser must use browser prefix moz, webkit, o, and ms</em>
console.log(document.querySelector('li').<strong>matchesSelector</strong>('li:first-child')); <em>//logs false

//prefix moz
//console.log(document.querySelector('li').<strong>mozMatchesSelector</strong>('li:first-child'));

//prefix webkit
//console.log(document.querySelector('li').<strong>webkitMatchesSelector</strong>('li:first-child'));

//prefix o
//console.log(document.querySelector('li').<strong>oMatchesSelector</strong>('li:first-child'));

//prefix ms
//console.log(document.querySelector('li').<strong>msMatchesSelector</strong>('li:first-child'));</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
 <div class="notes">
 <h3>Notes</h3>
 <p>matchesSelector has not seen much love from the browsers as its usage
 is behind browser prefixes <em>mozMatchesSelector()</em>, <em>webkitMatchesSelector()</em>,
 <em>oMatchesSelector()</em>, <em>msMatchesSelector()</em> </p>
 <p>In the future <em>matchesSelector()</em> will be renamed to <em>matches()</em></p>
 </div>
 

</div>




<div id="chapter5" class="chapter">

 <h2>Chapter 5 - Element Node Geometry &amp; Scrolling Geometry</h2>
 
	<h2>5.1 Element node size, offsets, and scrolling overview</h2>
	<p>DOM nodes are parsed and <a href="http://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#Painting">painted</a> into visual shapes when viewing html documents in a web browser. Nodes, mostly element nodes, have a corresponding visual representation made viewable/visual by browsers. To inspect and in some cases manipulate the visual representation and gemometry of nodes programatically a set of API's exists and are specified in the <a href="http://www.w3.org/TR/cssom-view/">CSSOM View Module</a>. A subset of methods and properties found in this specification provide an API to determine the geometry (i.e. size &amp; position using offset) of element nodes as well as hooks for manipulating scrollable nodes and getting values of scrolled nodes. This chapter breaks down these methods and properties.</p>
	<div class="notes">
 <h3>Notes</h3>
 <p>Most of the properties (excluding <em>scrollLeft</em> &amp; <em>scrollTop</em>) from the CSSOM View Module specification are read only and calculated each time they are accessed. In other words, the values are live</p>
 </div>
	<h2>5.2 Getting an elements <em>offsetTop</em> and <em>offsetLeft</em> values relative to the <em>offsetParent</em></h2>
 <p>Using the properties <em>offsetTop</em> and <em>offsetLeft</em> we can get the offset pixel value of an element node from the <em>offsetParent</em>. These element node properties give us the distance in pixels from an elements outside top and left border to the inside top and left border of the <em>offsetParent</em>. The value of the <em>offsetParent</em> is determined by searching the nearest ancestor elements for an element that has a CSS position value not equal to static. If none are found then the <em>&lt;body&gt;</em> element or what some refer to as the "document" (as opposed to the browser viewport) is the <em>offsetParent</em> value. If during the ancestral search a <em>&lt;td&gt;</em>, <em>&lt;th&gt;</em>, or <em>&lt;table&gt;</em> element with a CSS position value of static is found then this becomes the value of <em>offsetParent</em>.</p>
 <p>Lets verify that <em>offsetTop</em> and <em>offsetLeft</em> provide the values one might expect. The properties <em>offsetLeft</em> and <em>offsetTop</em> in the code below tell us that the <em>&lt;div&gt;</em> with an <em>id</em> of <em>red</em> is 60px's from the top and left of the <em>offsetParent</em> (i.e. the <em>&lt;body&gt;</em> element in this example).</p>
 
 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;style&gt;
body{margin:0;}
#blue{height:100px;width:100px;background-color:blue;border:10px&#xA0;solid&#xA0;gray;&#xA0;padding:25px;margin:25px;}<br>#red{height:50px;width:50px;background-color:red;border:10px&#xA0;solid&#xA0;gray;}
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div&#xA0;id="blue"&gt;&lt;div&#xA0;id="red"&gt;&lt;/div&gt;&lt;/div&gt;

&lt;script&gt;

var div = document.querySelector('#red');&#xA0;<p>console.log(div.<strong>offsetLeft</strong>); <em>//logs 60</em><br>console.log(div.<strong>offsetTop</strong>);<em>&#xA0;//logs 60</em>
console.log(div.<strong>offsetParent</strong>);<em>&#xA0;//logs &lt;body&gt;</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</p></pre>
 <p>Examine the following image showing what the code visually show in browser to help aid your understanding of how the <em>offsetLeft</em> and <em>offsetTop</em> values are deteremined. The red <em>&lt;div&gt;</em> shown in the image is exactly 60 pixels from the <em>offsetParent</em>.</p>
 <p><img src="http://domenlightenment.com/images/c4sec2.png"></p>
 <p>Notice I am measuring from the outside border of the red <em>&lt;div&gt;</em> element to the inside border of the <em>offsetParent</em> (i.e. <em>&lt;body&gt;</em>). </p>
 <p>As previously mentioned If I was to change the blue <em>&lt;div&gt;</em> in the above code to have a position of absolute this would alter the value of the <em>offsetParent</em>. In the code below, absolutely positioning the blue <em>&lt;div&gt;</em> will cause the values returned from <em>offsetLeft</em> and <em>offsetTop</em> to report an offset (i.e. 25px's). This is because the offset parent is now the blue <em>&lt;div&gt;</em> and not the <em>&lt;body&gt;</em> .</p>
 
 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;style&gt;
#blue{height:100px;width:100px;background-color:blue;border:10px&#xA0;solid&#xA0;gray;&#xA0;padding:25px;margin:25px;<strong>position:absolute;</strong>}
#red{height:50px;width:50px;background-color:red;border:10px&#xA0;solid&#xA0;gray;}
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div&#xA0;id="blue"&gt;&lt;div&#xA0;id="red"&gt;&lt;/div&gt;&lt;/div&gt;

&lt;script&gt;

var div = document.querySelector('#red');&#xA0;<p>console.log(div.<strong>offsetLeft</strong>); <em>//logs 25</em><br>console.log(div.<strong>offsetTop</strong>);<em>&#xA0;//logs 25</em>
console.log(div.<strong>offsetParent</strong>);<em>&#xA0;//logs &lt;div id="blue"&gt;</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</p></pre>
	<p>The image of the browser view shown below clarifies the new measurements returned from <em>offsetLeft</em> and <em>offsetTop</em> when the <em>offsetParent</em> is the blue <em>&lt;div&gt;</em>.</p>
 <p><img src="http://domenlightenment.com/images/c4sec2b.png"></p>
 <div class="notes">
 <h3>Notes</h3>
 <p>Many of the browsers break the outside border to inside border measurement when the <em>offsetParent</em> is the <em>&lt;body&gt;</em> and the <em>&lt;body&gt;</em> or <em>&lt;html&gt;</em> element has a visible margin, padding, or border value.</p>
 <p>The <em>offsetParent</em>, <em>offsetTop</em>, and <em>offsetLeft</em> are extensions to the <em>HTMLelement</em> object.</p>
 </div>
 <h2>5.3 Getting an elements top, right, bottom and left border edge offset relative to the viewport	using <em>getBoundingClientRect()</em></h2>
 <p>Using the <em>getBoundingClientRect()</em> method we can get the position of an elements outside border edges as its painted in the browser viewport relative to the top and left edge of the viewport. This means the left and right edge are measured from the outside border edge of an element to the left edge of the viewport. And the top and bottom edges are measured from the outside border edge of an element to the top edge of the viewport.</p>
 <p>In the code below I create a 50px X 50px <em>&lt;div&gt;</em> with a 10px border and 100px margin. To get the distance in pixels from each border edge of the <em>&lt;div&gt;</em> I call the<em> getBoundingClientRect()</em> method on the <em>&lt;div&gt;</em> which returns an object containing a <em>top</em>, <em>right</em>, <em>bottom</em>, and <em>left</em> property.</p>
 
 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;style&gt;
body{margin:0;}<br>div{height:50px;width:50px;background-color:red;border:10px solid gray;margin:100px;}<br>&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div&gt;&lt;/div&gt;

&lt;script&gt;

var divEdges = document.querySelector('div').<strong>getBoundingClientRect()</strong>;&#xA0;<p>console.log(divEdges.top, divEdges.right, divEdges.bottom, divEdges.left); <em>//logs '100 170 170 100'</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</p></pre>

	<p>The image below shows the browser rendered view of the above code with some added measurement indicators to show exactly how <em>getBoudingClientRect()</em> is calculated.</p>
	<p><img src="http://domenlightenment.com/images/c4sec3.png">
	</p>
 <p>The <em>top</em> outside border edge of the <em>&lt;div&gt;</em> element is 100px from the top edge of the viewport. The <em>right</em> outside border edge of the element <em>&lt;div&gt;</em> is 170px from the left edge of the viewport. The <em>bottom</em> outside border edge of the element <em>&lt;div&gt;</em> is 170px from the top edge of the viewport. And the <em>left</em> outside border edge of the element <em>&lt;div&gt;</em> is 100px from the left edge of the viewport.</p>
 <h2>5.4 Getting an elements size (border + padding + content) in the viewport</h2>
 <p>The <em>getBoundingClientRect()</em> returns an object with a top, right, bottom, and left property/value but also with a height and width property/value. The <em>height</em> and <em>width</em> properties indicate the size of the element where the total size is derived by adding the content of the div, its padding, and borders together.</p>
 <p>In the code below I get the size of the <em>&lt;div&gt;</em> element in the DOM using <em>getBoundingClientRect()</em>.</p>
 
 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;<br>&lt;style&gt;<br>div{height:25px;width:25px;background-color:red;border:25px solid gray;padding:25px;}<br>&lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<p>&lt;div&gt;&lt;/div&gt;</p><p>&lt;script&gt;</p><p>var div = document.querySelector('div').<strong>getBoundingClientRect()</strong>;&#xA0;
<br>console.log(div.<strong>height</strong>, div.<strong>width</strong>); <em>//logs '125 125'</em>
<em>//because 25px border + 25px padding + 25 content + 25 padding + 25 border = 125</em></p><p>&lt;/script&gt;<br>&lt;/body&gt;
&lt;/html&gt;</p></pre>
 <p>The exact same size values can also be found using from the <em>offsetHeight</em> and <em>offsetWidth </em>properties. In the code below I leverage these properties to get the same exact height and width values provided by <em>getBoundingClientRect()</em>.</p>
 
 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;<br>&lt;style&gt;<br>div{height:25px;width:25px;background-color:red;border:25px solid gray;padding:25px;}<br>&lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<p>&lt;div&gt;&lt;/div&gt;</p><p>&lt;script&gt;</p><p>var div = document.querySelector('div')<strong></strong>;&#xA0;
<br>console.log(div.<strong>offsetHeight</strong>, div.<strong>offsetWidth</strong>); <em>//logs '125 125'</em>
<em>//because 25px border + 25px padding + 25 content + 25 padding + 25 border = 125</em></p><p>&lt;/script&gt;<br>&lt;/body&gt;
&lt;/html&gt;</p></pre>
 <h2>5.5 Getting an elements size (padding + content) in the viewport excluding borders</h2>
 <p>The <em>clientWidth</em> and <em>clientHeight</em> properties return a total size of an element by adding together the content of the element and its padding excluding the border sizes. In the code below I use these two properties to get the height and width of an element including padding but excluding borders.</p>
 
 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;<br>&lt;style&gt;<br>div{height:25px;width:25px;background-color:red;border:25px solid gray;padding:25px;}<br>&lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<p>&lt;div&gt;&lt;/div&gt;</p><p>&lt;script&gt;</p><p>var div = document.querySelector('div')<strong></strong>;&#xA0;
<br>console.log(div.<strong>clientHeight</strong>, div.<strong>clientWidth</strong>); <em>//logs '75 75' because 25px padding + 25 content + 25 padding = 75</em></p><p>&lt;/script&gt;<br>&lt;/body&gt;
&lt;/html&gt;</p></pre>
	<h2>5.6 Getting topmost element in viewport at a specific point using <em>elementFromPoint()</em></h2>
	<p>Using <em>elementFromPoint()</em> it's possible to get a reference to the topmost element in an html document at a specific point in the document. In the code example below I simply ask what is the topmost element 50 pixels from the top and left of the viewport. Since we have two <em>&lt;div</em>&gt;'s at that location the topmost (or if there is no z-index set the last one in document order) div is selected and returned.</p>
 
	<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;<br>&lt;style&gt;<br>div{height:50px;width:50px;background-color:red;position:absolute;top:50px;left:50px;}<br>&lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<p>&lt;div&#xA0;id="bottom"&gt;&lt;/div&gt;&lt;div&#xA0;id="top"&gt;&lt;/div&gt;</p><p>&lt;script&gt;</p><p>console.log(document.<strong>elementFromPoint(50,50)</strong>);<em> //logs <a title="//*[@id='me']">&lt;div&#xA0;id="top"&gt;</a><a title="/html/body/div"></a></em></p><p>&lt;/script&gt;<br>&lt;/body&gt;
&lt;/html&gt;</p></pre>
	
	<h2>5.7 Getting the size of the element being scrolled using <em>scrollHeight</em> and <em>scrollWidth</em></h2>
	<p>The <em>scrollHeight</em> and <em>scrollWidth</em> properties simply give you the height and width of the node being scrolled. For example, open any HTML document that scrolls in a web browser and access these properties on the <em>&lt;html&gt;</em> (e.g.<em> document.documentElement.scrollWidth</em>) or <em>&lt;body&gt;</em> (e.g.<em> document.body.scrollWidth</em>) and you will get the total size of the HTML document being scrolled.	Since we can apply, using CSS (i.e overflow:scroll), to elements lets look at a simpler code example. In the code below I make a <em>&lt;div&gt;</em> scroll a <em>&lt;p&gt;</em> element that is 1000px's x 1000px's. Accessing the <em>scrollHeight</em> and <em>scrollWidth</em> properties on the <em>&lt;div&gt;</em> will tell us that the element being scroll is 1000px's x 1000px's.</p>
	
 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;<br>&lt;style&gt;
*{margin:0;padding:0;}<br>div{height:100px;width:100px; overflow:auto;}<br>p{height:1000px;width:1000px;background-color:red;}<br>&lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<p>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;</p><p>&lt;script&gt;</p><p>var div = document.querySelector('div');&#xA0;</p><p>console.log(div.<strong>scrollHeight</strong>, div.<strong>scrollWidth</strong>)<em>; //logs '1000 1000'</em></p><p>&lt;/script&gt;<br>&lt;/body&gt;
&lt;/html&gt;</p></pre>
<div class="notes">
 <h3>Notes</h3>
 <p>If you need to know the height and width of the node inside a scrollable area when the node is smaller than the viewport of the scrollable area don't use <em>scrollHeight</em> and <em>scrollWidth</em> as this will give you the size of the viewport. If the node being scrolled is smaller than the scroll area then use <em>clientHeight</em> and <em>clientWidth</em> to determine the size of the node contained in the scrollable area.</p>
 </div>

	<h2>5.8 Getting &amp; Setting pixels scrolled from the top and left using <em>scrollTop</em> and <em>scrollLeft</em></h2>
	<p>The <em>scrollTop</em> and <em>scrollLeft</em> properties are read-write properties that return the pixels to the left or top that are not currently viewable in the scrollable viewport due to scrolling. In the code below I setup a <em>&lt;div&gt;</em> that scrolls a <em>&lt;p&gt;</em> element.</p>
	
 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;<br>&lt;style&gt;<br>div{height:100px;width:100px;overflow:auto;}<br>p{height:1000px;width:1000px;background-color:red;}<br>&lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<p>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;</p><p>&lt;script&gt;</p><p>var div = document.querySelector('div');&#xA0;</p><p>div.scrollTop = 750;<br>div.scrollLeft = 750;</p><p>console.log(div.<strong>scrollTop</strong>,div.<strong>scrollLeft</strong>); <em>//logs '750 750'&#xA0;</em></p><p>&lt;/script&gt;<br>&lt;/body&gt;
&lt;/html&gt;</p></pre>
	<p>I programatically scroll the <em>&lt;div&gt;</em> by setting the <em>scrollTop</em> and <em>scrollLeft</em> to 750. Then I get the current value of <em>scrollTop</em> and <em>scrollLeft</em>, which of course since we just set the value to 750 will return a value of 750. The 750 reports the number of pixels scroll and indicates 750 px's to the left and top are not viewable in the viewport. If it helps just think of these properties as the pixel measurements of the content that is not shown in the viewport to the left or top.</p>
	<h2>5.9 Scrolling an element into view using <em>scrollIntoView()</em></h2>
	<p>By selecting a node contained inside a node that is scrollable we can tell the selected node to scroll into view using the <em>scrollIntoView()</em> method. In the code below I select the fifth <em>&lt;p&gt;</em> element contained in the scrolling <em>&lt;div&gt;</em> and call <em>scrollIntoView()</em> on it. </p>
	
 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;<br>&lt;style&gt;<br>div{height:30px;width:30px; overflow:auto;}<br>p{background-color:red;}<br>&lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<p>&lt;div&gt;<br>&lt;content&gt;<br>&lt;p&gt;1&lt;/p&gt;<br>&lt;p&gt;2&lt;/p&gt;<br>&lt;p&gt;3&lt;/p&gt;<br>&lt;p&gt;4&lt;/p&gt;<br>&lt;p&gt;5&lt;/p&gt;<br>&lt;p&gt;6&lt;/p&gt;<br>&lt;p&gt;7&lt;/p&gt;<br>&lt;p&gt;8&lt;/p&gt;<br>&lt;p&gt;9&lt;/p&gt;<br>&lt;p&gt;10&lt;/p&gt;&#xA0; &#xA0; &#xA0; &#xA0; &#xA0; &#xA0;&#xA0;<br>&lt;/content&gt;&#xA0; &#xA0; &#xA0; &#xA0;&#xA0;<br>&lt;/div&gt;</p><p>&lt;script&gt;<br>
<em>//select &lt;p&gt;5&lt;/p&gt; and scroll that element into view, I pass children '4' because its a zero index array-like structure</em><br>document.querySelector('content').children[4].<strong>scrollIntoView(true)</strong>;<br>&#xA0; &#xA0;&#xA0;<br>&lt;/script&gt;<br>&lt;/body&gt;
&lt;/html&gt;</p></pre>
	<p>By passing the <em>scrollIntoView()</em> method a parameter of <em>true</em> I am telling the method to scroll to the top of the element being scrolled too. The <em>true</em> parameter is however not needed as this is the default action performed by the method. If you want to scroll align to the bottom of the element pass a parameter of <em>false </em>to the <em>scrollIntoView()</em> method.</p>
	


</div>




<div id="chapter6" class="chapter">

 <h2>Chapter 6 - Element Node Inline Styles </h2>
 <h2>6.1 Style Attribute (aka element inline CSS properties) Overview</h2>
 <p>Every HTML element has a style attribute that can be used to inline CSS properties specific to the element. In the code below I am accessing the <em>style</em>
 attribute of a <em>&lt;div&gt;</em> that contains several inline CSS properties.</p>
 
 
 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;div style="background-color:red;border:1px solid black;height:100px;width:100px;"&gt;&lt;/div&gt;

&lt;script&gt;

var divStyle = document.querySelector('div').<strong>style</strong>; 

<em>//logs CSSStyleDeclaration {0="background-color", ...}</em>
console.log(divStyle);

&#xA0;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
 <p>Notice in the code above that what is returned from the <em>style</em> property is a <em>CSSStyleDeclaration</em>
 object and not a string. Additionally note that only the elements inline
 styles (i.e. excluding the computed styles, computed styles being any styles that have cascaded
 from style sheets) are included in the <em>CSSStyleDeclartion</em>
 object.</p>
 <h2>6.2 Getting, setting, &amp; removing individual inline CSS properties</h2>
 <p>Inline CSS styles are individually
 represented as a property (i.e. object property) of the <em>style</em> object avaliabe on element node objects. This provides the
 interface for us to get, set, or remove individual CSS properties on an element by simply setting an objects property value. In the
 code below we set, get, and remove styles on a <em>&lt;div&gt;</em> by manipulating the properties of the <em>style</em> object.</p>
 
 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;div&gt;&lt;/div&gt;

&lt;script&gt;

var divStyle = document.querySelector('div').<strong>style</strong>;

<em>//set</em>
divStyle.<strong>backgroundColor</strong> = 'red';
divStyle.<strong>border</strong> = '1px solid black';
divStyle.<strong>width</strong> = '100px';
divStyle.<strong>height</strong> = '100px';

<em>//get</em>
console.log(divStyle.<strong>backgroundColor</strong>);
console.log(divStyle.<strong>border</strong>);
console.log(divStyle.<strong>width</strong>);
console.log(divStyle.<strong>height</strong>);

<strong><em>/*remove
divStyle.backgroundColor = '';
divStyle.border = '';
divStyle.width = '';
divStyle.height = '';
*/</em></strong>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
 <div class="notes">
 <h3>Notes</h3>
 <p>The property names contained in the style object do not contain the
 normal hyphen that is used in CSS property names. The translation is
 pretty simple. Remove the hyphen and use camel case. (e.g. font-size = <em>fontSize</em>
 or background-image = <em>backgroundImage</em>). In the case where a
 css property name is a JavaScript keyword the javascript css property
 name is prefixed with "css" (e.g. float = <em>cssFloat</em>). </p>
 <p>Short hand properties are available as properties as well. So you can
 not only set <em>margin</em>, but also <em>marginTop</em>.</p>
 <p>Remember to include for any css property value that requires a unit of
 measure the appropriate unit&#xA0; (e.g. <em>style.width = '300px';</em>
 <em>not style.width = '300';</em>). When a document is rendered in
 standards mode the unit of measure is require or it will be ignored. In
 quirksmode assumptions are made if not unit of measure is included. </p>
 </div>
	 
 <table border="0" class="table table-bordered">
	<thead>
		<tr>
			<th>CSS Property</th>
			<th>JavaScript Property</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>background</td>
			<td>background</td>
		</tr>
		<tr>
			<td>background-attachment</td>
			<td>backgroundAttachment</td>
		</tr>
		<tr>
			<td>background-color</td>
			<td>backgroundColor</td>
		</tr>
		<tr>
			<td>background-image</td>
			<td>backgroundImage</td>
		</tr>
		<tr>
			<td>background-position</td>
			<td>backgroundPosition</td>
		</tr>
		<tr>
			<td>background-repeat</td>
			<td>backgroundRepeat</td>
		</tr>
		<tr>
			<td>border</td>
			<td>border</td>
		</tr>
		<tr>
			<td>border-bottom</td>
			<td>borderBottom</td>
		</tr>
		<tr>
			<td>border-bottom-color</td>
			<td>borderBottomColor</td>
		</tr>
		<tr>
			<td>border-bottom-style</td>
			<td>borderBottomStyle</td>
		</tr>
		<tr>
			<td>border-bottom-width</td>
			<td>borderBottomWidth</td>
		</tr>
		<tr>
			<td>border-color</td>
			<td>borderColor</td>
		</tr>
		<tr>
			<td>border-left</td>
			<td>borderLeft</td>
		</tr>
		<tr>
			<td>border-left-color</td>
			<td>borderLeftColor</td>
		</tr>
		<tr>
			<td>border-left-style</td>
			<td>borderLeftStyle</td>
		</tr>
		<tr>
			<td>border-left-width</td>
			<td>borderLeftWidth</td>
		</tr>
		<tr>
			<td>border-right</td>
			<td>borderRight</td>
		</tr>
		<tr>
			<td>border-right-color</td>
			<td>borderRightColor</td>
		</tr>
		<tr>
			<td>border-right-style</td>
			<td>borderRightStyle</td>
		</tr>
		<tr>
			<td>border-right-width</td>
			<td>borderRightWidth</td>
		</tr>
		<tr>
			<td>border-style</td>
			<td>borderStyle</td>
		</tr>
		<tr>
			<td>border-top</td>
			<td>borderTop</td>
		</tr>
		<tr>
			<td>border-top-color</td>
			<td>borderTopColor</td>
		</tr>
		<tr>
			<td>border-top-style</td>
			<td>borderTopStyle</td>
		</tr>
		<tr>
			<td>border-top-width</td>
			<td>borderTopWidth</td>
		</tr>
		<tr>
			<td>border-width</td>
			<td>borderWidth</td>
		</tr>
		<tr>
			<td>clear</td>
			<td>clear</td>
		</tr>
		<tr>
			<td>clip</td>
			<td>clip</td>
		</tr>
		<tr>
			<td>color</td>
			<td>color</td>
		</tr>
		<tr>
			<td>cursor</td>
			<td>cursor</td>
		</tr>
		<tr>
			<td>display</td>
			<td>display</td>
		</tr>
		<tr>
			<td>filter</td>
			<td>filter</td>
		</tr>
		<tr>
			<td>font</td>
			<td>font</td>
		</tr>
		<tr>
			<td>font-family</td>
			<td>fontFamily</td>
		</tr>
		<tr>
			<td>font-size</td>
			<td>fontSize</td>
		</tr>
		<tr>
			<td>font-variant</td>
			<td>fontVariant</td>
		</tr>
		<tr>
			<td>font-weight</td>
			<td>fontWeight</td>
		</tr>
		<tr>
			<td>height</td>
			<td>height</td>
		</tr>
		<tr>
			<td>left</td>
			<td>left</td>
		</tr>
		<tr>
			<td>letter-spacing</td>
			<td>letterSpacing</td>
		</tr>
		<tr>
			<td>line-height</td>
			<td>lineHeight</td>
		</tr>
		<tr>
			<td>list-style</td>
			<td>listStyle</td>
		</tr>
		<tr>
			<td>list-style-image</td>
			<td>listStyleImage</td>
		</tr>
		<tr>
			<td>list-style-position</td>
			<td>listStylePosition</td>
		</tr>
		<tr>
			<td>list-style-type</td>
			<td>listStyleType</td>
		</tr>
		<tr>
			<td>margin</td>
			<td>margin</td>
		</tr>
		<tr>
			<td>margin-bottom</td>
			<td>marginBottom</td>
		</tr>
		<tr>
			<td>margin-left</td>
			<td>marginLeft</td>
		</tr>
		<tr>
			<td>margin-right</td>
			<td>marginRight</td>
		</tr>
		<tr>
			<td>margin-top</td>
			<td>marginTop</td>
		</tr>
		<tr>
			<td>overflow</td>
			<td>overflow</td>
		</tr>
		<tr>
			<td>padding</td>
			<td>padding</td>
		</tr>
		<tr>
			<td>padding-bottom</td>
			<td>paddingBottom</td>
		</tr>
		<tr>
			<td>padding-left</td>
			<td>paddingLeft</td>
		</tr>
		<tr>
			<td>padding-right</td>
			<td>paddingRight</td>
		</tr>
		<tr>
			<td>padding-top</td>
			<td>paddingTop</td>
		</tr>
		<tr>
			<td>page-break-after</td>
			<td>pageBreakAfter</td>
		</tr>
		<tr>
			<td>page-break-before</td>
			<td>pageBreakBefore</td>
		</tr>
		<tr>
			<td>position</td>
			<td>position</td>
		</tr>
		<tr>
			<td>float</td>
			<td>styleFloat</td>
		</tr>
		<tr>
			<td>text-align</td>
			<td>textAlign</td>
		</tr>
		<tr>
			<td>text-decoration</td>
			<td>textDecoration</td>
		</tr>
		<tr>
			<td>text-decoration: blink</td>
			<td>textDecorationBlink</td>
		</tr>
		<tr>
			<td>text-decoration: line-through</td>
			<td>textDecorationLineThrough</td>
		</tr>
		<tr>
			<td>text-decoration: none</td>
			<td>textDecorationNone</td>
		</tr>
		<tr>
			<td>text-decoration: overline</td>
			<td>textDecorationOverline</td>
		</tr>
		<tr>
			<td>text-decoration: underline</td>
			<td>textDecorationUnderline</td>
		</tr>
		<tr>
			<td>text-indent</td>
			<td>textIndent</td>
		</tr>
		<tr>
			<td>text-transform</td>
			<td>textTransform</td>
		</tr>
		<tr>
			<td>top</td>
			<td>top</td>
		</tr>
		<tr>
			<td>vertical-align</td>
			<td>verticalAlign</td>
		</tr>
		<tr>
			<td>visibility</td>
			<td>visibility</td>
		</tr>
		<tr>
			<td>width</td>
			<td>width</td>
		</tr>
		<tr>
			<td>z-index</td>
			<td>zIndex</td>
		</tr>
	</tbody>
</table>
 <p>The style object is a <em>CSSStyleDeclaration</em> object and it provides not only access to inidividual CSS properties, but also the <em>setPropertyValue(propertyName)</em>, <em>getPropertyValue(propertyName,value)</em>,
 and <em>removeProperty()</em> methods used to manipulate individual CSS properties on a element node. In
 the code below we set, get, and remove individual CSS properties on a <em>&lt;div&gt;</em>
 using these methods.</p>
 
 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;style&gt;<meta charset="utf-8">
&lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;

&lt;div style="background-color:green;border:1px solid purple;"&gt;&lt;/div&gt;

&lt;script&gt;

var divStyle = document.querySelector('div').style;

<em>//set</em>
divStyle.<strong>setProperty</strong>('background-color','red');
divStyle.<strong>setProperty</strong>('border','1px solid black');
divStyle.<strong>setProperty</strong>('width','100px');
divStyle.<strong>setProperty</strong>('height','100px');

<em>//get</em>
console.log(divStyle.<strong>getPropertyValue</strong>('background-color'));
console.log(divStyle.<strong>getPropertyValue</strong>('border','1px solid black'));
console.log(divStyle.<strong>getPropertyValue</strong>('width','100px'));
console.log(divStyle.<strong>getPropertyValue</strong>('height','100px'));

<em>/*remove
divStyle.removeProperty('background-color');
divStyle.removeProperty('border');
divStyle.removeProperty('width');
divStyle.removeProperty('height');
*/</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
<div class="notes">
 <h3>Notes</h3>
 <p>Take notice that the property name is passed to the <em>setProperty()</em>
 and <em>getPropertyValue()</em> method using the css property name
 including a hyphen (e.g. <em>background-color</em> not <em>backgroundColor</em>).</p>
 <p>For more detailed information about the <em>setProperty()</em>, <em>getPropertyValue()</em>,
 and <em>removeProperty()</em> as well as additional properties and
 methods have a look the <a href="https://developer.mozilla.org/en/DOM/CSSStyleDeclaration">documentation</a>
 provided by Mozilla. </p>
 </div>
 <h2>6.3 Getting, setting, &amp; removing all inline CSS properties</h2>
 <p>Its possible using the <em>cssText</em> property of the <em>CSSStyleDeclaration</em> object as
 well as the <em>getAttribute()</em> and <em>setAttribute()</em> method
 to get, set, and remove the entire (i.e. all inline CSS properties) value of the style attribute using a
 JavaScript string. In the code below we get, set, and remove all 
 inline CSS (as opposed to individually changing CSS proeprties) on a <em>&lt;div&gt;</em>.</p>
 
 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;div&gt;&lt;/div&gt;

&lt;script&gt;

var div = document.querySelector('div');
var divStyle = div.style;

<em>//set using cssText</em>
divStyle.<strong>cssText</strong> = 'background-color:red;border:1px solid black;height:100px;width:100px;';
<em>//get using cssText</em>
console.log(divStyle.<strong>cssText</strong>);
<em>//remove</em>
divStyle.<strong>cssText</strong> = '';

<em>//exactly that same outcome using setAttribute() and getAttribute()</em>

<em>//set using setAttribute</em>
div.<strong>setAttribute</strong>('style','background-color:red;border:1px solid black;height:100px;width:100px;');
<em>//get using getAttribute</em>
console.log(div.<strong>getAttribute</strong>('style'));
<em>//remove</em>
div.<strong>removeAttribute</strong>('style');

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
 <div class="notes">
 <h3>Notes</h3>
 <p>If its not obvious you should note that replacing the <em>style</em>
 attribute value with a new string is the fastest way to make multiple
 changes to an elements style. </p>
 </div>

<h2>6.4 Getting an elements computed styles (i.e. actual styles including any from the cascade) using <em>getComputedStyle()</em></h2>
 <p>The <em>style</em> property only contains the css that is defined
 via the style attribute. To get an elements css from the cascade
 (i.e. cascading from inline style sheets, external style sheets, browser style sheets) as
 well as its inline styles you can use <em>getComputedStyle()</em>. This
 method provides a read-only <em>CSSStyleDeclaration</em> object similar to 
 <em>style</em>. In the code example below I demonstrate the
 reading of cascading styles, not just element inline styles.</p>
 
 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;style&gt;
&#x200B;div{
 background-color:red;
 border:1px solid black;
 height:100px;
 width:100px;
}
&lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;

&lt;div style="background-color:green;border:1px solid purple;"&gt;&lt;/div&gt;

&lt;script&gt;

var div = document.querySelector('div');

<em>//logs rgb(0, 128, 0) or green, this is an inline element style</em>
console.log(window.<strong>getComputedStyle</strong>(div).backgroundColor);

<em>//logs 1px solid rgb(128, 0, 128) or 1px solid purple, this is an inline element style</em>
console.log(window.<strong>getComputedStyle</strong>(div).border);

<em>//logs 100px, note this is not an inline element style</em>
console.log(window.<strong>getComputedStyle</strong>(div).height);

<em>//logs 100px, note this is not an inline element style</em>
console.log(window.<strong>getComputedStyle</strong>(div).width);

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
 <p>Make sure you note that <em>getComputedStyle()</em> method honors the <a href="http://css-tricks.com/specifics-on-css-specificity/">CSS specificity hierarchy</a>. For example in the code just shown the <em>backgroundColor</em> of the <em>&lt;div&gt;</em> is reported as green not red because inline styles are at the top of the specificity hierarchy thus its the inline <em>backgroundColor</em> value that is applied to the element by the browser and consider its final computed style.</p>
 <div class="notes">
 <h3>Notes</h3>
 <p>No values can by set on a <em>CSSStyleDeclaration</em> object returned
 from <em>getComputedStyles()</em> its read only.</p>
 <p>The <em>getComputedStyles()</em> method returns color values in the <em>rgb(#,#,#)</em>
 format regardless of how they were originally authored.</p>
 <p><a href="http://www.w3.org/TR/CSS21/about.html#shorthand">Shorthand</a> properties are not computed for the <em>CSSStyleDeclaration</em>
 object you will have to use
 non-shorthand property names for property access (e.g. marginTop not margin)<em>.
 </em></p>
 </div>
 <h2>6.5 Apply &amp; remove css properties on an element using <em>class</em> &amp; <em>id</em> attributes</h2>
 <p> Style rules defined in a inline style sheet or external style sheet can be
 added or removed from an element using the <em>class</em> and <em>id</em>
 attribute. This is a the most common pattern for manipulating element styles.
 In the code below, leveraging <em>setAttribute()</em> and <em>classList.add(),</em> inline style rules are applied to a <em>&lt;div&gt;</em> by setting
 the <em>class</em> and <em>id</em> attribute value. Using <em>removeAttribute()</em> and <em>classList.remove()</em> these CSS rules can be removed as well.</p>
 
 <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;style&gt;
.foo{<br>&#xA0;&#xA0;background-color:red;<br>&#xA0;&#xA0;padding:10px;<br>}<br>#bar{<br>&#xA0;&#xA0;border:10px&#xA0;solid&#xA0;#000;<br>&#xA0;&#xA0;margin:10px;<br>}
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div&gt;&lt;/div&gt;

&lt;script&gt;

var div = document.querySelector('div');

<em>//set</em>
div.<strong>setAttribute</strong>('id','bar');
div.<strong>classList</strong>.add('foo');

<em>/*remove
div.removeAttribute('id');
div.classList.remove('foo');
*/</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>


</div>




<div id="chapter7" class="chapter">


<h2>Chapter 7 - Text Nodes </h2>
<h2>7.1 <em>Text</em> object overview</h2>
<p>Text in an HTML document is represented by instances of the <em>Text()</em> constructor function, which produces text nodes. When an HTML document is
	parsed the text mixed in among the elements of an HTML page are converted
	to text nodes.</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;p&gt;hi&lt;/p&gt;

&lt;script&gt;
<em>
//select 'hi' text node</em>
var textHi = document.querySelector('p').firstChild

console.log(textHi.constructor); <em>//logs Text()</em>

<em>//logs Text {textContent="hi", length=2, wholeText="hi", ...}</em>
console.log(textHi);

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>The code above concludes that the <em>Text()</em> constructor function
	constructs the text node but keep in mind that <em><span>Text</span></em> inherits from <em>CharacterData</em>,<em> Node</em>,
and <em>Object</em>.</p>
<h2>7.2 <em>Text</em> object &amp; properties</h2>
<p>To get accurate information pertaining to the available properties and
	methods on an <em>Text</em> node its best to ignore the
	specification and to ask the browser what is available. Examine the arrays
	created in the code below detailing the properties and methods available
	from a text node.</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;p&gt;hi&lt;/p&gt;

&lt;script&gt;
var text = document.querySelector('p').firstChild;

<em>//text own properties</em>
console.log(Object.keys(text).sort());

<em>//text own properties &amp; inherited properties</em>
var textPropertiesIncludeInherited = [];
for(var p in text){
	textPropertiesIncludeInherited.push(p);
}
console.log(textPropertiesIncludeInherited.sort());

<em>//text inherited properties only</em>
var textPropertiesOnlyInherited = [];
for(var p in text){
	if(!text.hasOwnProperty(p)){
		textPropertiesOnlyInherited.push(p);
	}
}
console.log(textPropertiesOnlyInherited.sort());

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>The available properties are many even if the inherited properties were not
	considered. Below I've hand pick a list of note worthy properties and
	methods for the context of this chapter.&#xA0;</p>
<ul>
	<li><em>textContent</em></li>
	<li><em>splitText()</em></li>
	<li><em>appendData()</em></li>
	<li><em>deleteData()</em></li>
	<li><em>insertData()</em></li>
	<li><em>replaceData()</em></li>
	<li><em>subStringData()</em></li>
	<li><em>normalize()</em></li>
	<li><em>data</em></li>
	
	<li><em>document.createTextNode()</em> (not a property or inherited property of text nodes but discussed in this chapter)</li>
</ul>
<h2>7.3 White space creates <em>Text</em> nodes</h2>
<p>When a DOM is contstructed either by the browser or by programmatic means text nodes are created from white space as well as from text characters. After all, whitespace is a character. In the code below the second paragraph, conaining an empty space, has a child <em>Text</em> node while the first paragraph does not.</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;p id="p1"&gt;&lt;/p&gt;
<strong>&lt;p id="p2"&gt; &lt;/p&gt;</strong>

&lt;script&gt;

console.log(document.querySelector('#p1').firstChild) <em>//logs null</em>
console.log(document.querySelector('#p2').firstChild.nodeName) <em>//logs #text</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>Don't forget that white space and text characters in the DOM are typically represented by a text node. This of course means that carriage returns are considered text nodes. In the code below we log a carriage return highlighting the fact that this type of character is in fact a text node.</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

<strong>&lt;p id="p1"&gt;&lt;/p&gt;</strong> <em>//yes there is a carriage return text node before this comment, even this comment is a node</em>
&lt;p id="p2"&gt;&lt;/p&gt;

&lt;script&gt;

console.log(document.querySelector('#p1').nextSibling) <em>//logs Text</em><em></em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>The reality is if you can input the character or whitespace into an html document using a keyboard then it can potentially be interputed as a text node. If you think about it, unless you minimze/compress the html document the average html page contains a great deal of whitespace and carriage return text nodes.</p>

<h2>7.4 Creating &amp; Injecting <em>Text</em> Nodes</h2>
<p><em>Text</em> nodes are created automatically for us when a browser interputs an HTML document and a corresponding DOM is built based on the contents of the document. After this fact, its also possible to programatically create <em>Text</em> nodes using <em>createTextNode()</em>. In the code below I create a text node and then inject that node into the live DOM tree.</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;div&gt;&lt;/div&gt;

&lt;script&gt;

var textNode = document.<strong>createTextNode('Hi')</strong>;
document.querySelector('div').appendChild(textNode);

console.log(document.querySelector('div').innerText); <em>// logs Hi</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>Keep in mind that we can also inject text nodes into programmatically created DOM structures as well. In the code below I place a text node inside of an <em>&lt;p&gt;</em> element before I inject it into the live DOM.</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;div&gt;&lt;/div&gt;

&lt;body&gt;

&lt;script&gt;

var elementNode = document.createElement('p');
var textNode = document.createTextNode('Hi');
<strong>elementNode.appendChild(textNode);</strong>
document.querySelector('div').appendChild(elementNode);

console.log(document.querySelector('div').innerHTML); <em>//logs &lt;div&gt;Hi&lt;/div&gt;</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

<h2>7.5 Getting a <em>Text</em> node value with <em>.data</em> or <em>nodeValue</em></h2>
<p>The text value/data represented by a <em>Text</em> node can be extracted from the node by using the <em>.data</em> or <em>nodeValue</em> property. Both of these return the text contained in a <em>Text</em> node. Below I demostrate both of these to retrive the value contained in the <em>&lt;div&gt;</em>.</p>


<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;p&gt;Hi, &lt;strong&gt;cody&lt;/strong&gt;&lt;/p&gt;&lt;body&gt;

&lt;script&gt;

console.log(document.querySelector('p').firstChild<strong>.data</strong>); <em>//logs 'Hi,'</em>
console.log(document.querySelector('p').firstChild<strong>.nodeValue</strong>); <em>//logs 'Hi,</em>'

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

<p>Notice that the <em>&lt;p&gt;</em> contains two <em>Text</em> node and <em>Element</em> (i.e. <em>&lt;strong&gt;</em>)node. And that we are only getting the value of the first child node contained in the <em>&lt;p&gt;</em>.</p>

<div class="notes">
 <h3>Notes</h3>
 <p>Getting the length of the characters contained in a text node is as simple as accessing the length proerty of the node itself or the actual text value/data of the node (i.e. <em>document.querySelector('p').firstChild.length</em> or <em>document.querySelector('p').firstChild.data.length</em> or <em>document.querySelector('p').firstChild.nodeValue.length</em>)</p>
</div>

<h2>7.6 Maniputlating <em>Text</em> nodes with <em>appendData()</em>, <em>deleteData()</em>, <em>insertData()</em>, <em>replaceData()</em>, <em>subStringData()</em></h2>
<p>The <em>CharacterData</em> object that <em>Text</em> nodes inherits methods from provides the following methods for manipulating and extracting sub values from <em>Text</em> node values.</p>
<ul>
	<li><em>appendData()</em></li>
	<li><em>deleteData()</em></li>
	<li><em>insertData()</em></li>
	<li><em>replaceData()</em></li>
	<li><em>subStringData()</em></li>
</ul>
<p>Each of these are leverage in the code example below.</p>


<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;p&gt;Go big Blue Blue&lt;body&gt;

&lt;script&gt;

var pElementText = document.querySelector('p').firstChild;<p><em>//add !</em><br>pElementText.<strong>appendData('!')</strong>;<br>console.log(pElementText.data);</p><p><em>//remove first 'Blue'</em><br>pElementText.<strong>deleteData(7,5)</strong>;<br>console.log(pElementText.data);</p><p><em>//insert it back 'Blue'</em><br>pElementText.<strong>insertData(7,'Blue ')</strong>;<br>console.log(pElementText.data);</p><p><em>//replace first 'Blue' with 'Bunny'</em><br>pElementText.<strong>replaceData(7,5,'Bunny ')</strong>;<br>console.log(pElementText.data);</p><p><em>//extract substring 'Blue Bunny'</em><br>console.log(pElementText.<strong>substringData(7,10)</strong>);

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</p></pre>
<div class="notes">
 <h3>Notes</h3>
 <p>These same manipulation and sub extraction methods can be leverage by <em>Comment</em> nodes</p>
</div>
<h2>7.7 When mulitple sibling <em>Text</em> nodes occur</h2>
<p>Typically, immediate sibling <em>Text</em> nodes do not occur because DOM trees created by browsers intelligently combines text nodes, however two cases exist that make sibling text nodes possible. The first case is rather obvious. If a text node contains an <em>Element</em> node (e.g. <em>&lt;p&gt;Hi, &lt;strong&gt;cody&lt;/strong&gt; welcome!&lt;/p&gt;</em>) than the text will be split into the proper node groupings. Its best to look at a code example as this might sound more complicted than it really is. In the code below the contents of the <em>&lt;p&gt;</em> element is not a single <em>Text</em> node it is in fact 3 nodes, a <em>Text</em> node, <em>Element</em> node, and another <em>Text</em> node.</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;p&gt;Hi, &lt;strong&gt;cody&lt;/strong&gt; welcome!&lt;/p&gt;

&lt;script&gt;

var pElement = document.querySelector('p');

console.log(pElement.childNodes.length); <em>//logs 3</em>

console.log(pElement.firstChild.data); <em>// is text node or 'Hi, '</em>
console.log(pElement.firstChild.nextSibling); <em>// is Element node or &lt;strong&gt;</em>
console.log(pElement.lastChild.data);&#xA0;&#x200B;<em>// is text node or ' welcome!'</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>The next case occurs when we are programatically add <em>Text</em> nodes to an element we created in our code. In the code below I create a <em>&lt;p&gt;</em> element and then append two <em>Text</em> nodes to this element. Which results in sibling <em>Text</em> nodes.</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;script&gt;

var&#xA0;pElementNode&#xA0;=&#xA0;document.createElement('p');<br>var&#xA0;textNodeHi&#xA0;=&#xA0;document.createTextNode('Hi ');<br>var&#xA0;textNodeCody&#xA0;=&#xA0;document.createTextNode('Cody');<p>pElementNode.appendChild(textNodeHi);<br>pElementNode.appendChild(textNodeCody);</p><p>document.querySelector('div').appendChild(pElementNode);</p><p>console.log(document.querySelector('div p').childNodes.length);&#xA0;<em>//logs 2&#x200B;</em>&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</p></pre>
<h2>7.8 Remove markup and return all child <em>Text</em> nodes using <em>textContent</em></h2>
<p>The <em>textContent</em> property can be used to get all child text nodes, as well as to set the contents of a node to a specific <em>Text</em> node. When its used on a node to get the textual content of the node it will returned a concatenataed string of all text nodes contained with the node you call the method on. This functionality would make it very easy to extract all text nodes from an HTML document. Below I extract all of the text contained withing the <em>&lt;body&gt;</em> element. Notice that <em>textContent</em> gathers not just immediate child text nodes but all child text nodes no matter the depth of encapsulation inside of the node the method is called.</p>
<p class="codeLink">live code: N/A</p>
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;
&lt;h1&gt; Dude&lt;/h2&gt;
&lt;p&gt;you &lt;strong&gt;rock!&lt;/strong&gt;&lt;/p&gt;
&lt;script&gt;

console.log(document.body.<strong>textContent</strong>);&#xA0;<em>//logs 'Dude you rock!' with some added white space

</em>&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>When <em>textContent</em> is used to set the text contained within a node it will remove all child nodes first, replacing them with a single <em>Text</em> node. In the code below I replace all the nodes inside of the <em>&lt;div&gt;</em> element with a single <em>Text</em> node.</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;
&lt;div&gt;
&lt;h1&gt; Dude&lt;/h2&gt;
&lt;p&gt;you &lt;strong&gt;rock!&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;script&gt;

document.body.<strong>textContent = 'You don\'t rock!'</strong>
console.log(document.querySelector('div').textContent<strong><em></em></strong>);&#xA0;<em>//logs 'You don't rock!'

</em>&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<div class="notes">
 <h3>Notes</h3>
 <p><em>textContent</em> returns <em>null</em> if used on the a document or doctype node.</p>
 <p><em>textContent</em> returns the contents from <em>&lt;script&gt;</em> and <em>&lt;style&gt;</em> elements</p>
</div>
<h2>7.9 The difference between <em>textContent</em> &amp; <em>innerText</em></h2>
<p>Most of the modern bowser, except Firefox, support a seeminly similiar property to <em>textContent</em> named <em>innerText</em>. However these properties are not the same. You should be aware of the following differences between <em>textContent</em> &amp; <em>innerText</em>.</p>
<ul>
	<li><em>innerText</em> is aware of CSS. So if you have hidden text <em>innerText</em> ignores this text, whereas <em>textContent</em> will not</li>
	<li>Because <em>innerText</em> cares about CSS it will trigger a reflow, whereas <em>textContent</em> will not</li>
	<li><em>innerText</em> ignores the <em>Text</em> nodes contained in <em>&lt;script&gt;</em> and <em>&lt;style&gt;</em> elements</li>
	<li><em>innerText</em>, unlike <em>textContent</em> will normalize the text that is returned. Just think of <em>textContent</em> as returning exactly what is in the document with the markup removed. This will include white space, line breaks, and carriage returns</li>
	<li><em>innerText</em> is considered to be non-standard and browser specific while <em>textContent</em> is implemented from the DOM specifications</li>
</ul>
<p>If you you intend to use <em>innerText</em> you'll have to create a work around for Firefox.</p>
<h2>7.10 Combine sibling <em>Text</em> nodes into one text node using <em>normalize()</em></h2>
<p>Sibling <em>Text</em> nodes are typically only encountered when text is programaticly added to the DOM. To eliminate sibling <em>Text</em> nodes that contain no <em>Element</em> nodes we can use <em>normalize()</em>. This will concatenate sibling text nodes in the DOM into a single <em>Text</em> node. In the code below I create sibling text, append it to the DOM, then normalize it.</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;
&lt;div&gt;&lt;/div&gt;
&lt;script&gt;

var&#xA0;pElementNode&#xA0;=&#xA0;document.createElement('p');
var&#xA0;textNodeHi&#xA0;=&#xA0;document.createTextNode('Hi');
var&#xA0;textNodeCody&#xA0;=&#xA0;document.createTextNode('Cody');

pElementNode.appendChild(textNodeHi);
pElementNode.appendChild(textNodeCody);

document.querySelector('div').appendChild(pElementNode);

console.log(document.querySelector('p').childNodes.length);&#xA0;<em>//logs 2</em>

document.querySelector('div').<strong>normalize()</strong>; <em>//combine our sibling text nodes</em>

console.log(document.querySelector('p').childNodes.length);&#xA0;<em>//logs 1</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<h2>7.11 Splitting a text node using <em>splitText()</em></h2>
<p> When <em>splitText()</em> is called on a <em>Text</em> node it will alter the text node its being called on (leaving the text up to the offset) and return a new <em>Text</em> node that contains the text split off from the orginal text based on the offset. In the code below the text node <em>Hey Yo!</em> is split after <em>Hey</em> and <em>Hey</em> is left in the DOM while <em>Yo!</em> is turned into a new text node are returned by the <em>splitText()</em> method.</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;p&gt;Hey Yo!&lt;/p&gt;

&lt;script&gt;

<em>//returns a new text node, taken from the DOM</em>
console.log(document.querySelector('p').firstChild.<strong>splitText(4)</strong>.data); <em>//logs Yo!</em>

<em>//What remains in the DOM...</em><br>console.log(document.querySelector('p').firstChild.textContent); <em>//logs Hey</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

</div>




<div id="chapter8" class="chapter">


<h2>Chapter 8 - DocumentFragment Nodes</h2>
<h2>8.1 <em>DocumentFragment</em> object overview</h2>
<p>The creation and use of a <em>DocumentFragment</em> node provides a light weight document DOM that is external to the live DOM tree. Think of a <em>DocumentFragment</em> as an empty document template that acts just like the live DOM tree, but only lives in memory, and its child nodes can easily be manipulated in memory and then appended to the live DOM.</p>

<h2>8.2 Creating <em>DocumentFragment</em>'s using <em>createDocumentFragment()</em></h2>
<p> In the code below a <em>DocumentFragment</em> is created using <em>createDocumentFragment()</em> and <em>&lt;li&gt;</em>'s are appended to the fragment.</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;script&gt;
<br>var&#xA0;docFrag&#xA0;=&#xA0;document.<strong>createDocumentFragment()</strong>;<p>["blue",&#xA0;"green",&#xA0;"red",&#xA0;"blue",&#xA0;"pink"].forEach(function(e)&#xA0;{<br>&#xA0; &#xA0;&#xA0;var&#xA0;li&#xA0;=&#xA0;document.createElement("li");<br>&#xA0; &#xA0;&#xA0;li.textContent&#xA0;=&#xA0;e;<br>&#xA0; &#xA0;&#xA0;docFrag.appendChild(li);<br>});</p><p>console.log(docFrag.textContent); <em>//logs bluegreenredbluepink</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</p></pre>
<p>Using a <em>documentFragment</em> to create node structures in memory is extrememly efficent when it comes time to inject the <em>documentFragment</em> into live node structures.</p>
<p>You might wonder what is the advantage to using a <em>documentFragment</em> over simply creating (via <em>createElement()</em>) a <em>&lt;div&gt;</em> in memory and working within this <em>&lt;div&gt;</em> to create a DOM structure. The follow are the differences.</p>
<ul>
	<li>A document fragment may contain any kind of node (except <em>&lt;body</em>&gt; or <em>&lt;html&gt;</em>) where as an element may not</li>
	<li>The document fragment itself, is not added to the DOM when you append a fragment. The contents of the node are. As opposed to appending an element node in which the element itself is part of the appending.</li>
	<li>When a document fragment is appended to the DOM it transfers from the document fragment to the place its appended. Its no longer in memory in the place you created it. This is not true for element nodes that are temperately used to contained nodes briefly and then are moved to the live DOM.</li>
</ul>

<h2>8.3 Adding a <em>DocumentFragment</em> to the live DOM</h2>
<p>By passing the <em>appendChild()</em> and <em>insertBefore()</em> node methods a <em>documentFragment</em> argument the child nodes of the <em>documentFragment</em> are transported as children nodes to the DOM node the methods are called on. Below we create a <em>documentfragment</em>, add some <em>&lt;li&gt;</em>'s to it, then append these new element nodes to the live DOM tree using <em>appendChild()</em>.</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;ul&gt;&lt;/ul&gt;

&lt;script&gt;

var ulElm = document.queryselector('ul');<br>var&#xA0;docFrag&#xA0;=&#xA0;document.createDocumentFragment();<p>["blue",&#xA0;"green",&#xA0;"red",&#xA0;"blue",&#xA0;"pink"].forEach(function(e)&#xA0;{<br>&#xA0; &#xA0;&#xA0;var&#xA0;li&#xA0;=&#xA0;document.createElement("li");<br>&#xA0; &#xA0;&#xA0;li.textContent&#xA0;=&#xA0;e;<br>&#xA0; &#xA0;&#xA0;docFrag.appendChild(li);<br>});<br>
ulElm.<strong>appendChild(docFrag)</strong>;

<em>//logs &lt;ul&gt;&lt;li&gt;blue&lt;/li&gt;&lt;li&gt;green&lt;/li&gt;&lt;li&gt;red&lt;/li&gt;&lt;li&gt;blue&lt;/li&gt;&lt;li&gt;pink&lt;/li&gt;&lt;/ul&gt;</em><br>console.log(document.body.innerHTML);

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</p></pre>
<div class="notes">
 <h3>Notes</h3>
 <p>Document fragments passed as arguments to inserting node methods will insert the entire child node structure ignoring the documentFragment node itself. </p>
</div>

<h2>8.4 Using <em>innerHTML</em> on a <em>documentFragment</em></h2>
<p>Creating a DOM structure in memory using node methods can be verbose and laboring. One way around this would be to created a <em>documentFragment</em>, append a <em>&lt;div&gt;</em> to this fragment because <em>innerHTML</em> does not work on document fragments, and then use the <em>innerHTML</em> property to update the fragment with a string of HTML. By doing this a DOM structure is crafted from the HTML string. In the code below I construct a DOM structure that I can then treat as a tree of nodes and not just a JavaScript string.</p>


<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;script&gt;

<em>//create a &lt;div&gt; and document fragment</em>
var divElm = document.createElement('div');<br>var&#xA0;docFrag&#xA0;=&#xA0;document.createDocumentFragment();<br>
<em>//append div to document fragment</em><br>docFrag.appendChild(divElm);

<em>//create a DOM structure from a string</em>
docFrag.querySelector('div').<strong>innerHTML</strong> = '&lt;ul&gt;&lt;li&gt;foo&lt;/li&gt;&lt;li&gt;bar&lt;/li&gt;&lt;/ul&gt;';<br>
<em>//the string becomes a DOM structure I can call methods on like querySelectorAll()</em>
<em>//Just don't forget the DOM structure is wrapped in a &lt;div&gt;</em>
console.log(docFrag.querySelectorAll('li').length); <em>//logs 2</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>When it comes time to append a DOM structure created using a <em>documentFragment</em> and <em>&lt;div&gt;</em> you'll want to append the structure skipping the injection of the <em>&lt;div&gt;</em>.</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;div&gt;&lt;/div&gt;

&lt;script&gt;

<em>//create a &lt;div&gt; and document fragment</em>
var divElm = document.createElement('div');<br>var&#xA0;docFrag&#xA0;=&#xA0;document.createDocumentFragment();<br>
<em>//append div to document fragment</em><br>docFrag.appendChild(divElm);

<em>//create a DOM structure from a string</em>
docFrag.querySelector('div').innerHTML = '&lt;ul&gt;&lt;li&gt;foo&lt;/li&gt;&lt;li&gt;bar&lt;/li&gt;&lt;/ul&gt;';<br>
<em>//append, starting with the first child node contained inside of the &lt;div&gt;</em>
document.querySelector('div').appendChild(<strong>docFrag.querySelector('div').firstChild</strong>);

<em>//logs &lt;ul&gt;&lt;li&gt;foo&lt;/li&gt;&lt;li&gt;bar&lt;/li&gt;&lt;/ul&gt;</em>
console.log(document.querySelector('div').innerHTML);

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

<div class="notes">
 <h3>Notes</h3>
 <p>In addtion to <em>DocumentFragment</em> we also have <em><a href="http://html5.org/specs/dom-parsing.html#domparser">DOMParser</a></em> to look forward too. <em>DOMParser</em>&#xA0;can parse HTML stored in a string into a DOM&#xA0;<a href="https://developer.mozilla.org/en/DOM/document" title="document">Document</a>. It's only supported in Opera &amp; Firefox as of today, but a <a href="https://gist.github.com/1129031">polyfill</a> is avaliable. Of course, if you need a stand alone HTML to DOM script try <a href="https://github.com/component/domify">domify</a>.</p>
</div>

<h2>8.5 Leaving a fragments containing nodes in memory by cloning</h2>
<p>When appending a <em>documentFragment</em> the nodes contained in the Fragment are moved from the Fragment to the structure you are appending too. To leave the contents of a fragment in memory, so the nodes remain after appending, simply clone using <em>cloneNode()</em> the <em>documentFragment</em> when appending. In the code below instead of tranporting the <em>&lt;li&gt;</em>'s from the document fragment I clone the <br>
<em>&lt;li&gt;</em>'s, which keeps the <em>&lt;li&gt;</em>'s being clonded in memory inside of the <em>documentFragment</em> node.</p>


<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;ul&gt;&lt;/ul&gt;

&lt;script&gt;
<em>
//create ul element and document fragment</em>
var ulElm = document.querySelector('ul');<br>var&#xA0;docFrag&#xA0;=&#xA0;document.createDocumentFragment();<br>
<em>//append li's to document fragment</em><br>["blue",&#xA0;"green",&#xA0;"red",&#xA0;"blue",&#xA0;"pink"].forEach(function(e)&#xA0;{<br>&#xA0; &#xA0;&#xA0;var&#xA0;li&#xA0;=&#xA0;document.createElement("li");<br>&#xA0; &#xA0;&#xA0;li.textContent&#xA0;=&#xA0;e;<br>&#xA0; &#xA0;&#xA0;docFrag.appendChild(li);<br>});<br>
<em>//append cloned document fragment to ul in live DOM</em>
ulElm.appendChild(docFrag<strong>.cloneNode(true)</strong>);

<em>//logs &lt;li&gt;blue&lt;/li&gt;&lt;li&gt;green&lt;/li&gt;&lt;li&gt;red&lt;/li&gt;&lt;li&gt;blue&lt;/li&gt;&lt;li&gt;pink&lt;/li&gt;</em><br>console.log(document.querySelector('ul').innerHTML);

<em>//logs <span>[</span><a title="/li">li</a><span>,</span><a title="/li[2]">li</a><span>,</span><a title="/li[3]">li</a><span>,</span><a title="/li[4]">li</a><span>,</span><a title="/li[5]">li</a><span>]</span></em> 
console.log(<strong>docFrag.childNodes</strong>);

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

</div>




<div id="chapter9" class="chapter">


 <h2>Chapter 9 - CSS Style Sheets &amp; CSS rules</h2>
 <h2>9.1 CSS Style sheet overview</h2>
 <p>A style sheet is added to an HTML document by either using the <em>HTMLLinkElement</em> node (i.e. <em>&lt;link href="stylesheet.css" rel="stylesheet" type="text/css"&gt;</em>) to include an external style sheet or the <em>HTMLStyleElement</em> node (i.e. <em>&lt;style&gt;&lt;/style&gt;</em>) to define a style sheet inline. In the HTML document below both of these <em>Element</em> node's are in the DOM and I verify which constructor, constructs these nodes.</p>
 
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;

&lt;link id="linkElement" href="http://yui.yahooapis.com/3.3.0/build/cssreset/reset-min.css" rel="stylesheet" type="text/css"&gt;

&lt;style id="styleElement"&gt;
body{background-color:#fff;}
&lt;/style&gt;

&lt;/head&gt;
&lt;body&gt;

&lt;script&gt;

<em>//logs function HTMLLinkElement() { [native code] }</em>
console.log(<strong>document.querySelector('#linkElement').constructor</strong>);

<em>//logs function HTMLStyleElement() { [native code] }</em>
console.log(<strong>document.querySelector('#styleElement').constructor</strong>);

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
 <p>Once a style sheet is added to an HTML document its represented by the <em>CSSStylesheet</em> object. Each CSS rule (e.g. <em>body{background-color:red;}</em>) inside of a style sheet is represent by a <em>CSSStyleRule</em> object. In the code below I verify which constructor constructed the style sheet and each CSS rule (selector &amp; its css properties and values) in the style sheet.</p>
 
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;

&lt;style id="styleElement"&gt;
body{background-color:#fff;}
&lt;/style&gt;

&lt;/head&gt;
&lt;body&gt;

&lt;script&gt;

<em>//logs function CSSStyleSheet() { [native code] } because this object is the stylesheet itself</em>
console.log(<strong>document.querySelector('#styleElement').sheet.constructor</strong>);

<em>//logs function CSSStyleRule() { [native code] } because this object is the rule inside of the style sheet</em>
console.log(<strong>document.querySelector('#styleElement').sheet.cssRules[0].constructor</strong>);<em></em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
 <p>Keep in mind that selecting the element that includes the style sheet (i.e. <em>&lt;link&gt;</em> or <em>&lt;style</em>&gt;) is not the same as accessing the actual object (<em>CSSStyleSheet</em>) that represents the style sheet itself.</p>
 <h2>9.2 Accessing all style sheets (i.e. <em>CSSStylesheet</em> objects) in the DOM</h2>
	<p><em>document.styleSheets</em> gives access to a list of all style sheet objects (aka <em>CSSStylesheet</em>) explicitly linked (i.e. <em>&lt;link&gt;</em>) or embedded (i.e. <em>&lt;style&gt;</em>) in an HTML document. In the code below <em>styleSheets</em> is leverage to gain access to all of the style sheets contained in the document.</p>
 <p class="codeLink">live code: N/A</p>
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;

&lt;link href="http://yui.yahooapis.com/3.3.0/build/cssreset/reset-min.css" rel="stylesheet" type="text/css"&gt;

&lt;style&gt;
body{background-color:red;}
&lt;/style&gt;

&lt;/head&gt;
&lt;body&gt;

&lt;script&gt;

console.log(<strong>document.styleSheets</strong>.length); <em>//logs 2</em>
console.log(<strong>document.styleSheets[0]</strong>); <em>// the &lt;link&gt;</em>
console.log(<strong>document.styleSheets[1]</strong>); <em>// the &lt;style&gt;</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<div class="notes">
 <h3>Notes</h3>
 <p><em>styleSheet</em> is live just like other node lists</p>
 <p>The <em>length</em> property returns the number of stylesheets contained in the list starting at 0 index (i.e.<em> document.styleSheets.length</em>)</p>
 <p>The style sheets included in a <em>styleSheets</em> list typically includes any style sheets created using the <em>&lt;style&gt;</em> element or using a <em>&lt;link&gt;</em> element where <em>rel</em> is set to <em>"stylesheet"</em></p>
</div>
<p> In addtion to using <em>styleSheets</em> to access a documents styles sheets its also possible to access a style sheet in an HTML document by first selecting the element in the DOM (<em>&lt;style&gt;</em> or <em>&lt;link&gt;</em>) and using the <em>.sheet</em> property to gain access to the <em>CSSStyleSheet</em> object. In the code below I access the style sheets in the HTML docment by first selecting the element used to include the style sheet and then leveraging the <em>sheet</em> property.</p>
 
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;

&lt;link id="linkElement" href="http://yui.yahooapis.com/3.3.0/build/cssreset/reset-min.css" rel="stylesheet" type="text/css"&gt;

&lt;style id="styleElement"&gt;
body{background-color:#fff;}
&lt;/style&gt;

&lt;/head&gt;
&lt;body&gt;

&lt;script&gt;

<em>//get CSSStylesheeet object for &lt;link&gt;</em>
console.log(document.querySelector('#linkElement').<strong>sheet</strong>); <strong><em>//same as document.styleSheets[0]</em></strong><em><strong></strong></em> <em></em>

<em>//get CSSSstylesheet object for &lt;style&gt;</em>
console.log(document.querySelector('#styleElement').<strong>sheet</strong>);<em> //same as document.styleSheets[1]</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

<h2>9.3<em> CSSStyleSheet</em> properties and methods</h2>
<p>To get accurate information pertaining to the available properties and
	methods on an <em>CSSStyleSheet</em> node its best to ignore the
	specification and to ask the browser what is available. Examine the arrays
	created in the code below detailing the properties and methods available
	from a <em>CSSStyleSheet</em> node.</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;<p>&lt;style&#xA0;id="styleElement"&gt;<br>body{background-color:#fff;}<br>&lt;/style&gt;</p><p>&lt;/head&gt;
&lt;body&gt;

&lt;script&gt;

var styleSheet = document.querySelector('#styleElement').sheet;

<em>//text own properties</em>
console.log(Object.keys(styleSheet).sort());

<em>//text own properties &amp; inherited properties</em>
var styleSheetPropertiesIncludeInherited = [];
for(var p in styleSheet){
	styleSheetPropertiesIncludeInherited.push(p);
}
console.log(styleSheetPropertiesIncludeInherited.sort());

<em>//text inherited properties only</em>
var styleSheetPropertiesOnlyInherited = [];
for(var p in styleSheet){
	if(!styleSheet.hasOwnProperty(p)){
		styleSheetPropertiesOnlyInherited.push(p);
	}
}
console.log(styleSheetPropertiesOnlyInherited.sort());

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</p></pre>
<p>A <em>CSSStyleSheet</em> object accessed from a <em>styleSheets</em> list or via the <em>.sheet</em> property has the following properties and methods:</p>
<ul>
	<li><em> disabled</em></li>
		<li><em>href</em></li>
		<li><em>media</em></li>
		<li><em>ownerNode</em></li>
		<li><em>parentStylesheet</em></li>
		<li><em>title</em></li>
		<li><em>type</em></li>
		<li><em>cssRules</em></li>
		<li><em>ownerRule</em></li>
		<li><em>deleteRule</em></li>
		<li><em>inserRule</em> </li>
	</ul>
 <div class="notes">
 <h3>Notes</h3>
 <p><em>href</em>, <em>media</em>, <em>ownerNode</em>, <em>parentStylesheet</em>, <em>title</em>, and <em>type</em> are read only properties, you can't set its value using these properteis</p>
 </div>
 <h2>9.4<em> CSSStyleRule </em>overview</h2>
	<p>A <em>CSSStyleRule</em> object represents each CSS rule contained in a style sheet. Basicly a <em>CSSStyleRule</em> is the interface to the CSS properties and values attached to a selector. In the code below we programaticlly access the details of each rule contained in the inline style sheet by accessing the <em>CSSStyleRule</em> object that represents the CSS rule in the style sheet.</p>
 
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;

&lt;style id="styleElement"&gt;
body{background-color:#fff;margin:20px;} <em>/*this is a css rule*/</em>
p{line-height:1.4em; color:blue;} <em>/*this is a css rule*/</em>
&lt;/style&gt;

&lt;/head&gt;
&lt;body&gt;

&lt;script&gt;

var sSheet = document.querySelector('#styleElement');

console.log(sSheet.cssRules[0].cssText); <em>//logs "body { background-color: red; margin: 20px; }"</em>
console.log(sSheet.cssRules[1].cssText); <em>//logs "p { line-height: 1.4em; color: blue; }"</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
	<h2>9.5 <em>CSSStyleRule</em> properties and methods</h2>
	<p>To get accurate information pertaining to the available properties and
	methods on an <em>CSSStyleRule</em> node its best to ignore the
	specification and to ask the browser what is available. Examine the arrays
	created in the code below detailing the properties and methods available
	from a <em>CSSStyleRule</em>node.</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;<p>&lt;style&#xA0;id="styleElement"&gt;<br>body{background-color:#fff;}<br>&lt;/style&gt;</p><p>&lt;/head&gt;
&lt;body&gt;

&lt;script&gt;

var styleSheetRule = document.querySelector('#styleElement').sheet.cssRule;

<em>//text own properties</em>
console.log(Object.keys(styleSheetRule).sort());

<em>//text own properties &amp; inherited properties</em>
var styleSheetPropertiesIncludeInherited = [];
for(var p in styleSheetRule){
	styleSheetRulePropertiesIncludeInherited.push(p);
}
console.log(styleSheetRulePropertiesIncludeInherited.sort());

<em>//text inherited properties only</em>
var styleSheetRulePropertiesOnlyInherited = [];
for(var p in styleSheetRule){
	if(!styleSheetRule.hasOwnProperty(p)){
		styleSheetRulePropertiesOnlyInherited.push(p);
	}
}
console.log(styleSheetRulePropertiesOnlyInherited.sort());

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</p></pre>
<p>Scripting the rules (e.g. <em>body{background-color:red;}</em>) contained inside of a style sheet is made possible by the <em>CSSrule</em> object. This object provides the following properties:</p>
	<ul>
		<li><em>cssText</em></li>
		<li><em>parentRule</em></li>
		<li><em>parentStylesSheet</em></li>
		<li><em>selectorText</em></li>
		<li><em>style</em></li>
		<li><em>type</em>	</li>
	</ul>
	<h2>9.6 Getting a list of CSS Rules in a style sheet using <em>CSSRules</em></h2>
	<p>As previously discussed the <em>styleSheets</em> list provides a list of style sheets contained in a document. The <em>CSSRules</em> list provides a list (aka <em>CSSRulesList</em>) of all the CSS rules (i.e. <em>CSSStyleRule</em> objects) in a specific style sheet. The code below logs a <em>CSSRules</em> list to the console.</p>
	 
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;

&lt;style id="styleElement"&gt;
body{background-color:#fff;margin:20px;}
p{line-height:1.4em; color:blue;}
&lt;/style&gt;

&lt;/head&gt;
&lt;body&gt;

&lt;script&gt;

var sSheet = document.querySelector('#styleElement').sheet;

<em>//array like list containing all of the CSSrule objects repreesenting each CSS rule in the style sheet</em>
console.log(sSheet.<strong>cssRules</strong>);

console.log(sSheet.cssRules.length); <em>//logs 2</em>

<em>//rules are index in a CSSRules list starting at a 0 index</em>
console.log(sSheet.cssRules[0]); <em>//logs first rule</em>
console.log(sSheet.cssRules[1]); <em>//logs second rule</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
 <h2>9.7 Inserting &amp; deleting CSS rules in a style sheet using <em>.insertRule()</em> and <em>.deleteRule()</em></h2>
 <p>The <em>insertRule()</em> and <em>deleteRule()</em> methods provided the ability to programatically manipulate the CSS rules in a style sheet. In the code below I use <em>insertRule()</em> to add the css rule <em>p{color:red}</em> to the inline style sheet at index 1. Remeber the css rules in a style sheet are numerical index starting at 0. So by inserting a new rule at index 1 the current rule at index 1 (i.e. <em>p{font-size:50px;}</em>) is push to index 2. </p>
 
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;

&lt;style id="styleElement"&gt;
p{line-height:1.4em; color:blue;} <em>/*index 0*/</em>
p{font-size:50px;} <em>/*index 1*/</em>
&lt;/style&gt;

&lt;/head&gt;
&lt;body&gt;

&lt;p&gt;Hi&lt;/p&gt;

&lt;script&gt;

<em>//add a new CSS rule at index 1 in the inline style sheet</em>
document.querySelector('#styleElement').sheet.<strong>insertRule('p{color:red}',1)</strong>;

<em>//verify it was added</em><br>console.log(document.querySelector('#styleElement').sheet.cssRules[1].cssText);

<em>//Delete what we just added
</em>document.querySelector('#styleElement').sheet.deleteRule(1);

<em>//verify it was removed</em><br>console.log(document.querySelector('#styleElement').sheet.cssRules[1].cssText);

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>Deleting or removing a rule is as simple as calling <em>deleteRule()</em> method on a style sheet and passing it the index of the rule in the style sheet to be deleted.</p>

<div class="notes">
 <h3>Notes</h3>
 <p>Inserting and deleting rules is not a common practice given the difficulty around managing the cascaade and using a numeric indexing system to update a style sheet (i.e. determining at what index a style is located without previewing the contents of the style sheet itself.). Its much simpler working with CSS rules in CSS and HTML files before they are served to a client than programaticlly altering them in the client after the fact.</p>
</div>
<h2>9.8 Editing the value of a <em>CSSStyleRule</em> using the <em>.style</em> property</h2>
	<p>Just like the <em>.style</em> property that facilitates the manipulation of inline styles on element nodes there is a also <em>.style</em> property for <em>CSSStyleRule</em> objects that orchestrates the same manipulation of styles in style sheets. In the code below I levereage the <em>.style</em> property to set and get the value of css rules contained in the inline style sheet.</p>
 
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;

&lt;style id="styleElement"&gt;
p{color:blue;}
strong{color:green;}
&lt;/style&gt;

&lt;/head&gt;
&lt;body&gt;

&lt;p&gt;Hey &lt;strong&gt;Dude!&lt;/strong&gt;&lt;/p&gt;

&lt;script&gt;

var styleSheet = document.querySelector('#styleElement').sheet;

<em>//Set css rules in stylesheet</em>
styleSheet.cssRules[0]<strong>.style.color = 'red';</strong>
styleSheet.cssRules[1]<strong>.style.color = 'purple'</strong>;

<em>//Get css rules</em>
console.log(styleSheet.cssRules[0]<strong>.style.color)</strong>; <em>//logs 'red'</em>
console.log(styleSheet.cssRules[1]<strong>.style.color</strong>); <em>//logs 'purple'</em>

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
	<h2>9.9 Creating a new inline CSS style sheets</h2>
	<p>To craft a new style sheet on the fly after an html page is loaded one only has to create a new <em>&lt;style&gt;</em> node, add CSS rules using <em>innerHTML</em> to this node, then append the<em> &lt;style&gt;</em> node to the HTML document. In the code below I programatily craft a style sheet and add the <em>body{color:red}</em> CSS rule to the style sheet, then append the stylesheet to the DOM.</p>
 
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;&lt;/head&gt;
&lt;body&gt;

&lt;p&gt;Hey &lt;strong&gt;Dude!&lt;/strong&gt;&lt;/p&gt;

&lt;script&gt;

<strong>var styleElm = document.createElement('style');
styleElm.innerHTML = 'body{color:red}';</strong>

<em>//notice markup in the document changed to red from our new inline stylesheet</em>
document.querySelector('head').appendChild(styleElm);

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
	<h2>9.10 Programatically adding external style sheets to an HTML document</h2>
	<p>To add a CSS file to an HTML document programatically a <em>&lt;link&gt;</em> element node is created with the appropriate attributes and then the <em>&lt;link&gt;</em> element node is appended to the DOM. In the code below I programatically include an external style sheet by crafting a new <em>&lt;link&gt;</em> element and appending it to the DOM.</p>
	
 
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;&lt;/head&gt;
&lt;body&gt;

&lt;script&gt;

<em>//create &amp; add attributes to &lt;link&gt;</em>
<strong>var linkElm = document.createElement('link');<br>linkElm.setAttribute('rel', 'stylesheet');<br>linkElm.setAttribute('type', 'text/css');
linkElm.setAttribute('id', 'linkElement');<br>linkElm.setAttribute('href', 'http://yui.yahooapis.com/3.3.0/build/cssreset/reset-min.css');</strong>

<em>//Append to the DOM</em>
document.head.appendChild(linkElm);

<em>//confrim its addition to the DOM</em>
console.log(document.querySelector('#linkElement'));

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

	<h2>9.11 Disabling/Enabling style sheets using <em>disabled</em> property</h2>
	<p>Using the <em>.disabled</em> property of a <em>CSSStyleSheet</em> object its possible to enable or disabled a style sheet. In the code below we access the current disabled value of each style sheet in the document then proceed to disabled each style sheet leveraging the <em>.disabled</em> property.</p>
	
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;

&lt;link id="linkElement" href="http://yui.yahooapis.com/3.3.0/build/cssreset/reset-min.css" rel="stylesheet" type="text/css"&gt;

&lt;style id="styleElement"&gt;
body{color:red;}
&lt;/style&gt;

&lt;/head&gt;
&lt;body&gt;

&lt;script&gt;

<em>//Get current boolean disabled value</em>
console.log(document.querySelector('#linkElement').<strong>disabled</strong>); <em>//log 'false'</em>
console.log(document.querySelector('#styleElement').<strong>disabled</strong>); <em>//log 'false'</em>

<em>//Set disabled value, which of courese disabled all styles for this document</em>
document.document.querySelector('#linkElement').<strong>disabled</strong> = true;
document.document.querySelector('#styleElement').<strong>disabled</strong> = true;

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

<div class="notes">
 <h3>Notes</h3>
 <p>Disabled is not an avaliable attributre of a &lt;link&gt; or &lt;style&gt; element according to the specification. Trying to add this as an attribute in the HTML document itself will fail (and likley cause parsing errors where styles are ignored) in the majority of modern browsers in use today.</p>
</div>

</div>




<div id="chapter10" class="chapter">


 <h2>Chapter 10 - JavaScript in the DOM</h2>
	
	<h2>10.1 Inserting &amp; executing JavaScript overview</h2>
	<p>JavaScript can be inserted in to an HTML document in a modern way by including external JavaScript files or writing page level inline JavaScript, which is basically the contents of an external JavaScript file literally embed in the HTML page as a text node. Don't confuse element inline JavaScript contained in attribute event handlers (i.e. <em>&lt;div onclick="alert('yo')"&gt;&lt;/div&gt;</em>) with page inline JavaScript (i.e. <em>&lt;script&gt;alert('hi')&lt;/script&gt;</em>).</p>
	<p>Both methods of inserting JavaScript into an HTML document require the use of a <em><a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/scripting-1.html#the-script-element">&lt;script&gt;</a></em><a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/scripting-1.html#the-script-element"> element node</a>. The <em>&lt;script&gt;</em> element can contain JavaScript code or can be used to link to external JavaScript files using the <em>src</em> attribute. Both methods are explored in the code example below.</p>
	
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

<em>&lt;!-- external, cross domain JavaScript include</em><em> --&gt;</em>
<strong>&lt;script src="http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.3.3/underscore-min.js"&gt;&lt;/script&gt;</strong>

<em>&lt;!-- page inline JavaScript</em><em> --&gt;</em>
<strong>&lt;script&gt;
console.log('hi');
&lt;/script&gt;</strong>

&lt;/body&gt;
&lt;/html&gt;
</pre>
<div class="notes">
 <h3>Notes</h3>
 <p>Its possible to insert and execute JavaScript in the DOM by placing JavaScript in an element attribute event handler (i.e. <em>&lt;div onclick="alert('yo')"&gt;&lt;/div&gt;</em>) and using the <em>javascript:</em> protocal (e.g. <em>&lt;a href="javascript:alert('yo')"&gt;&lt;/a&gt;</em>) but this is no longer considered a modern practice.</p>
 <p>Trying to include an external JavaScript file and writing page inline JavaScript using the same <em>&lt;script&gt;</em> element will result in the page inline JavaScript being ignored and the exterenal JavaScript file being downloaded and exectued </p>
 <p>Self-closing scripts tags (i.e. <em>&lt;script src="" /&gt;</em> ) should be avoid unless you are rocking some old school XHTML</p>
 <p>The <em>&lt;script&gt;</em> element does not have any required attributes but offers the follow optional attribures: <em>async</em>, <em>charset</em>, <em>defer</em>, <em>src</em>, and <em>type</em></p>
 <p>Page inline JavaScript produces a text node. Which permits the usage of <em>innerHTML</em> and <em>textContent</em> to retrieve the contents of a line <em>&lt;script&gt;</em>. However, appending a new text node made up of JavaScript code to the DOM after the browser has already parsed the DOM will not execute the new JavaScript code. It simply replaces the text.</p>
 <p>If JavaScript code contains the string <em>'&lt;/script&gt;'</em> you will have to escape the closing <em>'/'</em> with <em>'&lt;\/script&gt;'</em> so that the parser does not think this is the real closing <em>&lt;/script&gt;</em> element</p>
</div>
	<h2>10.2 JavaScript is parsed synchronously by default</h2>
	<p>By default when the DOM is being parsed and it encounters a <em>&lt;script&gt;</em> element it will stop parsing the document, block any further rendering &amp; downloading, and exectue the JavaScript. Because this behavior is blocking and does not permit parallel parsing of the DOM or exection of JavaScriopt its consider to be synchronous. If the JavaScript is external to the html document the blocking is exacerbated because the JavaScript must first be downloaed before it can be parsed. In the code example below I comment what is occuring during browser rendering when the browser encoutners several <em>&lt;script&gt;</em> elements in the DOM.</p>
 
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

<em></em><em>&lt;!-- stop document parsing, block document parsing, load js, exectue js, then resume document parsing...</em><em> --&gt;</em><em></em>
<strong>&lt;script src="http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.3.3/underscore-min.js"&gt;&lt;/script&gt;</strong><em>
</em><em>
</em><em>&lt;!-- stop document parsing, block document parsing, exectue js, then resume document parsing...</em><em> --&gt;</em><em>
</em><strong>&lt;script&gt;console.log('hi');&lt;/script&gt;</strong><em></em><strong></strong>
<em></em>

&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>You should make note of the differences between an inline script's and external scripts as it pertains to the loading phase.</p>
<div class="notes">
 <h3>Notes</h3>
 <p>The default blocking nature of a <em>&lt;script&gt;</em> element can have a significant effect on the perfomrance &amp; percived performance of the visual rendering of a HTML web page. If you have a couple of script elements at the start of an html page nothing else is happening (e.g. DOM parsing &amp; resource loading) until each one is downloaed and executed sequentially. </p>
</div>
	<h2>10.3 Defering the downloading &amp; exectuion of external JavaScript using <em>defer</em></h2>
	<p>The <em>&lt;script&gt;</em> element has an attribute called <em>defer</em> that will defer the blocking, downloading, and executing of an external JavaScript file until the browser has parsed the closing <em>&lt;html&gt;</em> node. Using this attribute simply defers what normally occurs when a web browser encoutners a <em>&lt;script&gt;</em> node. In the code below I defer each external JavaScript file until the final <em>&lt;html&gt;</em> is encountered.</p>
 
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

<em>&lt;!-- defer, don't block just ignore this until the &lt;html&gt; element node is parsed --&gt;</em>
&lt;script <strong>defer</strong> src="http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.3.3/underscore-min.js"&gt;&lt;/script&gt;<strong>

</strong><em>&lt;!-- defer, don't block just ignore this until the &lt;html&gt; element node is parsed</em><em> --&gt;</em>
&lt;script <strong>defer</strong> src="http://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js"&gt;&lt;/script&gt;

<em>&lt;!-- defer, don't block just ignore this until the &lt;html&gt; element node is parsed</em><em> --&gt;</em>
&lt;script <strong>defer</strong> src="http://cdnjs.cloudflare.com/ajax/libs/jquery-mousewheel/3.0.6/jquery.mousewheel.min.js"&gt;&lt;/script&gt;

&lt;script&gt;
<em>//We know that jQuery is not avaliable because this occurs before the closing &lt;html&gt; element</em>
console.log(window['jQuery'] === undefined); <em>//logs true</em>

<em>//Only after everything is loaded can we safley conclude that jQuery was loaded and parsed</em>
document.body.onload = function(){console.log(jQuery().jquery)}; <em>//logs function</em>
&lt;/script&gt; 

&lt;/body&gt;
&lt;/html&gt;
</pre>
<div class="notes">
 <h3>Notes</h3>
 <p>According to the specification defered scripts are suppose to be exectued in document order and before the <em>DOMContentLoaded</em> event. However, adherence to this specification among modern browsers is inconsistent.</p>
 <p><em>defer</em> is a boolan attribute it does not have a value</p>
 <p>Some browers support defered inline scripts but this is not common among modern browsers</p>
 <p>By using <em>defer</em> the assummption is that <em>document.write()</em> is not being used in the JavaScript that will be defered</p>
</div>
	<h2>10.4 Asynchronously downloading &amp; executing external JavaScript files using <em>async</em></h2>
	<p>The <em>&lt;script&gt;</em> element has an attribute called <em>async</em> that will override the sequential blocking nature of <em>&lt;script&gt;</em> elements when the DOM is being constructed by a web browser. By using this attribute, we are telling the browser not to block the construction (i.e. DOM parsing, including downloading other assets e.g. images, style sheets, etc...) of the html page and forgo the the sequential loading as well. </p>
	<p>What happens by using the <em>async</em> attribute is the files are loaded in parallel and parsed in order of download once they are fully downloaded. In the code below I comment what is happening when the HTML document is being parsed and render by the web browser.</p>
 
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

<em></em><strong><em>&lt;!-- Don't block, just start downloading and then parse the file when it's done downloading --&gt;</em></strong>
&lt;script <strong>async</strong> src="http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.3.3/underscore-min.js"&gt;&lt;/script&gt;<strong>
<em></em>
</strong><em>&lt;!-- Don't block, just start downloading and then parse the file when it's done downloading --&gt;
</em>&lt;script <strong>async</strong> src="http://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js"&gt;&lt;/script&gt;<em>

&lt;!-- Don't block, just start downloading and then parse the file when it's done downloading --&gt;
</em>&lt;script <strong>async</strong> src="http://cdnjs.cloudflare.com/ajax/libs/jquery-mousewheel/3.0.6/jquery.mousewheel.min.js"&gt;&lt;/script&gt;
<em></em>

&lt;script&gt;
<em>// we have no idea if jQuery has been loaded yet likley not yet...</em>
console.log(window['jQuery'] === undefined);<em>//logs true</em>

<em>//Only after everything is loaded can we safley conclude that jQuery was loaded and parsed</em>
document.body.onload = function(){console.log(jQuery().jquery)}<em></em>;
&lt;/script&gt; 

&lt;/body&gt;
&lt;/html&gt;
</pre>

<div class="notes">
 <h3>Notes</h3>
 <p>IE 10 has support for <em>async</em>, but IE 9 does not</p>
 <p>A major drawback to using the <em>async</em> attribute is JavaScript files potentially get parsed out of the order they are included in the DOM. This raises a dependency management issue.</p>
 <p><em>async</em> is a boolan attribute it does not have a value</p>
 <p>By using <em>async</em> the assummption is that <em>document.write()</em> is not being used in the JavaScript that will be defered</p>
 <p>The <em>async</em> attribute will trump the <em>defer</em> if both are used on a <em>&lt;script&gt;</em> element</p>
</div>

	<h2>10.5 Forcing asynchronous downloading &amp; parsing of external JavaScript using dynamic <em>&lt;script&gt;</em></h2>
 <p>A known hack for forcing a web browser into asynchronous JavaScript downloading and parsing without using the <em>async</em> attribure is to programatically create <em>&lt;script&gt;</em> elements that include external JavaScript files and insert them in the DOM. In the code below I programatically create the <em>&lt;script&gt;</em> element node and then append it to the <em>&lt;body&gt;</em> element which forces the browser to treat the <em>&lt;script&gt;</em> element asynchronously.</p>
 
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

<em>&lt;!-- Don't block, just start downloading and then parse the file when it's done downloading --&gt;</em>
&lt;script&gt;
<strong>var underscoreScript = document.createElement("script"); 
underscoreScript.src = "http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.3.3/underscore-min.js"; 
document.body.appendChild(underscoreScript);</strong>
&lt;/script&gt;

<em>&lt;!-- Don't block, just start downloading and then parse the file when it's done downloading --&gt;</em>
&lt;script&gt;
<strong>var jqueryScript = document.createElement("script");
jqueryScript.src = "http://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js"; 
document.body.appendChild(jqueryScript);</strong>
&lt;/script&gt;

<em>&lt;!-- Don't block, just start downloading and then parse the file when it's done downloading --&gt;</em>
&lt;script&gt;
<strong>var mouseWheelScript = document.createElement("script");
mouseWheelScript.src = "http://cdnjs.cloudflare.com/ajax/libs/jquery-mousewheel/3.0.6/jquery.mousewheel.min.js"; 
document.body.appendChild(mouseWheelScript);</strong>
&lt;/script&gt;

&lt;script&gt;
<em>//Only after everything is loaded can we safley conclude that jQuery was loaded and parsed</em>
document.body.onload = function(){console.log(jQuery().jquery)}<em></em>;
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</pre>
 <div class="notes">
 <h3>Notes</h3>
 <p>A major drawback to using dynamic <em>&lt;script&gt;</em> elements is JavaScript files potentially get parsed out of the order they are included in the DOM. This raises a dependency management issue.</p>
 </div>
	<h2>10.6 Using the <em>onload</em> call back for asynchronous <em>&lt;script&gt;</em>'s so we know when its loaded</h2>
	<p>The <em>&lt;script&gt;</em> element <a href="http://pieisgood.org/test/script-link-events/">supports a load event</a> handler (ie. <em>onload</em>) that will execute once an external JavaScript file has been loaded and executed. In the code below I leverage the <em>onload</em> event to create a callback programatically notifying us when the JavaScript file has been downloaded and exectued.</p>
 
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

<em>&lt;!-- Don't block, just start downloading and then parse the file when it's done downloading --&gt;</em>
&lt;script&gt;
var underscoreScript = document.createElement("script"); 
underscoreScript.src = "http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.3.3/underscore-min.js";
underscoreScript.<strong>onload = function(){console.log('underscsore is loaded and exectuted');};</strong>
document.body.appendChild(underscoreScript);
&lt;/script&gt;

<em>&lt;!-- Don't block, just start downloading and then parse the file when it's done downloading --&gt;</em>
&lt;script async src="http://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js" <strong>onload="console.log('jQuery is loaded and exectuted');"</strong>&gt;&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</pre>

	<h2>10.7 Be mindful of <em>&lt;script&gt;</em> 's placement in HTML for DOM manipulation</h2>
	<p>Given a <em>&lt;script&gt;</em> elements synchronous nature, placing one in the <em>&lt;head&gt;</em> element of an HTML document presents a timing problem if the JavaScript execution is dependant upon any of the DOM that proceeds the <em>&lt;script&gt;</em>. In a nut shell, if JavaScript is executed at the begining of a document that manipulates the DOM, that proceeds it, you are going to get a JavaScript error. Proven by the following code example:</p>
	<p class="codeLink">live code: N/A</p>
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
<em>&lt;!-- stop parsing, block parsing, exectue js then resume... --&gt;</em>
&lt;script&gt;
<em>//we can't script the body element yet, its null, not even been parsed by the browser, its not in the DOM yet </em>
<strong>console.log(document.body.innerHTML);</strong> <em>//logs Uncaught TypeError: Cannot read property 'innerHTML' of null</em> 
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;strong&gt;Hi&lt;/strong&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
	<p>Many developers, myself being one of them, for this reason will attempt to place all <em>&lt;script&gt;</em> elements before the closing <em>&lt;/body&gt;</em> element. By doing this you can rest assured the DOM in front of the <em>&lt;script&gt;</em>'s has been parsed and is ready for scripting. As well, this strategy will remove a dependancy on DOM ready events that can liter a code base.	</p>
	<h2>10.8 Getting a list of <em>&lt;script&gt;</em>'s in the DOM</h2>
	<p>The <em>document.scripts</em> property avaliable from the document object provides a list (i.e. an <em>HTMLCollection</em>) of all of the scripts currently in the DOM. In the code below I leverage this property to gain access to each of the <em>&lt;script&gt;</em> elements <em>src</em> attributes.</p>
	<p class="codeLink">live code: N/A</p>
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;
&lt;script src="http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.3.3/underscore-min.js"&gt;&lt;/script&gt;
&lt;script src="http://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js"&gt;&lt;/script&gt;
&lt;script src="http://cdnjs.cloudflare.com/ajax/libs/jquery-mousewheel/3.0.6/jquery.mousewheel.min.js"&gt;&lt;/script&gt;

&lt;script&gt;&#x200B;
Array.prototype.slice.call(document.<strong>scripts</strong>).forEach(function(elm){<br>	console.log(elm); <br>});<em>//will log each script element in the document</em>
&lt;/script&gt; 

&lt;/body&gt;
&lt;/html&gt;
</pre>
 

</div>




<div id="chapter11" class="chapter">


 <h2>Chapter 11 - DOM Events</h2>
 <h2>11.1 DOM events overview</h2>
 <p>An event, in terms of the DOM, is either a pre-defined or custom moment in time that occurs in relationship with an element in the DOM, the <em>document</em> object, or the <em>window</em> object. These moments are typically predetermined and programaticlly accounted for by associating functionality (i.e. handlers/callbacks) to occur when these moments in time come to pass. These moments can be initiated by that state of the UI (e.g. input is focused or something has been dragged), the state of the enviroment that is running the JavaScript program (e.g. page is loaded or XHR request has finished), or the state of the program itself (e.g. start monitor users ui interaction for 30 seconds after the page has loaded).</p>
 <p>Setting up events can be accomplished using inline attribute event handlers, property event handlers, or the <em>addEventListener()</em> method. In the code below I'm demonstrating these three patterns for setting up an event. All three patterns add a <em>click</em> event that is invoked whenever the <em>&lt;div&gt;</em> in the html document is clicked by the mouse. </p>
 
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

<em>&lt;!-- inline attribure event handler pattern --&gt;</em>
&lt;body <strong>onclick</strong>="console.log('fire/trigger attribure event handler')"&gt;

&lt;div&gt;click me&lt;/div&gt;

&lt;script&gt;
var elementDiv = document.querySelector('div');

<em>// property event handler pattern</em>
elementDiv.<strong>onclick</strong> = function(){console.log('fire/trigger property event handler')};

<em>//addEventListener method pattern</em>
elementDiv.<strong>addEventListener</strong>('click',function(){console.log('fire/trigger addEventListener')}, false);
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;
</pre>
 <p>Notice that one of the events is attached to the <em>&lt;body&gt;</em> element. If you find it odd that the attribute event handler on the <em>&lt;body&gt;</em> fires by clicking the <em>&lt;div&gt;</em> element consider that when the <em>&lt;div&gt;</em> is clicked, are you not also clicking on the <em>&lt;body&gt;</em> element. Click anywhere but on the <em>&lt;div&gt;</em> and you still see the attribute handler fire on the <em>&lt;body&gt;</em> element alone. </p>
 <p>While all three of these patterns for attaching an event to the DOM programatically schedule the event, only the <em>addEventListener()</em> provides a robust and organized solution. The inline attribute event handler mixes together JavaScript and HTML and best practices advise keeping these things seperate. </p>
 <p>The downside to using a property event handler is that only one value can be assigned to the event property at a time. Meaning, you can't add more than one propety event handler to a DOM node when assigning events as property values. The code below shows an example of this by assigning a value to the <em>onclick</em> property twice, the last value set is used when the event is invoked.</p>
 
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;div&gt;click me&lt;/div&gt;

&lt;script&gt;
var elementDiv = document.querySelector('div');

<em>// property event handler </em>
elementDiv.<strong>onclick = function(){console.log('I\'m first, but I get overidden/replace')};
</strong>
<em>//overrides/replaces the prior value
</em>elementDiv.<strong>onclick = function(){console.log('I win')};
</strong>
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;
</pre>
 <p>Additionaly, using event handlers inline or property event handlers can suffer from scoping nuances as one attempts to leverage the scope chain from the function that is invoked by the event. The <em>addEventListener()</em> smooths out all of these issues, and will be used throughout this chapter.</p>
 <div class="notes">
 <h3>Notes</h3>
 <p><em>Element</em> nodes typically support inline event handlers (e.g. <em>&lt;div onclick=""&gt;&lt;/div&gt;</em>), property event handlers (e.g. <em>document.querySelector('div').onclick = function(){}</em>), and the use of the <em>addEventListener()</em> method. </p>
 <p> The <em>Document</em> node supports property event handlers (e.g.<em> document.onclick = funciton()</em>) and the use of the <em>addEventListener()</em> method.</p>
 <p>The <em>window</em> object supports inline event handler's via the <em>&lt;body&gt;</em> or <em>&lt;frameset&gt;</em> element (e.g. <em>&lt;body onload=""&gt;&lt;/body&gt;</em>), property event handlers (e.g. <em>window.load = function(){}</em>), and the use of the <em>addEventListener()</em> method.</p>
 <p>A property event handler historically has been refered to as a "DOM level 0 event". And the <em>addEventListener()</em> is often refered to as a "DOM level 2 event". Which is rather confusing considering there is no level 0 event or level 1 event. Addintioanlly, inline event handlers are known to be called, "HTML event handlers".</p>
 </div>
 <h2>11.2 DOM event types</h2>
 <p> In the tables below I detail the most common pre-defined events that can be attached to <em>Element</em> nodes, the <em>document</em> object, and the <em>window</em> object. Of course not all events are directly applicable to the node or object it can be attached too. That is, just because you can attach the event without error, and most likley invoke the event (i.e. bubbling events like <em>onchange</em> to <em>window</em>), does not mean that adding something like <em>window.onchange </em> is logical given that this event, by design was not meant for the <em>window</em> object.</p>
 
 <p><strong>User interface events </strong></p>
 <table border="0" class="table table-bordered">
	<thead>
		<tr>
			<th>Event Type</th>
			<th>Event Interface</th>
			<th>Description</th>
			<th>Event Targets</th>
			<th>Bubbles</th>
			<th>Cancelable</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><em>load</em></td>
			<td><em>Event</em>,<em> UIEvent</em></td>
			<td>fires when an asset (HTML page, image, CSS, frameset, <em>&lt;object&gt;</em>, or JS file) is loaded.</td>
			<td><em>Element</em>, <em>Document</em>, <em>window</em>, <em>XMLHttpRequest</em>, <em>XMLHttpRequestUpload</em></td>
			<td>No</td>
			<td>No</td>
		</tr>
		<tr>
			<td><em>unload</em></td>
			<td><em> UIEvent</em></td>
			<td>fires when user agent removes the resource (document, element, defaultView) or any depending resources (images, CSS file, etc.)</td>
			<td><em>window</em>, <em>&lt;body&gt;</em>, <em>&lt;frameset&gt;</em></td>
			<td>No</td>
			<td>No</td>
		</tr>
		<tr>
			<td><em>abort</em></td>
			<td><em>Event</em>,<em> UIEvent</em></td>
			<td>Fires when an resource (object/image) is stopped from loading before completely loaded</td>
			<td><em>Element</em>,<em> XMLHttpRequest</em>, <em>XMLHttpRequestUpload</em></td>
			<td>Yes</td>
			<td>No</td>
		</tr>
		<tr>
			<td><em>error</em></td>
			<td><em>Event</em>,<em> UIEvent</em></td>
			<td>Fires when a resource failed to load, or has been loaded but cannot be interpreted according to its semantics, such as an invalid image, a script execution error, or non-well-formed XML</td>
			<td><em>Element</em>,<em> XMLHttpRequest</em>, <em>XMLHttpRequestUpload</em></td>
			<td>Yes</td>
			<td>No</td>
		</tr>
		<tr>
			<td><em>resize</em></td>
			<td><em>UIEvent</em></td>
			<td>Fires when a document view has been resized. This event type is dispatched after all effects for that occurrence of resizing of that particular&#xA0;event target&#xA0;have been executed by the&#xA0;user agent</td>
			<td><em>window</em>, <em>&lt;body&gt;</em>, <em>&lt;frameset&gt;</em></td>
			<td>Yes</td>
			<td>No</td>
		</tr>
		<tr>
			<td><em>scroll</em></td>
			<td><em>UIEvent</em></td>
			<td>Fires when a user scrolls a document or an element.</td>
			<td><em>Element</em>, <em>Document</em>, <em>window</em></td>
			<td>Yes</td>
			<td>No</td>
		</tr>
		<tr>
			<td><em>contextmenu</em></td>
			<td><em>MouseEvent</em></td>
			<td>fires by right clicking an element</td>
			<td><em>Element</em></td>
			<td>Yes</td>
			<td>Yes</td>
		</tr>
		
	</tbody>
</table>
<p><strong>Focus events </strong></p>
 <table border="0" class="table table-bordered">
	<thead>
		<tr>
			<th>Event Type</th>
			<th>Event Interface</th>
			<th>Description</th>
			<th>Events Targets</th>
			<th>Bubbles</th>
			<th>Cancelable</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><em>blur</em></td>
			<td><em>FocusEvent</em></td>
			<td>Fires when an element loses focus either via the mouse or tabbing</td>
			<td><em>Element</em>&#xA0;(except <em>&lt;body&gt;</em>&#xA0;and <em>&lt;frameseet&gt;</em> ), <em>Document</em></td>
			<td>No</td>
			<td>No</td>
		</tr>
		<tr>
			<td><em>focus</em></td>
			<td><em>FocusEvent</em></td>
			<td>Fires when an element receives focus</td>
			<td><em>Element</em>&#xA0;(except <em>&lt;body&gt;</em>&#xA0;and <em>&lt;frameseet&gt;</em> ), <em>Document</em></td>
			<td>No</td>
			<td>No</td>
		</tr>
		<tr>
			<td><em>focusin</em></td>
			<td><em>FocusEvent</em></td>
			<td>Fires when an event target is about to receive focus but before the focus is shifted. This event occurs right before the focus event</td>
			<td><em>Element</em></td>
			<td>Yes</td>
			<td>No</td>
		</tr>
		<tr>
			<td><em>focusout</em></td>
			<td><em>FocusEvent</em></td>
			<td>Fires when an event target is about to lose focus but before the focus is shifted. This event occurs right before the blur event</td>
			<td><em>Element</em></td>
			<td>Yes</td>
			<td>No</td>
		</tr>
		
	</tbody>
</table>
<p><strong>Form events </strong></p>
<table border="0" class="table table-bordered">
	<thead>
		<tr>
			<th>Event Type</th>
			<th>Event Interface</th>
			<th>Description</th>
			<th>Event Targets</th>
			<th>Bubbles</th>
			<th>Cancelable</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><em>change</em></td>
			<td>specific to HTML forms</td>
			<td>Fires when a control loses the input&#xA0;focus&#xA0;and its value has been modified since gaining focus</td>
			<td><em>Element</em></td>
			<td>Yes</td>
			<td>No</td>
		</tr>
		<tr>
			<td><em>reset</em></td>
			<td>specific to HTML forms</td>
			<td>Fires when a form is reset</td>
			<td><em>Element</em></td>
			<td>Yes</td>
			<td>No</td>
		</tr>
		<tr>
			<td><em>submit</em></td>
			<td>specific to HTML forms</td>
			<td>Fires when a form is submitted</td>
			<td><em>Element</em></td>
			<td>Yes</td>
			<td>Yes</td>
		</tr>
		<tr>
			<td><em>select</em></td>
			<td>specific to HTML forms</td>
			<td>Fires when a user selects some text in a&#xA0;text field, including input and textarea</td>
			<td><em>Element</em></td>
			<td>Yes</td>
			<td>No</td>
		</tr>
	</tbody>
</table>
<p><strong>Mouse events </strong></p>
 <table border="0" class="table table-bordered">
	<thead>
		<tr>
			<th>Event Type</th>
			<th>Event Interface</th>
			<th>Description</th>
			<th>Event Targets</th>
			<th>Bubbles</th>
			<th>Cancelable</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><em>click</em></td>
			<td><em>MouseEvent</em></td>
			<td>Fires when mouse pointer is clicked (or user presses enter key) over an element. A click is defined as a mousedown and mouseup over the same screen location. The sequence of these events is <em>mousedown</em>&gt;<em>mouseup</em>&gt;<em>click</em>. Depending upon the environment configuration, the&#xA0;click&#xA0;event&#xA0;may&#xA0;be dispatched if one or more of the event types&#xA0;mouseover,&#xA0;mousemove, and mouseout&#xA0;occur between the press and release of the pointing device button. The&#xA0;click&#xA0;event&#xA0;may&#xA0;also be followed by the&#xA0;dblclick&#xA0;event</td>
			<td><em>Element</em>, <em>Document</em>, <em>window</em></td>
			<td>Yes</td>
			<td>Yes</td>
		</tr>
		<tr>
			<td><em>dblclick</em></td>
			<td><em>MouseEvent</em></td>
			<td>Fires when a mouse pointer is clicked twice over an element. The definition of a double click depends on the environment configuration, except that the event target&#xA0;must&#xA0;be the same between&#xA0;<em>mousedown</em>,&#xA0;<em>mouseup</em>, and&#xA0;<em>dblclick</em>. This event type&#xA0;must&#xA0;be dispatched after the event typeclick&#xA0;if a click and double click occur simultaneously, and after the event type&#xA0;<em>mouseup</em>&#xA0;otherwise</td>
			<td><em>Element</em>, <em>Document</em>, <em>window</em></td>
			<td>Yes</td>
			<td>Yes</td>
		</tr>
		<tr>
			<td><em>mousedown</em></td>
			<td><em>MouseEvent</em></td>
			<td>Fires when mouse pointer is pressed over an element</td>
			<td><em>Element</em>, <em>Document</em>, <em>window</em></td>
			<td>Yes</td>
			<td>Yes</td>
		</tr>
		<tr>
			<td><em>mouseenter</em></td>
			<td><em>MouseEvent</em></td>
			<td>Fires when mouse pointer is moved onto the boundaries of an element or one of its descendent elements. This event type is similar to&#xA0;mouseover, but differs in that it does not bubble, and&#xA0;must not&#xA0;be dispatched when the pointer device moves from an element onto the boundaries of one of its descendent elements</td>
			<td><em>Element</em>, <em>Document</em>, <em>window</em></td>
			<td>No</td>
			<td>No</td>
		</tr>
		<tr>
			<td><em>mouseleave</em></td>
			<td><em>MouseEvent</em></td>
			<td>Fires when mouse pointer is moved off of the boundaries of an element and all of its descendent elements. This event type is similar to mouseout, but differs in that does not bubble, and that it must not be dispatched until the pointing device has left the boundaries of the element and the boundaries of all of its children</td>
			<td><em>Element</em>, <em>Document</em>, <em>window</em></td>
			<td>No</td>
			<td>No</td>
		</tr>
		<tr>
			<td><em>mousemove</em></td>
			<td><em>MouseEvent</em></td>
			<td>Fires when mouse pointer is moved while it is over an element. The frequency rate of events while the pointing device is moved is implementation-, device-, and platform-specific, but multiple consecutive mousemove events should be fired for sustained pointer-device movement, rather than a single event for each instance of mouse movement. Implementations are encouraged to determine the optimal frequency rate to balance responsiveness with performance</td>
			<td><em>Element</em>, <em>Document</em>, <em>window</em></td>
			<td>Yes</td>
			<td>No</td>
		</tr>
		<tr>
			<td><em>mouseout</em></td>
			<td><em>MouseEvent</em></td>
			<td>Fires when mouse pointer is moved off of the boundaries of an element. This event type is similar to <em>mouseleave</em>, but differs in that does bubble, and that it must be dispatched when the pointer device moves from an element onto the boundaries of one of its descendent elements</td>
			<td><em>Element</em>, <em>Document</em>, <em>window</em></td>
			<td>Yes</td>
			<td>Yes</td>
		</tr>
		<tr>
			<td><em>mouseup</em></td>
			<td><em>MouseEvent</em></td>
			<td>Fires when mouse pointer button is released over an element</td>
			<td><em>Element</em>, <em>Document</em>, <em>window</em></td>
			<td>Yes</td>
			<td>Yes</td>
		</tr>
		<tr>
			<td><em>mouseover</em></td>
			<td><em>MouseEvent</em></td>
			<td>Fires when mouse pointer is moved over an element</td>
			<td><em>Element</em>, <em>Document</em>, <em>window</em></td>
			<td>Yes</td>
			<td>Yes</td>
		</tr>
		
	</tbody>
</table>

<p><strong>Wheel events </strong></p>
 <table border="0" class="table table-bordered">
	<thead>
		<tr>
			<th>Event Type</th>
			<th>Event Interface</th>
			<th>Description</th>
			<th>Event Targets</th>
			<th>Bubbles</th>
			<th>Cancelable</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><em>wheel</em> (browsers use <em>mousewheel</em> but the specification uses <em>wheel</em>)</td>
			<td><em>WheelEvent</em></td>
			<td>Fires when a mouse wheel has been rotated around any axis, or when an equivalent input device (such as a mouse-ball, certain tablets or touchpads, etc.) has emulated such an action. Depending on the platform and input device, diagonal wheel deltas&#xA0;may&#xA0;be delivered either as a singlewheel&#xA0;event with multiple non-zero axes or as separate&#xA0;wheel&#xA0;events for each non-zero axis. Some helpful details about browser support can be found <a href="http://www.quirksmode.org/dom/events/scroll.html">here</a>.</td>
			<td><em>Element</em>, <em>Document</em>, <em>Window</em></td>
			<td>Yes</td>
			<td>Yes</td>
		</tr>
		
	</tbody>
</table>

<p><strong>Keyboard events </strong></p>
 <table border="0" class="table table-bordered">
	<thead>
		<tr>
			<th>Event Type</th>
			<th>Event Interface</th>
			<th>Description</th>
			<th>Event Targets</th>
			<th>Bubbles</th>
			<th>Cancelable</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><em>keydown</em></td>
			<td><em>KeyboardEvent</em></td>
			<td>Fires when a key is initially pressed. This is sent after any key mapping is performed, but before any input method editors receive the keypress. This is sent for any key, even if it doesn't generate a character code.</td>
			<td><em>Element</em>, <em>Document</em></td>
			<td>Yes</td>
			<td>Yes</td>
		</tr>
		<tr>
			<td><em>keypress</em></td>
			<td><em>KeyboardEvent</em></td>
			<td>Fires when a key is initially pressed, but only if that key normally produces a character value. This is sent after any key mapping is performed, but before any input method editors receive the keypress.</td>
			<td><em>Element</em>, <em>Document</em></td>
			<td>Yes</td>
			<td>Yes</td>
		</tr>
		<tr>
			<td><em>keyup</em></td>
			<td><em>KeyboardEvent</em></td>
			<td>Fires when a key is released. This is sent after any key mapping is performed, and always follows thecorresponding <em>keydown</em>&#xA0;and&#xA0;<em>keypress</em>&#xA0;events.</td>
			<td><em>Element</em>, <em>Document</em></td>
			<td>Yes</td>
			<td>Yes</td>
		</tr>
		
	</tbody>
</table>
 <p><strong>Touch events </strong></p>
 <table border="0" class="table table-bordered">
	<thead>
		<tr>
			<th>Event Type</th>
			<th>Event Interface</th>
			<th>Description</th>
			<th>Event Targets</th>
			<th>Bubbles</th>
			<th>Cancelable</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><em>touchstart</em></td>
			<td><em>TouchEvent</em></td>
			<td>Fires event to indicate when the user places a&#xA0;touch point&#xA0;on the touch surface</td>
			<td><em>Element</em>, <em>Document</em>, <em>window</em></td>
			<td>Yes</td>
			<td>Yes</td>
		</tr>
		<tr>
			<td><em>touchend</em></td>
			<td><em>TouchEvent</em></td>
			<td>Fires event to indicate when the user removes a&#xA0;touch poin<a href="http://www.w3.org/TR/2011/WD-touch-events-20110505/#dfn-touch-point">t</a>&#xA0;from the touch surface, also including cases where the touch point physically leaves the touch surface, such as being dragged off of the screen</td>
			<td><em>Element</em>, <em>Document</em>, <em>window</em></td>
			<td>Yes</td>
			<td>Yes</td>
		</tr>
		<tr>
			<td><em>touchmove</em></td>
			<td><em>TouchEvent</em></td>
			<td>Fires event to indicate when the user moves a&#xA0;touch point&#xA0;along the touch surface</td>
			<td><em>Element</em>, <em>Document</em>, <em>window</em></td>
			<td>Yes</td>
			<td>Yes</td>
		</tr>
		<tr>
			<td><em>touchenter</em></td>
			<td><em>TouchEvent</em></td>
			<td>Fires event to indicate when a&#xA0;touch point&#xA0;moves onto the interactive area defined by a DOM element</td>
			<td><em>Element</em>, <em>Document</em>, <em>window</em></td>
			<td>No</td>
			<td>?</td>
		</tr>
		<tr>
			<td><em>toucheleave</em></td>
			<td><em>TouchEvent</em></td>
			<td>Fires event to indicate when a&#xA0;touch point&#xA0;moves off the interactive area defined by a DOM element</td>
			<td><em>Element</em>, <em>Document</em>, <em>window</em></td>
			<td>No</td>
			<td>?</td>
		</tr>
		<tr>
			<td><em>touchcancel</em></td>
			<td><em>TouchEvent</em></td>
			<td>Fires event to indicate when a touch point has been disrupted in an implementation-specific manner, such as a synchronous event or action originating from the UA canceling the touch, or the touch point leaving the document window into a non-document area which is capable of handling user interactions.</td>
			<td><em>Element</em>, <em>Document</em>, <em>window</em></td>
			<td>Yes</td>
			<td>No</td>
		</tr>
		
	</tbody>
</table>

 <div class="notes">
 <h3>Notes</h3>
 <p>Touch events are typically only supported iOS, Andorid, and Blackberry browsers or browsers (e.g. chrome) that can switch on touch modes</p>
 </div>

<p><strong>Window, <em>&lt;body&gt;</em>, and frame specific events </strong></p>
 <table border="0" class="table table-bordered">
	<thead>
		<tr>
			<th>Event Type</th>
			<th>Event Interface</th>
			<th>Description</th>
			<th>Event Targets</th>
			<th>Bubbles</th>
			<th>Cancelable</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><em>afterprint</em></td>
			<td>?</td>
			<td>Fires on the object immediately after its associated document prints or previews for printing</td>
			<td><em>window</em>, <em>&lt;body&gt;</em>, <em>&lt;frameset&gt;</em></td>
			<td>No</td>
			<td>No</td>
		</tr>
		<tr>
			<td><em>beforeprint</em></td>
			<td>?</td>
			<td>Fires on the object before its associated document prints or previews for printing</td>
			<td><em>window</em>, <em>&lt;body&gt;</em>, <em>&lt;frameset&gt;</em></td>
			<td>No</td>
			<td>No</td>
		</tr>
		<tr>
			<td><em>beforeunload</em></td>
			<td>?</td>
			<td>Fires prior to a document being unloaded</td>
			<td><em>window</em>, <em>&lt;body&gt;</em>, <em>&lt;frameset&gt;</em></td>
			<td>No</td>
			<td>Yes</td>
		</tr>
		<tr>
			<td><em>hashchange</em></td>
			<td><em>HashChangeEvent</em></td>
			<td>Fires when there are changes to the portion of a URL that follows the number sign (#)</td>
			<td><em>window</em>, <em>&lt;body&gt;</em>, <em>&lt;frameset&gt;</em></td>
			<td>No</td>
			<td>No</td>
		</tr>
		<tr>
			<td><em>messsage</em></td>
			<td>?</td>
			<td>Fires when the user sends a cross-document message or a message is sent from a&#xA0;<em>Worker</em>&#xA0;with&#xA0;<em>postMessage</em></td>
			<td><em>window</em>, <em>&lt;body&gt;</em>, <em>&lt;frameset&gt;</em></td>
			<td>No</td>
			<td>No</td>
		</tr>
		<tr>
			<td><em>offline</em></td>
			<td><em>NavigatorOnLine</em></td>
			<td>Fires when browser is working offline</td>
			<td><em>window</em>, <em>&lt;body&gt;</em>, <em>&lt;frameset&gt;</em></td>
			<td>No</td>
			<td>No</td>
		</tr>
		<tr>
			<td><em>online</em></td>
			<td><em>NavigatorOnLine</em></td>
			<td>Fires when browser is working online</td>
			<td><em>window</em>, <em>&lt;body&gt;</em>, <em>&lt;frameset&gt;</em></td>
			<td>No</td>
			<td>No</td>
		</tr>
		<tr>
			<td><em>pagehide</em></td>
			<td><em>PageTransitionEvent</em></td>
			<td>Fires when traversing&#xA0;from&#xA0;a&#xA0;session history entry</td>
			<td><em>window</em>, <em>&lt;body&gt;</em>, <em>&lt;frameset&gt;</em></td>
			<td>No</td>
			<td>No</td>
		</tr>
		<tr>
			<td><em>pageshow</em></td>
			<td><em>PageTransitionEvent</em></td>
			<td>The&#xA0;pagehide&#xA0;event is fired when traversing&#xA0;from&#xA0;a&#xA0;session history entry</td>
			<td><em>window</em>, <em>&lt;body&gt;</em>, <em>&lt;frameset&gt;</em></td>
			<td>No</td>
			<td>No</td>
		</tr>	
	</tbody>
</table>

<p><strong>Document specific events</strong></p>
 <table border="0" class="table table-bordered">
	<thead>
		<tr>
			<th>Event Type</th>
			<th>Event Interface</th>
			<th>Description</th>
			<th>Event Targets</th>
			<th>Bubbles</th>
			<th>Cancelable</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><em>readystatechange</em></td>
			<td><em>Event</em></td>
			<td>Fires&#xA0;event when <em>readyState</em>&#xA0;is changed</td>
			<td><em>Document</em>, <em>XMLHttpRequest</em></td>
			<td>No</td>
			<td>No</td>
		</tr>
		<tr>
			<td><em>DOMContentLoaded</em></td>
			<td><em>Event</em></td>
			<td>Fires when a webpage has been parsed, but before all resources have been fully downloaded</td>
			<td><em>Document</em></td>
			<td>Yes</td>
			<td>No</td>
		</tr>
	</tbody>
</table>

<p><strong>Drag events </strong></p>
 <table border="0" class="table table-bordered">
	<thead>
		<tr>
			<th>Event Type</th>
			<th>Event Interface</th>
			<th>Description</th>
			<th>Event Targets</th>
			<th>Bubbles</th>
			<th>Cancelable</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><em>drag</em></td>
			<td><em>DragEvent</em></td>
			<td>Fires on the source object continuously during a drag operation. </td>
			<td><em>Element</em>, <em>Document</em>, <em>window</em></td>
			<td>Yes</td>
			<td>Yes</td>
		</tr>
		<tr>
			<td><em>dragstart</em></td>
			<td><em>DragEvent</em></td>
			<td>Fires on the source object when the user starts to drag a text selection or selected object. The&#xA0;ondragstart&#xA0;event is the first to fire when the user starts to drag the mouse.</td>
			<td><em>Element</em>, <em>Document</em>, <em>window</em></td>
			<td>Yes</td>
			<td>Yes</td>
		</tr>
		<tr>
			<td><em>dragend</em></td>
			<td><em>DragEvent</em></td>
			<td>Fires on the source object when the user releases the mouse at the close of a drag operation. The ondragend event is the final drag event to fire, following the ondragleave event, which fires on the target object.</td>
			<td><em>Element</em>, <em>Document</em>, <em>window</em></td>
			<td>Yes</td>
			<td>No</td>
		</tr>	
		<tr>
			<td><em>dragenter</em></td>
			<td><em>DragEvent</em></td>
			<td>Fires on the target element when the user drags the object to a valid drop target.</td>
			<td><em>Element</em>, <em>Document</em>, <em>window</em></td>
			<td>Yes</td>
			<td>Yes</td>
		</tr>	
		<tr>
			<td><em>dragleave</em></td>
			<td><em>DragEvent</em></td>
			<td>Fires on the target object when the user moves the mouse out of a valid drop target during a drag operation.</td>
			<td><em>Element</em>, <em>Document</em>, <em>window</em></td>
			<td>Yes</td>
			<td>No</td>
		</tr>	
		<tr>
			<td><em>dragover</em></td>
			<td><em>DragEvent</em></td>
			<td>Fires on the target element continuously while the user drags the object over a valid drop target. The&#xA0;ondragover&#xA0;event fires on the target object after the&#xA0;ondragenter&#xA0;event has fired.</td>
			<td><em>Element</em>, <em>Document</em>, <em>window</em></td>
			<td>Yes</td>
			<td>Yes</td>
		</tr>	
		<tr>
			<td><em>drop</em></td>
			<td><em>DragEvent</em></td>
			<td>Fires on the target object when the mouse button is released during a drag-and-drop operation. The ondrop event fires before the ondragleave and ondragend events.</td>
			<td><em>Element</em>, <em>Document</em>, <em>window</em></td>
			<td>Yes</td>
			<td>Yes</td>
		</tr>	
	</tbody>
</table>
<div class="notes">
 <h3>Notes</h3>
 <p>The tables below were crafted from the following three resources <a href="http://www.w3.org/TR/DOM-Level-3-Events/#events-module">Document Object Model (DOM) Level 3 Events Specification 5 User Event Module</a>, <a href="https://developer.mozilla.org/en/DOM/DOM_event_reference">DOM event reference</a>, <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/webappapis.html#events">HTML Living Standard 7.1.6 Event handlers on elements, Document objects, and Window objects,</a>, and <a href="http://www.quirksmode.org/dom/events/">Event compatibility tables</a>.</p>
 <p>I've only mentioned here in this section the most common event types. Keep in mind there are numerous HTML5 api's that I've excluded from the this section (e.g. <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#event-definitions">media events</a> for <em>&lt;video&gt;</em> and <em>&lt;audio&gt;</em> elements or all state change events for the <a href="http://www.w3.org/TR/XMLHttpRequest/#event-handlers">XMLHttpRequest Level 2</a>).</p>
 <p>The <em>copy</em>, <em>cut</em>, and <em>textinput</em> event are not defined by DOM 3 events or HTML5</p>
 <p>Use mouseenter and mouseleave instead of mouseover and mouseout. Unfortunately Firefox, Chrome, and Safari still haven&#x2019;t added these events!</p>
 </div>
 <h2>11.3 The event flow</h2>
 <p>When an event is invoked the <a href="http://www.w3.org/TR/DOM-Level-3-Events/#dom-event-architecture">event flows or propagates through the DOM</a>, firing the same event on other nodes and JavaScript objects. The event flow can be programmed to occur as a capture phase (i.e. DOM tree trunk to branch) or bubbling phase (i.e. DOM tree branches to trunk), or both.</p>
 <p>In the code below I set up 10 event listeners that can all be invoked, due to the event flow, by clicking once on the <em>&lt;div&gt;</em> element in the HTML document. When the <em>&lt;div&gt;</em> is clicked the capture phase begins at the <em>window</em> object and propagates down the DOM tree firing the <em>click</em> event for each object (i.e. <em>window</em> <strong>&gt;</strong> <em>document</em> <strong>&gt;</strong> <em>&lt;html&gt;</em><strong> &gt; </strong><em>&lt;body&gt;</em><strong> &gt;</strong> event target) until it hits the event target. Once the capture phase ends the target phase starts, firing the <em>click</em> event on the target element itself. Next the propagation phase propagates up from the event target firing the <em>click</em> event until it reaches the <em>window</em> object (i.e. event target <strong>&gt;</strong> <em>&lt;body&gt;</em> <strong>&gt;</strong> <em>&lt;html&gt;</em> <strong>&gt;</strong> <em>document</em> <strong>&gt;</strong> <em>window</em>). With this knowledge it should be obvious why clicking the <em>&lt;div&gt;</em> in the code example logs to the console 1,2,3,4,5,6,7,8,9,11.</p>
 
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;div&gt;click me to start event flow&lt;/div&gt;

&lt;script&gt;

<em>/*notice that I am passing the addEventListener() a boolean parameter of true so capture events fire, not just bubbling events*/</em>

<em>//1 capture phase</em>
window.addEventListener('click',function(){console.log(<strong>1</strong>);},true);

<em>//2 capture phase</em>
document.addEventListener('click',function(){console.log(<strong>2</strong>);},true);

<em>//3</em><em> capture phase</em>
document.documentElement.addEventListener('click',function(){console.log(<strong>3</strong>);},true);

<em>//4</em><em> capture phase</em>
document.body.addEventListener('click',function(){console.log(<strong>4</strong>);},true);

<em>//5 target phase occurs during capture phase</em>
document.querySelector('div').addEventListener('click',function(){console.log(<strong>5</strong>);},true);

<em>//6 target phase occurs during bubbling phase</em>
document.querySelector('div').addEventListener('click',function(){console.log(<strong>6</strong>);},false);

<em>//7 bubbling phase</em>
document.body.addEventListener('click',function(){console.log(<strong>7</strong>);},false);

<em>//8</em> <em>bubbling phase</em>
document.documentElement.addEventListener('click',function(){console.log(<strong>8</strong>);},false);

<em>//9</em> <em>bubbling phase</em>
document.addEventListener('click',function(){console.log(<strong>9</strong>);},false);

<em>//10</em> <em>bubbling phase</em>
window.addEventListener('click',function(){console.log(<strong>10</strong>)},false);

&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;
</pre>
 <p>After the <em>&lt;div&gt;</em> is clicked, the event flow proceeds in this order: </p>
 <ol>
 	<li>capture phase invokes click events on window that are set to fire on capture</li>
 	<li>capture phase invokes click events on document that are set to fire on capture</li>
 	<li>capture phase invokes click events on html element that are set to fire on capture</li>
 	<li>capture phase invokes click events on body element that are set to fire on capture</li>
 	<li>target phase invokes click events on div element that are set to fire on capture</li>
 	<li>target phase invokes click events on div element that are set to fire on bubble</li>
 	<li>bubbling phase invokes click events on body element are set to fire on bubble</li>
 	<li>bubbling phase invokes click events on html element are set to fire on bubble</li>
 	<li>bubbling phase invokes click events on document are set to fire on bubble</li>
 	<li>bubbling phase invokes click events on window are set to fire on bubble</li>
 </ol>
 <p>The use of the capture phase is not all that common due to a lack of browser support for this phase. Typically events are assumed to be inovked during the bubbling phase. In the code below I remove the capture phase from the previous code example and demostrate typically what is occuring during an event invocation.</p>
 
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;div&gt;click me to start event flow&lt;/div&gt;

&lt;script&gt;

<em>//1 target phase occurs during bubbling phase</em>
document.querySelector('div').addEventListener('click',function(){console.log(<strong>1</strong>);},false);

<em>//2</em> <em>bubbling phase</em>
document.body.addEventListener('click',function(){console.log(<strong>2</strong>);},false);

<em>//3</em> <em>bubbling phase</em>
document.documentElement.addEventListener('click',function(){console.log(<strong>3</strong>);},false);

<em>//4</em> <em>bubbling phase</em>
document.addEventListener('click',function(){console.log(<strong>4</strong>);},false);

<em>//5</em> <em>bubbling phase</em>
window.addEventListener('click',function(){console.log(<strong>5</strong>)},false);

&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;
</pre>
 <p>Notice in the last code example that if the click event is initiated (click anywhere except on the <em>&lt;div&gt;</em>) on the <em>&lt;body&gt;</em> element the click event attached to the <em>&lt;div&gt;</em> is not invoked and bubbling invocation starts on the <em>&lt;body&gt;</em>. This is due to the fact the the event target is no longer the <em>&lt;div&gt;</em> but instead the <em>&lt;body&gt;</em> element.</p>
 <div class="notes">
 <h3>Notes</h3>
 <p>Modern browsers do support the use of the capture phase so what was once considered unreliable might just server some value today. For example, one could intercept an event before it occurs on the event target.</p>
 <p>Keep this knowledge of event capturing and bubbling at the forefront of your thoughts when you read the event delegation section of this chapter.</p>
 <p>The event object passed to event listener functions contains a <em>eventPhase</em> property containing a number which indicates which phase an event is inoked in. A value of 1 indicates the capture phase. A value of 2 indicates the target phase. And a value of 3 indicates bubbling phase.</p>
 </div>
<h2>11.4 Adding event listeners to <em>Element</em> nodes, <em>window</em> object, and <em>Document</em> object</h2>
<p>The <em>addEventListener()</em> method is avaliabe on all <em>Element</em> nodes, the <em>window</em> object, and the <em>document</em> object providing the ability to added event listeners to parts of an HTML document as well as JavaScript objects relating to the DOM and <a href="https://developer.mozilla.org/en-US/docs/DOM/window">BOM</a> (browser object model). In the code below I leverage this method to add a <em>mousemove</em> event to a <em>&lt;div&gt;</em> element, the <em>document</em> object, and the <em>window</em> object. Notice, due to the event flow, that mouse movement specifically over the <em>&lt;div&gt;</em> will invoke all three listeners each to time a movement occurs.</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;body&gt;

&lt;div&gt;mouse over me&lt;/div&gt;

&lt;script&gt;

<em>//add a mousemove event to the window object, invoking the event during the bubbling phase</em>
window.<strong>addEventListener</strong>('mousemove',function(){console.log('moving over window');},false);

<em>//add a mousemove event to the document object, invoking the event during the bubbling phase</em>
document.<strong>addEventListener</strong>('mousemove',function(){console.log('moving over document');},false);

<em>//add a mousemove event to a &lt;div&gt; element object, invoking the event during the bubbling phase</em>
document.querySelector('div').<strong>addEventListener</strong>('mousemove',function(){console.log('moving over div');},false);

&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;
</pre>

<p>The <em>addEventListener()</em> method used in the above code example takes three arguments. The first argument is the type of event to listen for. Notice that the event type string does not contain the "on" prefix (i.e. <em>onmousemove</em>) that event handlers require. The second argument is the function to be invoked when the event occurs. The third parameter is a boolean indicating if the event should be fired during the capture phase or bubbling phase of the event flow.</p>
<div class="notes">
 <h3>Notes</h3>
 <p>I've purposfully avoided dicussing inline event handlers &amp; property event handlers in favor of promoting the use of <em>addEventListener()</em></p>
 <p>Typically a developer wants events to fire during the bubbling phase so that object eventing handles the event before bubbling the event up the DOM. Because of this you almost always provide a <em>false</em> value as the last argument to the <em>addEventListener()</em>. In modern browsers if the 3rd parameter is not specified it will default to false.</p>
 <p>You should be aware that the <em>addEventListener()</em> method can be used on the <em>XMLHttpRequest</em> object</p>
 </div>
<h2>11.5 Removing event listeners</h2>
<p>The <em>removeEventListener()</em> method can be used to remove events listeners, if the orginal listener was not added using an anonymous function. In the code below I add two events listeners to the HTML document and attempt to remove both of them. However, only the listener that was attached using a function reference is removed.</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;div&gt;click to say hi&lt;/div&gt;

&lt;script&gt;

var sayHi = function(){console.log('hi')};

<em>//adding event listener using anonymous function</em>
document.body.addEventListener('click',function(){console.log('dude');},false);

<em>//adding event listener using function reference</em>
document.querySelector('div').addEventListener('click',sayHi,false);

<em>//attempt to remove both event listeners, but only the listener added with a funtions reference is removed</em>
document.querySelector('div').<strong>removeEventListener</strong>('click',sayHi,false);

<em>//this of course does not work as the function passed to removeEventListener is a new and different function</em>
document.body.<strong>removeEventListener</strong>('click',function(){console.log('dude');},false);

<em>//clicking the div will still invoke the click event attached to the body element, this event was not removed</em>

&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>Anonymous functions added using <em>addEventListener()</em> method simply cannot be removed.</p>

<h2>11.6 Getting event properties from the event object</h2>
<p>The handler or callback function invoked for events is sent by default a parameter that contains all relevant information about an event itself. In the code below I demostrate access to this event object and log all of its properties and values for a load event as well as a click event. Make sure you click the <em>&lt;div</em>&gt; to see the properties assocaited with a click event.</p>


<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;div&gt;click me&lt;/div&gt;

&lt;script&gt;

document.querySelector('div').addEventListener('click',function(<strong>event</strong>){<br>Object.keys(<strong>event</strong>).sort().forEach(function(item){<br>&#xA0; &#xA0; &#xA0;console.log(item+' = '+<strong>event</strong>[item]); <em>//logs event propeties and values</em><br>});&#xA0; &#xA0;&#xA0;&#xA0;<br>},false);

<em>//assumes 'this' is window</em>
this.addEventListener('load',function(<strong>event</strong>){<br>Object.keys(<strong>event</strong>).sort().forEach(function(item){<br>&#xA0; &#xA0; &#xA0;console.log(item+' = '+<strong>event</strong>[item]); <em>//logs event propeties and values</em><br>});&#xA0; &#xA0;&#xA0;&#xA0;<br>},false);

&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>Keep in mind that each event will contain slightly different properties based on the event type (e.g. <a href="https://developer.mozilla.org/en/DOM/MouseEvent">MouseEvent</a>, <a href="https://developer.mozilla.org/en/DOM/KeyboardEvent">KeyboardEvent</a>, <a href="https://developer.mozilla.org/en/DOM/WheelEvent">WheelEvent</a>).</p>
 <div class="notes">
 <h3>Notes</h3>
 <p>The event object also provides the<em> stopPropagation()</em>, <em>stopImediatePropagation()</em>, and <em>preventDefault()</em> methods.</p>
 <p>In this book I use the argument name <em>event</em> to reference the event object. In truth you can use any name you like and its not uncommon to see <em>e</em> or <em>evt</em>. </p>
 </div>
 <h2>11.7 The value of <em>this</em> when using <em>addEventListener()</em></h2>
<p>The value of <em>this</em> inside of the event listener function passed to the <em>addEventListener()</em> method will be a reference to the node or object the event is attached too. In the code below I attach an event to a <em>&lt;div&gt;</em> and then using <em>this</em> inside of the event listener gain access to the <em>&lt;div&gt;</em> element the event is attached too.</p>


<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;div&gt;click me&lt;/div&gt;

&lt;script&gt;

document.querySelector('div').addEventListener('click',function(){
<em>// 'this' will be the element or node the event listener is attached too</em>
console.log(<strong>this</strong>); <em>//logs '&lt;div&gt;' </em>
},false);

&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>When events are invoked as part of the event flow the <em>this</em> value will remain the value of the node or object that the event listener is attached too. In the code below we add a <em>click</em> event listener to the <em>&lt;body&gt;</em> and regardless of if you click on the <em>&lt;div&gt;</em> or the <em>&lt;body&gt;</em> the value of <em>this</em> always points to <em>&lt;body&gt;</em>.</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;div&gt;click me&lt;/div&gt;

&lt;script&gt;

<em>//click on the &lt;div&gt; or the &lt;body&gt; the value of this remains the &lt;body&gt; element node</em>
document.body.addEventListener('click',function(){
console.log(<strong>this</strong>); <em>//log &lt;body&gt;...&lt;/body&gt;</em>
},false);

&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>Additionally its possible using the <em>event.currentTarget</em> property to get the same reference, to the node or object invoking the event listener, that the <em>this</em> property provides. In the code below I leverage the<em> event.currentTarget</em> event object property showcasing that it returns the same value as <em>this</em>.</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;div&gt;click me&lt;/div&gt;

&lt;script&gt;

document.addEventListener('click',function(event){
console.log(<strong>event.currentTarget</strong>); <em>//logs '#document'
//same as...
</em>console.log(this);
},false);

document.body.addEventListener('click',function(event){
console.log(<strong>event.currentTarget</strong>); <em>//logs '&lt;body&gt;'
//same as...
</em>console.log(this);
},false);

document.querySelector('div').addEventListener('click',function(event){
console.log(<strong>event.currentTarget</strong>); <em>//logs '&lt;div&gt;'</em>
<em>//same as...</em>
console.log(this);
},false);

&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;
</pre>
<h2>11.8 Referencing the <em>target</em> of an event and not the node or object the event is invoked on</h2>
<p>Because of the event flow its possible to click a <em>&lt;div&gt;</em>, contained inside of a <em>&lt;body&gt;</em> element and have a <em>click</em> event listener attached to the <em>&lt;body&gt;</em> element get invoked. When this happens, the event object passed to the event listener function attached to the <em>&lt;body&gt;</em> provides a reference (i.e. <em>event.target</em>) to the node or object that the event originated on (i.e. the target). In the code below when the <em>&lt;div&gt;</em> is clicked, the <em>&lt;body&gt;</em> element's <em>click</em> event listener is invoked and the <em>event.target</em> property references the orginal <em>&lt;div&gt;</em> that was the target of the click event. The <em>event.target</em> can be extremely useful when an event that fires because of the event flow needs knowledge about the origin of the event.</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;div&gt;click me&lt;/div&gt;

&lt;script&gt;

document.body.addEventListener('click',function(event){
<em>//when the &lt;div&gt; is clicked logs '&lt;div&gt;' because the &lt;div&gt; was the target in the event flow</em>
console.log(<strong>event.target</strong>); 
},false);

&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>Consider that in our code example if the <em>&lt;body&gt;</em> element is clicked instead of the <em>&lt;div&gt;</em> then the event <em>target</em> and the element node that the event listener is invoked on are the same. Therefore <em>event.target</em>, <em>this</em>, and <em>event.currentTarget</em> will all contain a reference to the <em>&lt;body&gt;</em> element.</p>

<h2>11.9 Cancelling default browser events using <em>preventDefault()</em></h2>
<p>Browsers provide several events already wired up when an HTML page is presented to a user. For example, clicking a link has a corresponding event (i.e. you navigate to a url). So does clicking a checkbox (i.e. box is checked) or typing text into a text field (i.e. text is inputed and appears on screen). These browser events can be prevented by calling the <em>preventDefault()</em> method inside of the event handler function associated with a node or object that invokes a browser default event. In the code below I prevent the default event that occurs on a <em>&lt;a&gt;</em>, <em>&lt;input&gt;</em>, and <em>&lt;textarea&gt;</em>.</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;a href="google.com"&gt;no go&lt;/div&gt;

&lt;input type="checkbox" /&gt;

&lt;textarea&gt;&lt;/textarea&gt;

&lt;script&gt;

document.querySelector('a').addEventListener('click',function(event){
event.<strong>preventDefault()</strong>; <em>//stop the default event for &lt;a&gt; which would be to load a url</em>
},false);

document.querySelector('input').addEventListener('click',function(event){
event.<strong>preventDefault</strong>(); <em>//stop default event for checkbox, which would be to toggle checkbox state</em>
},false);

document.querySelector('textarea').addEventListener('keypress',function(event){
event.<strong>preventDefault</strong>(); <em>//stop default event for textarea, which would be to add characters typed</em>
},false);

<em>/*keep in mind that events still propagate, clicking the link in this html document will stop the default event but not event bubbling*/</em>
document.body.addEventListener('click',function(){<br>console.log('the event flow still flows!');<br>},false);

&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;
</pre>

<p>All attempts to click the link, check the box, or type in the text input in the previous code example will fail because I am preventing the default events for these elements from occuring.</p>
<div class="notes">
 <h3>Notes</h3>
 <p>The <em>preventDefault()</em> methods does not stop events from propagating (i.e. bubbling or capture phases)</p>
 <p>Providing a <em>return false</em> at the end of the body of the event listener has the same result as call the <em>preventDefault()</em> method</p>
 <p>The event object passed to event listener functions contains a boolean <em>cancelable</em> property which indicates if the event will respond to preveentDefault() method and canceling default behavior</p>
 <p>The event object passed to event listener functions contains a <em>defaultPrevented</em> property which indicates true if <em>preventDefault()</em> has been invoked for a bubbling event.</p>
 </div>

<h2>11.10 Stoping the event flow using <em>stopPropagation()</em></h2>
<p>Calling <em>stopProgagation()</em> from within an event handler/listener will stop the capture and bubble event flow phases, but any events directly attached to the node or object will still be invoked. In the code below the <em>onclick</em> event attached to the <em>&lt;body&gt;</em> is never gets invoked because we are stopping the event from bubbling up the DOM when clicking on the <em>&lt;div&gt;</em>. </p>


<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;div&gt;click me&lt;/div&gt;

&lt;script&gt;

document.querySelector('div').addEventListener('click',function(){
console.log('me too, but nothing from the event flow!');
},false);

document.querySelector('div').addEventListener('click',function(event){
console.log('invoked all click events attached, but cancel capture and bubble event phases');
event.<strong>stopPropagation()</strong>;
},false);

document.querySelector('div').addEventListener('click',function(){
console.log('me too, but nothing from the event flow!');
},false);

<em>/*when the &lt;div&gt; is clicked this event is not invoked because one of the events attached to the &lt;div&gt; stops the capture and bubble flow.*/</em>
document.body.addEventListener('click',function(){<br>console.log('What, denied from being invoked!');<br>},false);

&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>Notice that other click events attached to the the <em>&lt;div&gt;</em> still get invoked! Additionally using <em>stopPropagation()</em> does not prevent default events. Had the <em> &lt;div&gt;</em> in our code example been a <em>&lt;a&gt;</em> with an href value calling stopPropagation would not have stopped the browser default events from getting invoked.</p>

<h2>11.11 Stoping the event flow as well as other like events on the same target using <em>stopImmediatePropagation()</em></h2>
<p>Calling the <em>stopImmediatePropagation()</em> from within an event handler/listener will stop the event flow phases (i.e. <em>stopPropagation()</em>), as well as any other like events attached to the event target that are attached after the event listener that invokes the <em>stopImmediatePropagation()</em> method. In the code example below If we call <em>stopImmediatePropagation()</em>from the second event listener attached to the <em>&lt;div&gt;</em> the click event that follows will not get invoked.</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;div&gt;click me&lt;/div&gt;

&lt;script&gt;

<em>//first event attached</em>
document.querySelector('div').addEventListener('click',function(){
console.log('I get invoked because I was attached first');
},false);

<em>//seond event attached</em>
document.querySelector('div').addEventListener('click',function(event){
console.log('I get invoked, but stop any other click events on this target');
event.<strong>stopImmediatePropagation()</strong>;
},false);
<em>
//third event attached, but because stopImmediatePropagation() was called above this event does not get invoked</em>
document.querySelector('div').addEventListener('click',function(){
console.log('I get stopped from the previous click event listener');
},false);

<em>//notice that the event flow is also cancelled as if stopPropagation was called too</em>
document.body.addEventListener('click',function(){<br>console.log('What, denied from being invoked!');<br>},false);

&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;
</pre>
<div class="notes">
 <h3>Notes</h3>
 <p>Using the <em>stopImmediatePropagation()</em> does not prevent default events. Browser default events still get invoked and only calling <em>preventDefault()</em> will stop these events.</p>
 </div>
<h2>11.12 Custom events</h2>
<p>A developer is not limited to the predefined event types. Its possible to attach and invoke a custom event, using the <em>addEventListener()</em> method like normal in combiniation with <em>document.createEvent()</em>, <em>initCustomEvent()</em>, and <em>dispatchEvent()</em>. In the code below I create a custom event called <em>goBigBlue</em> and invoke that event<em>.</em></p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;div&gt;click me&lt;/div&gt;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;

&lt;script&gt;

var&#xA0;divElement&#xA0;=&#xA0;document.querySelector('div');<p><em>//create the custom event</em><br>var&#xA0;cheer&#xA0;=&#xA0;document.<strong>createEvent('CustomEvent')</strong>; <em>//the 'CustomEvent' parameter is required</em></p><p><em>//create an event listener for the custom event</em><br>divElement.addEventListener('goBigBlue',function(event){<br>&#xA0; &#xA0;&#xA0;console.log(event.detail.goBigBlueIs)<br>},false);</p><p><em>/*Use the initCustomEvent method to setup the details of the custom event.
Parameters for initCustomEvent are: (event, bubble?, cancelable?, pass values to event.detail)*/</em><br>cheer.<strong>initCustomEvent('goBigBlue',true,false,{goBigBlueIs:'its gone!'})</strong>;<br>&#xA0; &#xA0;&#xA0;<em><br>//invoke the custom event using dispatchEvent</em><br>divElement.<strong>dispatchEvent(cheer)</strong>;&#x200B;<br>
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;
</p></pre>

<h2>11.13 Simulating/Triggering mouse events</h2>
<p>Simiulating an event is not unlike creating a custom event. In the case of simulating a mouse event we create a <em>'MouseEvent'</em> using <em>document.createEvent()</em>. Then, using <em>initMouseEvent()</em> we setup the mouse event that is going to occur. Next the mouse event is dispatched on the element that we'd like to simulate an event on (i.e the <em>&lt;div&gt;</em> in the html document). In the code below a click event is attached to the <em>&lt;div&gt;</em> in the page. Instead of clicking the <em>&lt;div&gt;</em> to invoke the click event the event is triggered or simulated by programatically setting up a mouse event and dispatching the event to the <em>&lt;div&gt;</em>.</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;div&gt;no need to click, we programatically trigger it&lt;/div&gt;&#x200B;&#x200B;&#x200B;&#x200B;

&lt;script&gt;

var&#xA0;divElement&#xA0;=&#xA0;document.querySelector('div');

<em>//setup click event that will be simulated</em><br>divElement.addEventListener('click',function(event){<br>&#xA0; &#xA0;&#xA0;console.log(Object.keys(event));<br>},false);<p><em>//create simulated mouse event 'click'</em><br>var&#xA0;simulateDivClick&#xA0;=&#xA0;document.<strong>createEvent('MouseEvents')</strong>;
<br><em>/*setup simulated mouse 'click'
initMouseEvent(type,bubbles,cancelable,view,detail,screenx,screeny,clientx,clienty,ctrlKey,altKey,shiftKey,metaKey,button,relatedTarget)*</em>
simulateDivClick.<strong>initMouseEvent('click',true,true,document.defaultView,0,0,0,0,0,false,false,false,0,null,null)</strong>;
<br><em>//invoke simulated clicked event</em><br>divElement.<strong>dispatchEvent(simulateDivClick)</strong>;</p><p>&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;
</p></pre>
<div class="notes">
 <h3>Notes</h3>
 <p>Simulating/triggering mouse events as of this writing works in all modern browsers. Simulating other event types quickly becomes more complicated and leveraging <a href="https://github.com/airportyh/simulate.js">simulate.js</a> or jQuery (e.g. jQuery <em>trigger()</em> method) becomes neccsary.</p>
</div>
<h2>11.14 Event delegation</h2>
<p>Event delegation, stated simply, is the programmatic act of leveraging the event flow and a single event listener to deal with multiple event targets. A side effect of event delegation is that the event targets don't have to be in the DOM when the event is created in order for the targets to respond to the event. This is of course rather handy when dealing with XHR responses that update the DOM. By implementing event delegation new content that is added to the DOM post JavaScript load parsing can immediately start responding to events. Imagine you have a table with an unlimited number of rows and columns. Using event delegation we can add a single event listener to the <em>&lt;table&gt;</em> node which acts as a delegate for the node or object that is the initial target of the event. In the code example below, clicking any of the <em>&lt;td&gt;</em>'s (i.e. the target of the event) will delegate its event to the <em>click</em> listener on the <em>&lt;table&gt;</em>. Don't forget this is all made possible because of the event flow and in this specific case the bubbling phase.</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;

&lt;p&gt;Click a table cell&lt;/p&gt;

&lt;table&#xA0;border="1"&gt;<br>&#xA0; &#xA0;&#xA0;&lt;tbody&gt;<br>&#xA0; &#xA0; &#xA0; &#xA0;&#xA0;&lt;tr&gt;&lt;td&gt;row 1 column 1&lt;/td&gt;&lt;td&gt;row 1 column 2&lt;/td&gt;&lt;/tr&gt;<br>&#xA0; &#xA0; &#xA0; &#xA0;&#xA0;&lt;tr&gt;&lt;td&gt;row 2 column 1&lt;/td&gt;&lt;td&gt;row 2 column 2&lt;/td&gt;&lt;/tr&gt;<br>&#xA0; &#xA0; &#xA0; &#xA0;&#xA0;&lt;tr&gt;&lt;td&gt;row 3 column 1&lt;/td&gt;&lt;td&gt;row 3 column 2&lt;/td&gt;&lt;/tr&gt;<br>&#xA0; &#xA0; &#xA0; &#xA0;&#xA0;&lt;tr&gt;&lt;td&gt;row 4 column 1&lt;/td&gt;&lt;td&gt;row 4 column 2&lt;/td&gt;&lt;/tr&gt;<br>&#xA0; &#xA0; &#xA0; &#xA0;&#xA0;&lt;tr&gt;&lt;td&gt;row 5 column 1&lt;/td&gt;&lt;td&gt;row 5 column 2&lt;/td&gt;&lt;/tr&gt;<br>&#xA0; &#xA0; &#xA0; &#xA0;&#xA0;&lt;tr&gt;&lt;td&gt;row 6 column 1&lt;/td&gt;&lt;td&gt;row 6 column 2&lt;/td&gt;&lt;/tr&gt;<br>&#xA0; &#xA0;&#xA0;&lt;/tbody&gt;<br>&lt;/table&gt;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;

&lt;script&gt;

<strong>document.querySelector('table').addEventListener('click',function(event){</strong>
	if(event.target.tagName.toLowerCase() === 'td'){ <em>//make sure we only run code if a td is the target</em><br>		console.log(event.target.textContent); <em>//use event.target to gain access to target of the event which is the td</em>&#xA0;
	} &#xA0; &#xA0; &#xA0;<br><strong>},false);</strong><br>
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>If we were to update the table in the code example with new rows, the new rows would responded to the <em>click</em> event as soon as they were render to the screen because the click event is delegated to the <em>&lt;table&gt;</em> element node.</p>
<div class="notes">
 <h3>Notes</h3>
 <p>Event delegation is ideally leverage when you are dealing with a <em>click</em>, <em>mousedown</em>, <em>mouseup</em>, <em>keydown</em>, <em>keyup</em>, and <em>keypress</em> event type. </p>
</div>
 
</div>




<div id="chapter12" class="chapter">


 <h2>Chapter 12 - Creating dom.js - a wishful jQuery inspired DOM Library for modern browers</h2>
 <h2>12.1 dom.js overview</h2>
 <p>I want you to take the information and knowledge from this book and leverage it as I walk you through a foundation for a wishful, modern, jQuery like DOM library called dom.js. Think of dom.js as the foundation to a modern library for selecting DOM nodes and doing something with them. Not unlike jQuery the dom.js code will provide a function for selecting something from the DOM (or creating) and then doing something with it. I show some examples of the <em>dom()</em> function below which shouldn't look all that foreign if you are familiar with jQuery or really any DOM utility for selecting elements.</p>
 <pre>
<em>//select in a document all li's in the first ul and get the innerHTML for the first li</em>
dom('li','ul').html();

<em>//create html structure using a document fragment and get the innerHTML of ul</em>
dom('&lt;ul&gt;&lt;li&gt;hi&lt;/li&gt;&lt;/ul&gt;').html()</pre>
 <p>For most readers this chapter is simply an exercise in taking the information in this book and applying it to a JavaScript DOM library. For others, this might just shed some light on jQuery itself and any DOM manipulation logic used in JavaScript frameworks today. Ideally, in the end, I hope this exercise inspires readers to craft their own micro DOM abstractions on an as needed bases when the situation is right. With that said, lets begin.</p>
 <h2>12.2 Create a unique scope</h2>
	<p>To protect our dom.js code from the global scope, I will first create a unique scope to which it can live and operate within without fear of collisions in the global scope. In the code below I setup a pretty standard <a href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/">Immediately-Invoked Function Expression</a> to create this private scope. When the IIFE is invoked the value of <em>global</em> will be set to the current global scope (i.e. <em>window</em>).</p>
 
<pre>
<strong>(function(win){ 

var global = win;<br>var doc = this.document;

}}(window);</strong><em></em>
</pre>
<p>Inside of the IIFE we setup a reference to the <em>window </em> and <em>document</em> object (i.e. <em>doc</em>) to speed up the access to these objects inside of the IIFE.</p>
<h2>12.3 Create the <em>dom()</em> and <em>GetOrMakeDom()</em> functions exposing <em>dom()</em> and <em>GetOrMakeDom.prototype</em> to the global scope</h2>
	<p>Just like jQuery we are going to create a function that will return a chain-able, wrapped set (i.e. custom array like object) of DOM nodes (e.g. <em>{0:ELEMENT_NODE,1:ELEMENT_NODE,length:2}</em>) based on the parameters sent into the function. In the code below I setup the <em> dom()</em> function and parameters which get passed on to the <em>GetOrMakeDOM</em> constructor function that when invoked will return the object containing the DOM nodes, that is then returned by from <em>dom()</em>.</p>
 
<pre>
(function(win){ 

var global = win;<br>var doc = global.document;

<strong>var dom = function(params,context){
	return new GetOrMakeDom(params,context);
};

var GetOrMakeDom = function(params,context){

};</strong><em></em>

})(window);<em></em></pre>
<p>In order for the <em>dom()</em> function to be accessed/called from outside of the private scope setup by the IIFE we have to expose the dom function (i.e. create a reference) to the global scope. This is done by creating a property in the global scope called <em>dom</em> and pointing that property to the local <em>dom()</em> function. When <em>dom</em> is accessed from the global scope it will point to my locally scoped <em>dom()</em> function. In the code below doing, <em>global.dom = dom; </em>does the trick.</p>

<pre>
(function(win){

var global = win;<br>var doc = global.document;
<strong>
</strong>var dom = function(params,context){
	return new GetOrMakeDom(params,context);
};

var GetOrMakeDom = function(params,context){

};

<em>//expose dom to global scope</em><br><strong>global.dom = dom;</strong>

})(window);</pre>
<p>The last thing we need to do is expose the <em>GetOrMakeDom.prototype</em> property to the global scope. Not unlike jQuery (e.g. <em>jQuery.fn</em>) we are simply going to provide a shortcut reference from <em>dom.fn</em> to <em>GetOrMakeDOM.prototype</em>. This is shown in the code below.</p>

<pre>
(function(win){

var global = win;<br>var doc = global.document;
<strong>
</strong>var dom = function(params,context){
	return new GetOrMakeDom(params,context);
};

var GetOrMakeDom = function(params,context){

};

<em>//expose dom to global scope</em><br>global.dom = dom;

<em>//short cut to prototype</em><br><strong>dom.fn = GetOrMakeDom.prototype;</strong>

})(window);<em></em></pre>
<p>Now anything attached to the <em>dom.fn</em> is actually a property of the <em>GetOrMakeDOM.prototype</em> object and is inherited during property lookup for any object instance created from the <em>GetOrMakeDOM</em> constructor function.</p>
<div class="notes">
	<h3>Notes</h3>
	<p>The <em>getOrMakeDom</em> function is invoked with the <em>new</em> operator. Make sure you <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/new">understand</a> what happens when a function is invoked using the <em>new</em> operator.</p>
</div>

<h2>12.4 Create optional context paramater passed to <em>dom()</em></h2>
<p>When <em>dom()</em> is invoked, it also invokes the <em>GetOrMakeDom</em> function passing it the parameters that are sent to <em>dom()</em>. When the <em>GetOrMakeDOM</em> constructor is invoked the first thing we need to do is determine context. The context for working with the DOM can be set by passing a selector string used to select a node or a node reference itself. If its not obvious the purpose of passing a context to the <em>dom()</em> function provides the ability to limit the search for element nodes to a specific branch of the DOM tree. This is very similar, almost identical, to the second parameter passed to the <em>jQuery</em> or <em>$</em> function. In the code below I default the context to the current document found in the global scope. If a context parameter is available, I determine what it is (i.e. string or node) and either make the node passed in the context or select a node via <em>querySelectorAll()</em>.</p>

<pre>
(function(win){

var global = win;<br>var doc = global.document;
<strong>
</strong>var dom = function(params,context){
	return new GetOrMakeDom(params,context);
};

var GetOrMakeDom = function(params,context){

<strong>	var currentContext = doc;
		if(context){
			if(context.nodeType){<em>//its either a document node or element node</em>
				currentContext = context;
			}else{ <em>//else its a string selector, use it to selector a node</em>
				currentContext = doc.querySelector(context);
		}
	}</strong>

};

<em>//expose dom to global scope</em><br>global.dom = dom;

<em>//short cut to prototype</em><br>dom.fn = GetOrMakeDom.prototype;

})(window);</pre>
<p>With the <em>context</em> parameter logic setup we can next add the logic required to deal with the <em>params</em> parameter used to actually select or created nodes.</p>
<h2>12.5 Populate object with DOM node references based on <em>params</em> and return object</h2>
<p>The <em>params</em> parameter passed to <em>dom()</em>, then on to the <em>getOrMakeDom()</em> varies in the type of parameter that can be passed. Similar to jQuery the type's of value's passed can be any one of the following:</p>
<ul>
	<li>css selector string (e.g. <em>dom('body')</em>)</li>
	<li>html string (e.g. <em>dom('&lt;p&gt;Hellow&lt;/p&gt;&lt;p&gt; World!&lt;/p&gt;')</em>)</li>
	<li><em>Element</em> node (e.g. <em>dom(document.body)</em>)</li>
	<li>array of element nodes (e.g. <em>dom([document.body])</em>)</li>
	<li>a <em>NodeList</em> (e.g. <em>dom(document.body.children)</em>)</li>
	<li>a <em>HTMLcollection</em> (e.g.<em> dom(document.all)</em>)</li>
	<li>a <em>dom()</em> object itself. (e.g. <em>dom(dom())</em>)</li>
 </ul>
<p>The result of passing <em>params</em> is the construction of a chain-able object containing references to nodes (e.g. <em>{0:ELEMENT_NODE,1:ELEMENT_NODE,length:2})</em> either in the DOM or in a document fragment. Lets examine how each of the above parameters can be used to produce an object containing node references.</p>
<p>The logic to permit such a wide variety of parameter types is shown below in the code and starts with a simple check to verify that <em>params</em> is not <em>undefined</em>, an empty string, or a string with empty spaces. If this is the case we add a <em>length</em> property with a value of <em>0</em> to the object constructed from calling <em>GetOrMakeDOM</em> and return the object so the execution of the function ends. If <em>params</em> is not a false (<a href="http://javascriptweblog.wordpress.com/2011/02/07/truth-equality-and-javascript/">or false like</a>) value the execution of the function continues.</p>
<p>Next the <em>params</em> value, if a string, is checked to see if contains HTML. If the string contains HTML then a <a href="https://developer.mozilla.org/en-US/docs/DOM/DocumentFragment">document fragmen</a>t is created and the string is used as the <em>innerHTML</em> value for a <em>&lt;div&gt;</em> contained in the document fragment so that the string is converted to a DOM structure. With the html string converted to a node tree, the structure is looped over accessing top level nodes, and references to these nodes are passed to the object being created by <em>GetOrMakeDom</em>. If the string does not contain HTML execution of the function continues.</p>
<p>The next check simply verifies if <em>params</em> is a reference to a single node and if it is we wrap a reference to it up in an object and return it other wise at we are pretty sure the <em>params</em> value is a <a href="https://developer.mozilla.org/en-US/docs/DOM/HTMLCollection">html collection</a>, <a href="https://developer.mozilla.org/en-US/docs/DOM/NodeList">node list</a>, array, string <a href="http://www.quirksmode.org/css/contents.html">selector</a>, or an object created from <em>dom()</em>. If its a string selector, a node list is created by calling the <em>queryselectorAll()</em> method on the <em>currentContext</em>. If its not a string selector we loop over the html collection, node list, array, or object extracting the node references and using the references as values contained in the object sent back from calling the <em>GetOrMakeDom</em>.</p>
<p>All of this logic inside of <em>GetOrMakeDom()</em> function can be a bit overwhelming just realize that the point of the constructor function is to construct an object containing references to nodes (e.g. <em>{0:ELEMENT_NODE,1:ELEMENT_NODE,length:2}</em>) and returns this object to <em>dom()</em>.</p>

<pre>
(function(win){

var global = win;<br>var doc = global.document;
<strong>
</strong>var dom = function(params,context){
	return new GetOrMakeDom(params,context);
};

<strong>var regXContainsTag = /^\s*&lt;(\w+|!)[^&gt;]*&gt;/;</strong>

var GetOrMakeDom = function(params,context){

	var currentContext = doc;
	if(context){
		if(context.nodeType){
			currentContext = context;
		}else{
			currentContext = doc.querySelector(context);
		}
	}

<strong>	<em>//if no params, return empty dom() object</em>
	if(!params || params === '' || typeof params === 'string' &amp;&amp; params.trim() === ''){
		this.length = 0;
		return this;
	}

	<em>//if HTML string, construct domfragment, fill object, then return object</em>
	if(typeof params === 'string' &amp;&amp; regXContainsTag.test(params)){//yup its forsure html string
		<em>//create div &amp; docfrag, append div to docfrag, then set its div's innerHTML to the string, then get first child</em>
		var divElm = currentContext.createElement('div');
		divElm.className = 'hippo-doc-frag-wrapper';
		var docFrag = currentContext.createDocumentFragment();
		docFrag.appendChild(divElm);
		var queryDiv = docFrag.querySelector('div');
		queryDiv.innerHTML = params;
		var numberOfChildren = queryDiv.children.length;
		<em>//loop over nodelist and fill object, needs to be done because a string of html can be passed with siblings</em>
		for (var z = 0; z //give the object a length value
		this.length = numberOfChildren;
	<em>	//return object</em>
		return this; <em>//return e.g. {0:ELEMENT_NODE,1:ELEMENT_NODE,length:2}</em>
	}

	<em>//if a single node reference is passed, fill object, return object</em>
	if(typeof params === 'object' &amp;&amp; params.nodeName){
		this.length = 1;
		this[0] = params;
		return this;
	}

	<em>//if its an object but not a node assume nodelist or array, else its a string selector, so create nodelist</em>
	var nodes;
	if(typeof params !== 'string'){<em>//nodelist or array</em>
		nodes = params;
	}else{<em>//ok string</em>
		nodes = currentContext.querySelectorAll(params.trim());
	}
	<em>//loop over array or nodelist created above and fill object</em>
	var nodeLength = nodes.length;
	for (var i = 0; i //give the object a length value
	this.length = nodeLength;
	<em>//return object</em>
	return this; <em>//return e.g. {0:ELEMENT_NODE,1:ELEMENT_NODE,length:2}</em></strong>
	
};

<em>//expose dom to global scope</em><br>global.dom = dom;

<em>//short cut to prototype</em><br>dom.fn = GetOrMakeDom.prototype;

})(window);
&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;</pre>


<h2>12.6 Create <em>each()</em> method and make it a chainable method</h2>
<p>When we invoke <em>dom()</em> we can access anything attached to <em>dom.fn</em> by way of prototypical inheritance. (e.g. <em>dom().each())</em>. Not unlike jQuery methods attached to <em>dom.fn</em> operate on the object created from the <em>GetOrMakeDom</em> constructor function. The code below setups the <em>each()</em> method.</p>

<pre>
<strong>dom.fn.each = function (callback) {<br>	var len = this.length; <em>//the specific instance create from getOrMakeDom() and returned by calling dom()</em><br>	for(var i = 0; i &lt; len; i++){
		<em>//invoke the callback function setting the value of this to element node and passing it parameters</em><br>		callback.call(this[i], i, this[i]);<br>	}<br>};&#x200B;&#x200B;&#x200B;</strong>&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;
</pre>
<p>As you might expect the <em>each()</em> method takes a callback function as a parameter and invokes the function (setting the <em>this</em> value to the element node object with <em>call()</em>) for each node element in the <em>getOrMakeDom</em> object instance. The <em>this</em> value inside of the <em>each()</em> function is a reference to the <em>getOrMakeDom</em> object instance (e.g. <em>{0:ELEMENT_NODE,1:ELEMENT_NODE,length:2}</em>).</p>
<p>When a method does not return a value (e.g. <em>dom().length</em> returns a length) its possible to allow method chaning by simply returning the object the method belongs too instead of a specific value. Basically, we are returning the <em>GetOrMakeDom</em> object so another method can be called on this instance of the object. In the code below I would like the <em>each()</em> method to be chainable, meaning more methods can be called after calling <em>each()</em>, so I simply return <em>this</em>. The <em>this</em> in the code below is the object instance created from calling the <em>getOrMakeDom</em> function.</p>

<pre>
dom.fn.each = function (callback) {<br>	var len = this.length;<br>	for(var i = 0; i &lt; len; i++){<br>		callback.call(this[i], i, this[i]);<br>	}<strong>
	return this; <em>//make it chainable by returning e.g. {0:ELEMENT_NODE,1:ELEMENT_NODE,length:2}</em><em></em><br></strong>};&#x200B;<strong>&#x200B;&#x200B;</strong>&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;
</pre>
<h2>12.7 Create <em>html()</em>, <em>append()</em>, &amp; <em>text()</em> methods</h2>
<p>With the core <em>each()</em> method created and implicit iteration avaliable we can now build out a few <em>dom()</em> methods that act on the nodes we select from an HTML document or create using document fragments. The three methods we are going to create are:</p>
<ul>
	<li><em>html()</em> / <em>html('html string')</em></li>
	<li><em>text()</em> / <em>text('text string')</em></li>
	<li><em>append('html | text | dom() | nodelist/HTML collection | node | array')</em></li>
 </ul>
<p>The <em>html()</em> and <em>text()</em> methods follow a very similar pattern. If the method is called with a parameter value we loop (using <em>dom.fn.each()</em> for implicit iteration ) over each element node in the <em>getOrMakeDom</em> object instance setting either the <em>innerHTML</em> value or <em>textContent</em> value. If no parameter is sent we simply return the <em>innerHTML</em> or <em>textContent</em> value for the first element node in the <em>getOrMakeDom</em> object instance. Below you will see this logic coded.</p>


 <pre>
dom.fn.html = function(htmlString){
	<strong>if(htmlString){
		return this.each(function(){ <em>//notice I return this so its chainable if called with param</em>
			this.innerHTML = htmlString;
		});
	}else{
		return this[0].innerHTML;
	}</strong>
};

dom.fn.text = function(textString){
	<strong>if(textString){
		return this.each(function(){ <em>//notice I return this so its chainable if called with param</em>
			this.textContent = textString;
		});
	}else{
		return this[0].textContent.trim();
	}</strong>
};</pre>


	<p>The <em>append()</em> method leveraging <em>insertAdjacentHTML</em> will take a an html string, text string, <em>dom()</em> object, nodelist/HTML collection a single node or array of nodes and appends it to the nodes selected.</p>
	

 <pre>dom.fn.append = function(stringOrObject){<br>	<strong>return this.each(function(){<br>		if(typeof stringOrObject === 'string'){<br>			this.insertAdjacentHTML('beforeend',stringOrObject);<br>		}else{<br>			var that = this;<br>			dom(stringOrObject).each(function(name,value){<br>				that.insertAdjacentHTML('beforeend',value.outerHTML);<br>			});<br>		}<br>	});</strong><br>};</pre>

 <h2>12.8 Taking dom.js for a spin</h2>
 <p>During the creation of <a href="https://github.com/codylindley/domjs/tree/master/test">dom.js I created some very simple qunit tests</a> that we are now going to run outside of the testing framework. However, you can also <a href="https://github.com/codylindley/domjs/blob/master/test/index.html">run the testing framework</a> to see dom.js in action. The follow code demostrates the code create in this chapter.</p>
 
<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;
<br>&lt;ul&gt;<br>&lt;li&gt;1&lt;/li&gt;<br>&lt;li&gt;2&lt;/li&gt;<br>&lt;li&gt;3&lt;/li&gt;<br>&lt;/ul&gt;<br>
&lt;script src="https://raw.github.com/codylindley/domjs/master/builds/dom.js"&gt;&lt;/script&gt;
&lt;script&gt;

<em>//dom()</em><br>console.log(<strong>dom()</strong>);<br>console.log(<strong>dom('')</strong>);<br>console.log(<strong>dom('body')</strong>);<br>console.log(<strong>dom('&lt;p&gt;Hellow&lt;/p&gt;&lt;p&gt; World!&lt;/p&gt;')</strong>);<br>console.log(<strong>dom(document.body)</strong>);<br>console.log(<strong>dom([document.body,&#xA0;document.body])</strong>);<br>console.log(<strong>dom(document.body.children)</strong>);<br>console.log(<strong>dom(dom('body'))</strong>);
<br><em>//dom().html()</em><br>console.log(<strong>dom('ul li:first-child').html('one')</strong>);<br>console.log(<strong>dom('ul li:first-child').html()&#xA0;===&#xA0;'one'</strong>);
<br><em>//dom().text()</em><br>console.log(<strong>dom('ul li:last-child').text('three')</strong>);<br>console.log(<strong>dom('ul li:last-child').text()&#xA0;===&#xA0;'three'</strong>);
<br><em>//dom().append()</em><br><strong>dom('ul').append('&lt;li&gt;4&lt;/li&gt;');<br>dom('ul').append(document.createElement('li'));<br>dom('ul').append(dom('li:first-child'));</strong>

&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;
</pre>
 <h2>12.9 Summary &amp; continuing on with dom.js</h2>
<p>This chapter has been about creating a foundation to a jQuery like DOM library. If you'd like to continue studying the building blocks to a jQuery-like DOM library I would suggest checking out <a href="https://github.com/codylindley/hippojs">hippo.js</a>, which is an exercise in re-creating the jQuery DOM methods for modern browsers. Both <a href="https://github.com/codylindley/domjs">dom.js</a> and <a href="https://github.com/codylindley/hippojs">hippo.js</a> make use of <a href="http://gruntjs.com/">grunt</a>, <a href="http://qunitjs.com/">QUnit</a>, and <a href="http://jshint.com/">JS Hint</a> which I highly recommend looking into if building your own JavaScript libraries is of interest. In addition to the fore mentioned developer tools I highly recommending reading, "<a href="http://coding.smashingmagazine.com/2012/10/09/designing-javascript-apis-usability/">Designing Better JavaScript APIs</a>". Now go build something for the DOM.</p>


</div>













</body>
</div>
</body></html>
