<!DOCTYPE html><html><head><title>Git Tutorial – The Ultimate Guide</title></head><body>
<h1>Git Tutorial – The Ultimate Guide</h1><p><a href="https://www.javacodegeeks.com/2016/07/git-tutorial.html" target="_new">Original URL</a></p>
<p><blockquote>Git is, without any doubt, the most popular version control system. Ironically, there are other version control systems easier to learn and to use, but, despite that, Git is the favorite option for&hellip;</blockquote></p>
<div><div class="entry"><p>Git is, without any doubt, the most popular version control system. Ironically, there are other version control systems easier to learn and to use, but, despite that, Git is the favorite option for developers, which is quite clarifying about the powerfulness of Git.</p><p>This guide will cover all the topics needed to know in order to use Git properly, from explaining what is it and how it differs from other tools, to its usage, covering also advanced topics and practices that can suppose an added value to the process of version controlling.</p><h2 id="section_1">1. What is version control? What is Git?</h2><p>Version control is the management of the changes made within a system, that it has not to be software necessarily.</p><p>Even if you have never used before Git or similar tools, you will probably have ever carried out a version control. A very used and <em>bad</em> practice in software developing is, when the software has reached a stable situation, saving a local copy of it, identifying it as stable, and then following with the changes in other copy.</p><p>This is something that <strong>every</strong> software engineer has done before using specific tools version controlling, so don&#x2019;t feel bad if you have done it. Actually, this is much more better than having commented the code like:</p><pre class="brush:java">/* First version
public void foo(int bar) {
 return bar + 1;
}
*/
/* Second version
public void foo(int bar) {
 return bar - 1;
}
*/
public void foo(int bar) {
 return bar build_a_javascript_command_line_interface_cli_with_nodejs.md data data.json gnu_ddrescue_manual.md higher_order_components_a_react_application_design_pattern.md html httpie_parse_url.sh learn_how_to_use_awk_builtin_variables_–_part_10.md lehm.md making_sense_of_everything_with_words2map.md md node_modules package.json parse_urls_json.sh png tidy urls_to_read.txt url_to_filename.csv 2;
}</pre><p>Which should be declared illegal.</p><p>The <strong>version control systems (VCS)</strong> are designed for carrying out a proper management of the changes. These tools provide the following features:</p><ul><li>Reversibility.</li><li>Concurrency.</li><li>Annotation.</li></ul><p>The reversibility is the main capability of a VCS, allowing to return to any point of the history of the source code, for example, when a bug has been introduced and the code has to return to a stable point.</p><p>The concurrency allows to have several people making changes on the same project, facilitating the process of the integration of pieces of code developed by two or more developers.</p><p>The annotation is the feature that allows to add additional explanations and thoughts about the changes made, such us a resume of the changes made, the reason that has caused these changes, an overall description of the stability, etc.</p><p>With this, <strong>the VCSs solve one of the most common problems of software development: the fear for changing the software</strong>. You will be probably be familiar to the famous saying &#x201C;if something works, don&#x2019;t change it&#x201D;. Which is almost a joke, but, actually, is like we act many times. <strong>A VCS will help you to get rid of being scared about changing your code</strong>.</p><p>There are several models for the version control systems. The one we mentioned, the manual process, can be considered as a local version control system, since the changes are only saved locally.</p><p>Git is a <strong>distributed</strong> version control system (DVCS), also known as decentralized. This means that <strong>every developer has a full copy of the repository</strong>, which is hosted in the cloud.</p><p>We will see more in detail the features of DVCSs in the following chapter.</p><h2 id="section_2">2. Git vs SVN (DVCS vs CVCS)</h2><p>Before the DVCSs burst into the version controlling world, the most popular VCS was, probably Apache Subversion (known also as SVN). This VCS was centralized (CVCS). A centralized VCS is a system designed to have <strong>a single full copy of the repository, hosted in some server, where the developers save the changes they made</strong>.</p><p>Of course, using a CVCS is better than having a local version control, which is incompatible with teamwork. But having a version control system that completely depends on a centralized server has an obvious implication: if the server, or the connection to it goes down, the developers won&#x2019;t be able to save the changes. Or even worse, if the central repository gets corrupted, and no backup exists, the history of the repository will be lost.</p><p><strong>CVCSs can also be slow</strong>. Recording a change in the repository means making effective the change in the remote repository, so, it relies on the connection speed to the server.</p><p>Returning to Git and DVCSs, with it, every developer has the full repository locally. So, the <strong>developers can save the changes whenever they want</strong>. If at certain moment the server hosting the repository is down, the developers can continue working without any problem. And the changes could be recorded into the shared repository later.</p><p>Another difference with CVCSs, is that DVCSs, specially Git, are <strong>much more faster</strong>, since the changes are made locally, and the disk access is faster than network access, at least in normal situation.</p><p>The differences between both systems could be summed up to the following: with a <strong>CVCS you are enforced to have a complete dependency on a remote server</strong> to carry out your version control, whereas <strong>with a DVCS the remote server is just an option</strong> to share the changes.</p><h2 id="section_3">3. Download and install Git</h2><h3 id="section_3_1">3.1. Linux</h3><p>As you probably have guessed, Git can be installed in Linux executing the following commands:</p><pre class="brush:bash">sudo apt-get update
sudo apt-get install git</pre><h3 id="section_3_2">3.2. Windows</h3><p>Firstly, we have to download the last stable release from <a href="https://git-scm.com/downloads">official page</a>.</p><p>Run the executable, and click &#x201C;next&#x201D; button until you get to the following step:</p><div class="wp-caption aligncenter"><img src="https://www.javacodegeeks.com/wp-content/uploads/2016/07/Windows-install-1.jpg" width="499"><p class="wp-caption-text">1. Configuring Git in Windows to use it through Git Bash only.</p></div><p>Check the first option. The following options can be left as they come by default. You are about four or five &#x201C;next&#x201D; ago of having Git installed.</p><p>Now, if you open the context menu (right click), you will see two new options:</p><ul><li>&#x201C;Git GUI here&#x201D;.</li><li>&#x201C;Git Bash here&#x201D;.</li></ul><p>In this guide we will be using the bash. All the commands shown will be for their execution in this bash.</p><h2 id="section_4">4. Git usage</h2><p>In this chapter, we will see how to use Git to start with our version controlling.</p><h3 id="section_4_1">4.1. Creating a repository</h3><p>To begin using Git, we have first to create a repository, also known as &#x201C;repo&#x201D;. For that, in the directory where we want to have the repository, we have to execute:</p><pre class="brush:bash">git init</pre><p>We have a Git repository! Note that a folder named <code>.git</code> has been created. The repository will be the directory where the <code>.git</code> folder is placed. This folder is the repository metadata, an embedded database. It&#x2019;s better not to touch anything inside it while you are not familiarized with Git.</p><h3 id="section_4_2">4.2. Creating the history: commits</h3><p>Git constructs the history of the repository with commits. <strong>A commit is a full snapshot of the repository, that is saved in the database</strong>. Every state of the files that are committed, will be recoverable later at any moment.</p><p>When doing a commit, we have to choose which files are going to be committed; not all the repository has to be committed necessarily. This process is called <strong>staging</strong>, where files are <strong>added to the index</strong>. The Git index is <strong>where the data that is going to be saved in the commit is stored temporarily</strong>, until the commit is done.</p><p>Let&#x2019;s see how it works.</p><p>We are going to create a file and add some content to it, for example:</p><pre class="brush:bash">echo 'My first commit!' &gt; README.txt</pre><p>Adding this file, the status of the repository has changed, since a new file has been created in the <strong>working directory</strong>. We can check for the status of the repository with the <code>status</code> option:</p><pre class="brush:bash">git status</pre><p>Which, in this case, would generate the following output:</p><pre class="brush:bash">On branch master

Initial commit

Untracked files:
&#xA0; (use "git add &lt;file&gt;..." to include in what will be committed)

&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; README.txt

nothing added to commit but untracked files present (use "git add" to track)</pre><p>What Git is saying is &#x201C;<em>you have a new file in the repository directory, but this file is not yet selected to be committed</em>&#x201C;.</p><p>If we want to include this file the commit, remember that it has to be added to the index. This is made with the <code>add</code> command, as Git suggests in the output of <code>status</code> :</p><pre class="brush:bash">git add README.txt</pre><p>Again, the status of the repository has changes:</p><pre class="brush:bash">On branch master

Initial commit

Changes to be committed:
&#xA0; (use "git rm --cached &lt;file&gt;..." to unstage)

&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; new file:&#xA0;&#xA0; README.txt</pre><p>Now, we can do the commit!</p><pre class="brush:bash">git commit</pre><p>Now, the default text editor will be shown, where we have to type the commit message, and then save. <strong>If we leave the message empty, the commit will be aborted</strong>.</p><p>Additionally, we can use the shorthand version with <code>-m</code> flag, specifying the commit message inline:</p><pre class="brush:bash">git commit -m 'Commit message for first commit!'</pre><p>We can add all the files of the current directory, recursively, to the index, with <code>.</code>:</p><pre class="brush:bash">git add .</pre><p>Note that the following:</p><pre class="brush:bash">echo 'Second commit!' &gt; README.txt
git add README.txt
echo 'Or is it the third?' &gt; README.txt
git commit -m 'Another commit'</pre><p><strong>Would commit the file with <code>'Second commit!'</code> content, because it was the one added to the index, and then we changed the file of the working directory</strong>, not the one added to staging area. To commit the latest change, we would have to add again the file to the index, being the first added file overwritten.</p><p>Git identifies each commit uniquely using SHA1 hash function, based on the contents of the committed files. So, each commit is identified with a 40 character-long hexadecimal string, like the following, for example: <code>de5aeb426b3773ee3f1f25a85f471750d127edfe</code>. Take into account that the commit message, commit date, or any other variable rather than the committed files&#x2019; content (and size), are not included in the hash calculation.</p><p>So, for our first two commit, the history would be the following:</p><div class="wp-caption aligncenter"><img src="https://www.javacodegeeks.com/wp-content/uploads/2016/07/1-Git-history.jpg" width="860"><p class="wp-caption-text">2. History of the repository, with two commits.</p></div><p>Git shortens the checksum of each commit to 7 characters (whenever it&#x2019;s possible), to make them more legible.</p><p>Each commit points to the commit it has been created from, being this called the &#x201C;ancestor&#x201D;.</p><p>Note that <code>HEAD</code> element. This is one of the most important element in Git. The <code>HEAD</code> is the element that points to the current point in the repository history. <strong>The contents of the working directory will be those that belong to the snapshot the <code>HEAD</code> is pointing to</strong>.</p><p>We will see this <code>HEAD</code> more in detail later.</p><h4>4.2.1. Tips for creating good commit messages</h4><p>The commit message content is more important that it may seem at first sight. Git allows to add any kind of explanation for any change we made, without touching the source code, and we should always take advantage of this.</p><p>For the message formatting, there&#x2019;s an unwritten rule known as the <strong>50/72 rule</strong>, which is so simple:</p><ul><li>One first line with a summary of no more than 50 characters.</li><li>Wrap the subsequent explanations in lines of no more than 72 characters.</li></ul><p>This is based on how Git formats the output when we are reviewing the history.</p><p>But, more important than this, is the content of the message itself. The first thing that comes to mind to write are the changes that have been made, which is not bad at all. But the commit object itself is a description of the changes that have been made in the source code. To make the commit messages useful, <strong>you should always include the reason that motivated the changes</strong>.</p><h3 id="section_4_3">4.3. Viewing the history</h3><p>Of course, Git is able to show the history of the repository. For that, the <code>log</code> command is used:</p><pre class="brush:bash">git log</pre><p>If you try it, you will see that the output is not very nice. The <code>log</code> command has many flags available to draw pretty graphs. Here&#x2019;s a suggestion for using this command through this guide, even if graphs are shown for each scenario:</p><pre class="brush:bash">git log --all --graph --decorate --oneline</pre><p>If you want, you can omit the <code>--oneline</code> flag for showing the full information of each commit.</p><h3 id="section_4_4">4.4. Independent development lines: branches</h3><p>Branching is probably the most powerful feature of Git. <strong>A branch represents an independent development path</strong>. The branches coexist in the same repository, but each one has its own history. In the previous section, we have worked with a branch, Git&#x2019;s default branch, which is named <code>master</code>.</p><p>Taking into account this, the proper way to express the history would be the following, considering&#xA0;the branches.</p><div class="wp-caption aligncenter"><img src="https://www.javacodegeeks.com/wp-content/uploads/2016/07/2-History-with-master.jpg" width="860"><p class="wp-caption-text">3. History of the repository, showing the branch pointer.</p></div><p>Creating a branch with Git is so simple:</p><pre class="brush:bash">git branch &lt;branch-name&gt;</pre><p>For example:</p><pre class="brush:bash">git branch second-branch</pre><p>And that&#x2019;s it.</p><p>But, what is Git doing really when it creates a branch? It just creates a pointer with that branch name that points to the commit where the branch has been created:</p><div class="wp-caption aligncenter"><img src="https://www.javacodegeeks.com/wp-content/uploads/2016/07/3-Two-branches.jpg" width="860"><p class="wp-caption-text">4. History of the repository with a new branch.</p></div><p>This is one of the most notable features of Git: the branch creation speed, almost instantaneous, regardless of the repository size.</p><p>To start working in that branch, we have to <code>checkout</code> it:</p><pre class="brush:bash">git checkout second-branch</pre><p>Now, the commits will only exist in <code>second-branch</code>. Why? <strong>Because the <code>HEAD</code> now is pointing to <code>second-branch</code>, so, the history created from now will have an independent path from <code>master</code></strong>.</p><p>We can see it making a couple of commits being located in <code>second-branch</code>:</p><pre class="brush:bash">echo 'The changes made in this branch...' &gt;&gt; README.txt 
git add README.txt 
git commit -m 'Start changes in second-branch'
echo '... Only exist in this branch' &gt;&gt; README.txt 
git add README.txt 
git commit -m 'End changes in second-branch'</pre><p>If we check for the content of the file we have being modifying, we will see the following:</p><pre class="brush:bash">Second commit!
The changes made in this branch...
... Only exist in this branch</pre><p>But, what if we return to <code>master</code>?</p><pre class="brush:bash">git checkout master</pre><p>The content of the file will be:</p><pre class="brush:bash">Second commit!</pre><p>This is because, after creating the history of <code>second-branch</code>, we have placed the <code>HEAD</code> pointing to <code>master</code>:</p><div class="wp-caption alignnone"><img src="https://www.javacodegeeks.com/wp-content/uploads/2016/07/Two-histories.jpg" width="860"><p class="wp-caption-text">5. Independent history for second-branch.</p></div><h3 id="section_4_5">4.5. Combining histories: merging branches</h3><p>In the previous subsection, we have seen how we can create different paths for our repository history. Now, we are going to see how to combine them, what for Git is calling <strong>merging</strong>.</p><p>Let&#x2019;s suppose that, after the changes made in <code>second-branch</code>, is ready to return to <code>master</code>. For that, we have to place the <code>HEAD</code> in the destination branch (<code>master</code>), and specify the branch that is going to be merged to this destination branch (<code>second-branch</code>), with <code>merge</code> command:</p><pre class="brush:bash">git checkout master
git merge second-branch</pre><p>And Git will give the following output:</p><pre class="brush:bash">Updating f043d98..0705117
Fast-forward
&#xA0;README.txt | 2 ++
&#xA0;1 file changed, 2 insertions(+)</pre><p>Now, the history of the&#xA0;<code>second-branch</code> has been merged to <code>master</code>, so, all the changes made in this first branch have been applied to the second.</p><p>In this case, the entire history of second-branch is now part of the history of master, having a graph like the following:</p><div class="wp-caption aligncenter"><img src="https://www.javacodegeeks.com/wp-content/uploads/2016/07/4-Fast-forward.jpg" width="860"><p class="wp-caption-text">6. History after merging second-branch to master.</p></div><p>As you can see, no track of the life of <code>second-branch</code> has been saved, when you probably were expecting a nice tree.</p><p>This is because Git merged the branch using the <code>fast-forward</code> mode. Note that is telling it in the merge output, shown above. Why did Git do this? <strong>Because <code>master</code> and <code>second-branch</code> shared the common ancestor</strong>, <code>f043d98</code>.</p><p>When we are merging branches, <strong>is always advisable not to use the&#xA0;<code>fast-forward</code> mode</strong>. This is achieved passing <code>--no-ff</code> flag while merging:</p><pre class="brush:bash">git merge --no-ff second-branch</pre><p>What does this really do? Well, it just creates an intermediate, third commit, between the <code>HEAD</code>, and the &#x201C;from&#x201D; branch&#x2019;s last commit.</p><p>After saving the commit message (of course, is editable), the branch will be merged, having the following history:</p><div class="wp-caption aligncenter"><img src="https://www.javacodegeeks.com/wp-content/uploads/2016/07/No-ff-merge.jpg" width="860"><p class="wp-caption-text">7. History after merging second-branch to master, using no fast-forward mode.</p></div><p>Which is much more expressive, since the history is reflected as it is actually is. <strong>The no fast-forward mode should be always used</strong>.</p><p>A merge of a branch supposes the end of the life of this. So, it should be deleted:</p><pre class="brush:bash">git branch -d second-branch</pre><p>Of course, in the future, you can create again a <code>second-branch</code> named branch.</p><h3 id="section_4_6">4.6. Conflictive merges</h3><p>In the previous section we have seen an &#x201C;automatic&#x201D; merge, i.e., Git has been able to merge both histories. Why? Because of the previously mentioned <strong>common ancestor</strong>. That is, the branch is returning to the point it started from.</p><p>But, when the branch another branch borns from suffers changes, problems appear.</p><p>To understand this, let&#x2019;s construct a new history, which will have the following graph:</p><div class="wp-caption alignnone"><img src="https://www.javacodegeeks.com/wp-content/uploads/2016/07/Conflictive-histories.jpg" width="860"><p class="wp-caption-text">8. Continuing the history of master, after the creation of second-branch.</p></div><p>With the following commands:</p><pre class="brush:bash">echo 'one' &gt;&gt; file.txt
git add file.txt
git commit -m 'first'

echo 'two' &gt;&gt; file.txt
git add file.txt 
git commit -m 'second'

git checkout -b second-branch

echo 'three (from second-branch)' &gt;&gt; file.txt 
git add file.txt 
git commit -m 'third from second branch'

git checkout master

echo 'three' &gt;&gt; file.txt 
git add file.txt 
git commit -m 'third'</pre><p>What will happen if we try to merge <code>second-branch</code> to <code>master</code>?</p><pre class="brush:bash">git checkout master
git merge second-branch</pre><p>Git won&#x2019;t be able to do it:</p><pre class="brush:bash">CONFLICT (content): Merge conflict in file.txt
Automatic merge failed; fix conflicts and then commit the result.</pre><p><strong> Git doesn&#x2019;t know how to do it, because the changes made in <code>second-branch</code> are not directly applicable to <code>master</code>, since it has changed from this first branch inception</strong>. What Git has done is to indicate in which parts exists these incompatibilities.</p><p>Note that we haven&#x2019;t used the <code>--no-ff</code> flag, since we now in advance that the fast-forward won&#x2019;t be possible.</p><p>If we check the <code>status</code>, we will see the following:</p><pre class="brush:bash">On branch master
You have unmerged paths.
&#xA0; (fix conflicts and run "git commit")

Unmerged paths:
&#xA0; (use "git add &lt;file&gt;..." to mark resolution)

&#xA0;&#xA0; &#xA0;both modified:&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; file.txt</pre><p>Showing the conflictive files. If we open it, we will see that Git has added some strange lines:</p><pre class="brush:bash;highlight:[3,5,7]">one
two
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
three
=======
three (from second-branch)
&gt;&gt;&gt;&gt;&gt;&gt;&gt; second-branch</pre><p>Git has indicated which are the incompatible changes. And how does it know? <strong>The incompatible changes are those that have been introduced into the &#x201C;to&#x201D; merging branch (<code>master</code>) since the creation of the &#x201C;from&#x201D; merging branch (<code>second-branch</code>)</strong>.</p><p>Now, we have to decide how to combine the changes. On the one hand, the changes introduced to the current <code>HEAD</code> are shown (between <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code> and <code>=======</code>), and, on the other, the branch we are trying to merge (between <code>=======</code> and <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; second-branch</code>). To solve the conflict, there are three options:</p><ul><li>Use&#xA0;<code>HEAD</code> version.</li><li>Use <code>second-branch</code> version.</li><li>A combination of two versions.</li></ul><p>Regardless the option, the file should end without any of the metacharacters that Git has added to identify the conflicts.</p><p>Once the conflicts have been resolved, we have to add the file to the index and continue with the merge, with <code>commit</code> command:</p><pre class="brush:bash;highlight:[3,5,7]">git add file.txt
git commit</pre><p>Once saved the commit, the merge will be done, having Git created a third commit for this merge, as with when we used the <code>--no-ff</code> in the previous section.</p><h4>4.6.1. Knowing in advance which version to stay with</h4><p>It may happen that we know beforehand which version we want to choose in case of conflicts. In these cases, we can tell Git which version use, to make it apply it directly.</p><p>To do this, we have to pass the <code>-X</code> option to <code>merge</code>, indicating which version use:</p><pre class="brush:bash;highlight:[3,5,7]">git merge -X &lt;ours|theirs&gt; &lt;branch-name&gt;</pre><p>So, for using <code>HEAD</code> version, we would have to use <code>ours</code> option; instead, for using the version that is not <code>HEAD</code>&#x2018;s, <code>theirs</code> has to be passed.</p><p>That is, the following:</p><pre class="brush:bash;highlight:[3,5,7]">git merge -X ours second-branch</pre><p>Would leave the file as is shown:</p><pre class="brush:bash;highlight:[3,5,7]">one
two
three</pre><p>And, the following:</p><pre class="brush:bash;highlight:[3,5,7]">git merge -X theirs second-branch</pre><p>As it follows:</p><pre class="brush:bash;highlight:[3,5,7]">one
two
three (from second-branch)</pre><h3 id="section_4_7">4.7. Checking differences</h3><p>Git allows to check the differences between distinct points in the history. This is done with <code>diff</code> option.</p><h4>4.7.1. Interpreting the differences</h4><p>Before seeing what differences we can look at, firstly we have to understand how the differences are shown.</p><p>Let&#x2019;s see a sample output of a difference between the same file:</p><pre class="brush:bash">diff --git a/README.txt b/README.txt
index 31325b6..55e8d58 100644
--- a/README.txt
+++ b/README.txt
@@ -1,2 +1,2 @@
-This is
-the original file
+This file
+has been modified</pre><p>Here, <code>a</code> is the a previous version of the file, and <code>b</code> the current version.</p><p>The third and fourth line identifies each letter with a <code>-</code> or <code>+</code> symbol.</p><p>That <code>@@ -1,2 +1,2 @@</code> is called &#x201C;hunk header&#x201D;. This identifies the chunks of code that actually have changed, not showing the common parts for both versions.</p><p>The format is the following:</p><pre class="brush:bash">@@ &lt;previous&gt;&lt;from-line&gt;,&lt;number-of-lines&gt; &lt;current&gt;,&lt;from-line&gt;&lt;number-of-lines&gt;</pre><p>In this case:</p><ul><li>&#x201C;previous&#x201D;: identified with <code>-</code>, corresponding to <code>a</code>.</li><li>&#x201C;from-line&#x201D;: the line number from where the changes start.</li><li>&#x201C;number-of-lines&#x201D;: the number of lines shown.</li><li>&#x201C;current&#x201D;: identified with <code>+</code>, corresponding to <code>b</code>.</li></ul><p>Finally, which lines are subtracted, and which added, are shown. In this case, two lines have been subtracted from the line (those preceded with <code>-</code>), and other two have been added (preceded with <code>+</code>).<code></code></p><h4>4.7.2. Differences between working directory and last commit</h4><p>One common use is to check the differences between the working directory and the last commit. For this, is enough to execute:</p><pre class="brush:bash">git diff</pre><p>Which will show the difference for every file. We can specify also specific files:</p><pre class="brush:bash">git diff &lt;file1&gt; &lt;file2&gt;</pre><h4>4.7.3. Differences between exact points in history</h4><p>We can look for differences with:</p><ul><li>SHA1 id</li><li>Branch names</li><li><code>HEAD</code></li><li>Tags</li></ul><p>Being combinable between them.</p><p>The syntax is the following:</p><pre class="brush:bash">git diff &lt;original&gt;..&lt;modified&gt;</pre><p>For example, the following would show the changes that have been applied to <code>dev</code> branch, compared to a <code>v1.0</code> tag:</p><pre class="brush:bash">git diff v1.0..dev</pre><h3 id="section_4_8">4.8. Tagging important points</h3><p>Tagging is one of the nicest features of Git, since allows to mark important points in the repository history, in a very easy way. Usually, tags are used to mark releases, not only for stable releases, but also for under-development or incomplete releases, such as:</p><ul><li>Alpha</li><li>Beta</li><li>Release candidate (rc)</li></ul><p>Creating a tag is so simple, we just have to situate the <code>HEAD</code> in the point we want to tag, and just specify the tag name with the <code>tag</code> option:</p><pre class="brush:bash">git tag -a &lt;tag-name&gt;</pre><p>For example:</p><pre class="brush:bash">git tag -a v0.1-beta1</pre><p>Then, we will be asked to type a message for the tag. <strong>Typically, the changes made from last tag are specified</strong>.</p><p>As when committing, we can specify the tag message inline, with <code>-m</code> flag:</p><pre class="brush:bash">git tag -a v0.1 -m 'v0.1 stable release, changes from...'</pre><p>Take into account that the <strong>tag names cannot be repeated </strong>in a repository.</p><h3 id="section_4_9">4.9. Undoing and deleting things</h3><p>Git also allows to undo and modify some things in the history. In this section we will see what can be done, and how.</p><h4>4.9.1. Modifying the last commit</h4><p>Is quite common to want to modify the last commit, for example, when just a line of code has to be added; or even to modify the update message, without changing any file.</p><p>For that, Git has the <code>--amend</code> flag for <code>commit</code> command:</p><pre class="brush:bash">git commit --amend</pre><p>This is just the same as committing, but, instead of a new commit object, the last one of that branch will be overwritten.</p><h4>4.9.2. Discarding uncommitted changes</h4><p>This is for, after a commit, when we keep developing, we think that we have taken an incorrect path, and we want to reset the changes, returning to the last commit&#x2019;s state.</p><p>For this, the command used is <code>checkout</code>, as for moving between branches. But, when specifying a file, this gets reseted to the state of the last commit.</p><p>For example:</p><pre class="brush:bash">echo 'one' &gt; test.txt
git add test.txt 
git commit -m 'commit one'
echo 'two' &gt; test.txt 
git checkout test.txt # The content of test.txt is now 'one'.</pre><h4>4.9.3. Deleting commits</h4><p>Usually, we want to delete commits when we don&#x2019;t want to leave any record of an embarrassing commit, or just for removing useless changes.</p><p>This is achieved moving the branch or <code>HEAD</code> pointers. Moving the pointers to previous commits makes the commits remaining ahead get &#x201C;lost&#x201D;, unlinked from the linked list. To move them, <code>reset</code> command is used.</p><p>There are two ways of making a reset: not touching the working directory (soft reset, <code>--soft</code> flag), or resetting it too (hard reset, <code>--hard</code> flag). That is, <strong>if you make a soft reset, the commit(s) will be removed, but the modifications saved in that/those commit(s) will remain; and a hard reset, won&#x2019;t leave change made in the commit(s)</strong>. If no flag is specified, the reset will be done softly.</p><p>Let&#x2019;s start resetting things. The following command would remove the last commit, i.e., the commit where <code>HEAD</code> is pointing to:</p><pre class="brush:bash">git reset --hard HEAD~</pre><p>The <code>~</code> character is for indicating an ancestor. Used once, indicates the immediate parent; twice, the grandparent; and so on. But, instead of typing <code>~</code> <em>n</em> times, we can specify the <em>n</em> ancestors that we want to remove:</p><pre class="brush:bash">git reset --hard HEAD~3</pre><p>Which would remove the last 3 commits.</p><p>You may have noticed that this may cause conflicts with those commits with more than one ancestor, i.e., the result of a not fast-forwarded merge. Well, it doesn&#x2019;t cause any problem: the followed parent using <code>HEAD~</code> is always the first one. But there&#x2019;s a way to decide which of the common parents follow: <code>^</code>, followed by the parent number. So, the following:</p><pre class="brush:bash">git reset --hard HEAD~2^2</pre><p>Would remove the previous two commits, but taking the path of the second ancestor.</p><p>Even if it is possible to specify which ancestor path follow, <strong>is recommended to always use the syntax for first ancestor</strong> (only <code>~</code>) <strong>since it&#x2019;s easier, even if more commands would be required</strong> (since you would have to checkout the different branches to update <code>HEAD</code> position).</p><h4>4.9.4. Deleting tags</h4><p>Deleting tags is so simple:</p><pre class="brush:bash">git tag -d &lt;tag-name&gt;</pre><h2 id="section_5">5. Branching strategies</h2><p>Reached this point, you may have already asked your self: &#x201C;<em>Okay, branches are cool, but when should I create and merge them?</em>&#x201D;</p><p>When we want to carry out a version control, we need to know&#xA0;which strategy we are going to follow. <strong>Using Git without having a clear branching policy is a complete nonsense</strong>.</p><p>The branching workflow to follow <strong>depends, mainly, on how we want to maintain the code</strong>. In this section, we will see the two main branching strategies.</p><h3 id="section_5_1">5.1. Long running branches</h3><p>This strategy is used when we want <strong>to maintain a single version of our software at the same time</strong>. That is, when we offer the last version of our software as available, instead of having many versions (which can be still available, but considered as old or unmaintained).</p><p>The key of this strategy is having a branch only for stable versions, where the releases are tagged, for which the default branch is used, <code>master</code>; and having other branches for development, where the features are developed, tested, and integrated.</p><p>In this strategy, the <code>master</code> branch is the production branch, so <strong>only tested, properly integrated, definitive versions should be here. Or, there can also be under-development or not fully tested versions, but they must be properly tagged</strong>.</p><p>The following graph shows an example of the history of a repository following this strategy:</p><div class="wp-caption aligncenter"><img src="https://www.javacodegeeks.com/wp-content/uploads/2016/07/Long-running-branches-1.jpg" width="786"><p class="wp-caption-text">9. Example of a repository history using the long-running branches strategy.</p></div><p>Simple and clarifying. The production state is only modified for those changes that have been integrated with the development branch, where nothing happens if something breaks. The changes that have to be made for each feature are perfectly isolated, favoring the division of tasks among the teammates.</p><h3 id="section_5_2">5.2. One version, one branch</h3><p>This workflow is thought <strong>for creating software that will be available and maintained for several versions</strong>. In other words, a release does not &#x201C;overwrite&#x201D; every previous releases, it would &#x201C;overwrite&#x201D; only the release of the branch the release has been made for.</p><p>To achieve this, each maintained version has to have its main version, but with a common development path for all of them.</p><p>This is done having a branch for every version (usually named <code>PROJECT_NAME_XX_STABLE</code> or similar) for the stable release, the &#x201C;master&#x201D; of each version; and having a main branch (and its sub-branches) where the development is made, for which default&#xA0;<code>master</code> branch can be used. When each feature is developed and tested, the <code>master</code> branch can be merged to every wanted stable version.</p><p>This branching strategy is based on the long-running, but, in this case, having many &#x201C;masters&#x201D; instead of a single one.</p><p>Take into account that each feature should have to be tested with each version of the project we want to apply this feature to. Consider using Continuous Integration when dealing with this strategy.</p><p>Let&#x2019;s see an example of the graph of a history for which this strategy has been applied.</p><div class="wp-caption aligncenter"><img src="https://www.javacodegeeks.com/wp-content/uploads/2016/07/One-version-one-branch-1.jpg" width="860"><p class="wp-caption-text">10. Example of a repository history using the one version, one branch strategy.</p></div><p>As we can see, here, the&#xA0;<code>master</code> branch is used as the main development branch.</p><p>In the v3.0 version, we have simulated a bug for <code>feature1</code>. It does not have to be necessarily a bug appeared at integration time, it can be a bug that has been detected later. In any case, we are sure that bug of <code>feature1</code> only exists for v3.0 version. In these cases, we shouldn&#x2019;t fix these bugs in&#xA0;<code>master</code> branch, because it&#x2019;s not something that affects all the versions. We should create a branch from the affected version, fix the bug, and merge to the specific branch. And, if the future the same error persists for new releases, we can consider the option of merging it to <code>master</code>.</p><p>The main advantage of this strategy is that the common features follow a common path, and the specific changes can be perfectly isolated for the affected versions.</p><h3 id="section_5_3">5.3. Regardless the branching strategy: one branch for each bug</h3><p>No matter the branching strategy you use, an advisable practice is to create an independent branch for every bug, as same as it has been reported in your bug tracker (because you use a bug tracking system, right?). Actually, we have seen this practice in the previous example, in the integration of the feature into the branch for v3.0 version. <strong>Having an independent branch for each bug allows to having the issues perfectly located and identified, having the changes fixed involves isolated from others</strong>.</p><p>Identifying this branch with the id number generated by the bug tracker for the given bug, naming the branches, for example, as <code>issue-X</code>, allows to have a track between the changes made for the fix of that bug, to the comments made in the corresponding ticket of the bug tracker, which is really helpful, since you can explain possible solutions for the bugs, attach images, etc.</p><h2 id="section_6">6. Remote repositories</h2><p>Git, as we have seen in the introduction, is a distributed VCS. This means that, apart from the local, we can have a copy of the repository hosted in a remote server that, apart from making public the source code of the project, is used for collaborative development.</p><p>The most popular platform for Git repositories hosting is <a href="https://github.com/">GitHub</a>. Unfortunately, GitHub does not offer private repositories in its free plan. If you need a hosting platform with unlimited private repositories, you can use <a href="https://bitbucket.org/">Bitbucket</a>. And, if you are looking for hosting your repositories in your own server, the available option is <a href="https://about.gitlab.com/">GitLab</a>.</p><p>For this section, we will need to use one of the options mentioned above.</p><h3 id="section_6_1">6.1. Writing changes in the remote</h3><p>The first thing we need to do in the remote hosting is to create a repository, for which a URL with the following format will be created:</p><pre class="brush:bash">https://hosting-service.com/username/repository-name</pre><p>Once having a remote repository, we have to link it with our local repo. This is made with the <code>remote add &lt;remote-name&gt; &lt;repo-url&gt;</code> command:</p><pre class="brush:bash">git remote add origin https://hosting-service.com/username/repository-name</pre><p><code>origin</code> is which is named by default by Git, similarly to <code>master</code> branch, but it does not have to be necessarily.</p><p>Now, in our local repository, the remote repository is identified as <code>origin</code>. We can now start to &#x201C;send&#x201D; information to it, which is made with <code>push</code> option:</p><pre class="brush:bash">git push [remote-name] [branch-name | --all] [--tags]</pre><p>Let&#x2019;s see some examples of how it works:</p><pre class="brush:bash">git push origin --all # Updates the remote with all the local branches
git push origin master dev # Updates remote's mater and dev branches
git push origin --tags # Sends tags to remotes</pre><p>This is an example output of a successful master branch update:</p><pre class="brush:bash">Counting objects: 3, done.
Writing objects: 100% (3/3), 235 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To https://hosting-service.com/username/repository-name.git
&#xA0;* [new branch]&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; master -&gt; master</pre><p>What has Git internally with this?</p><p>Well, now, a directory <code>.git/refs/remotes</code> has been created, and, inside it, another directory, <code>origin</code> (because that&#x2019;s the name we have given to the remote). Here, <strong>Git creates a file for each branch exiting in the remote repository, with a reference to it. This reference is just the SHA1 id of the last commit of the given branch of the remote repository</strong>. This is used by Git to know if in remote repo are any changes that can be applied to the local repository. We will cover this in detail later in the following sections.</p><p><strong>Note</strong>: a repository can have as many remotes as we want. For example, we could have the remote of the same repository in both GitHub and Bitbucket:</p><pre class="brush:bash">git remote add github https://github.com/username/repository-name
git remote add bitbucket https://bitbucket.org/username/repository-name</pre><h3 id="section_6_2">6.2. Cloning a repository</h3><p>The cloning of a repository is actually made once, when we are going to start to work with a remote repository.</p><p>For cloning remote repositories there&#x2019;s no mystery, we just have to use the <code>clone</code> option, specifying the URL of the repository:</p><pre class="brush:bash">git clone https://hosting-service.com/username/repository-name</pre><p>Which would create a local directory with the repository, with the reference to the remote it has been cloned from.</p><p>By default, when cloning a repository, only the default branch is created (<code>master</code>, generally). The way to create the other branches locally is making a checkout to them.</p><p>Remote branches can be shown with <code>branch</code> option with <code>-r</code> flag:</p><pre class="brush:bash">git branch -r</pre><p>They will be shown with the format <code>&lt;remote-name&gt;/&lt;branch-name&gt;</code>. To create the local branch, is enough to make a checkout to <code>&lt;branch-name&gt;</code>.</p><h3 id="section_6_3">6.3. Updating remote references: fetching</h3><p>Fetching the remote repository means <strong>updating the reference of a local branch, to put it even with the remote branch</strong>.</p><p>Let&#x2019;s consider a collaborative scenario where two developers are pushing changes to the same repo. In some moment, one of the developers wants to update its reference to <code>master</code>, to the last push of the other developer, as is shown in the following image.</p><div class="wp-caption aligncenter"><img src="https://www.javacodegeeks.com/wp-content/uploads/2016/07/Remote-1.jpg" width="860"><p class="wp-caption-text">11. Collaborative development with a remote repository.</p></div><p>The content of the <code>.git/refs/remotes/origin/master</code> file of Alice&#x2019;s repository would be, before any update, the following:</p><pre class="brush:bash">5bfc81ce5f7a0b26b493be0c99f1966a1896c972</pre><p>Bob&#x2019;s, however, will be updated, since it has been him the last who has updated the remote repository:</p><pre class="brush:bash">37db4f82e346665f6048cc9e4b7cd48c83c6ebcb</pre><p>Now, Alice wants to have in her local repository the changes made by Bob. For that, she has to <code>fetch</code> the <code>master</code> branch:</p><pre class="brush:bash">git fetch origin master</pre><p>(Alternatively, she can fetch every branch with <code>--all</code> flag):</p><pre class="brush:bash">git fetch --all</pre><p>The output of the fetch would be something similar to the following:</p><pre class="brush:bash">remote: Counting objects: 3, done.
remote: Total 3 (delta 0), reused 0 (delta 0)
Unpacking objects: 100% (3/3), done.
From https://hosting-service.com/alice/repository-name
&#xA0;* branch&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; master&#xA0;&#xA0;&#xA0;&#xA0; -&gt; FETCH_HEAD
&#xA0;&#xA0; 5bfc81c..37db4f8&#xA0; master&#xA0;&#xA0;&#xA0;&#xA0; -&gt; origin/master</pre><p>And, now, the content of Alice&#x2019;s <code>.git/refs/remotes/origin/master</code> file would be the same of remote&#x2019;s:</p><pre class="brush:bash">37db4f82e346665f6048cc9e4b7cd48c83c6ebcb</pre><p>With this, Alice has <strong>updated the reference to remote&#x2019;s&#xA0;<code>master</code> branch, but the changes have not been applied in the repository</strong>.</p><p><code>fetch</code>&#xA0; does not apply changes directly to the local repository. Is the first of two steps that have to be made. The other step is to <strong>merge the remote branch, which has just been updated; with the local branch</strong>. This is just a merge as any other, but where the remote name has to be indicated:</p><pre class="brush:bash">git merge origin/master</pre><p>Once the merge is finished, Alice will have the latest version of <code>master</code> branch.</p><p><strong>Note</strong>: in this merge, we have not applied the no-fast forward. In this cases, would not have many sense to apply it, since we are merging the intrinsically same branch, but that is located somewhere else.</p><h3 id="section_6_4">6.4. Fetching and merging remotes at once: pulling</h3><p>Git has an option to apply remote changes at once, that is, fetching and merging the branch in one command. This option is <code>pull</code>.</p><p>Considering the exactly same scenario seen above, we could just execute:</p><pre class="brush:bash">git pull origin master</pre><p>And would do the fetch, followed by the merge.</p><p>Use the way you fell more comfortable with. There&#x2019;s no <em>better</em> way; actually, they do exactly the same, but expressed differently.</p><h3 id="section_6_5">6.5. Conflicts updating remote repository</h3><p>Let&#x2019;s return to the scenario shown above. What would happen if, without updating her local repository, Alice would create a commit and push it to the remote repository? Well, she would receive an ugly message from Git:</p><pre class="brush:bash">&#xA0;! [rejected]&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; master -&gt; master (fetch first)
error: failed to push some refs to 'https://hosting-service.com/alice/repository-name.git'
hint: Updates were rejected because the remote contains work that you do
hint: not have locally. This is usually caused by another repository pushing
hint: to the same ref. You may want to first integrate the remote changes
hint: (e.g., 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.</pre><p>The push would be rejected because Alice <strong>has not continued the history of the repository from a point that has been already registered in the remote</strong>. So, before writing changes in the remote repository, she would need first to fetch &amp; merge, or pull, the remote with her changes.</p><h4>6.5.1. A bad way to resolve conflicts</h4><p>There&#x2019;s still another way, which can not be exactly considered as <em>resolving</em>. Is about forcing pushes with <code>--force</code> flag.</p><p>Forcing a push is about, basically, one thing: overwrite the remote repository branch (or the whole repository) with the one that is being pushed. So, in the above scenario, if Alice forces a push of her repository, the <code>37db4f8</code> commit will disappear. <strong>This would leave Bob working in something similar to a &#x201C;parallel universe&#x201D; that cannot coexist with the current reality of the project</strong>, since his work is based on a state that no longer exist in the project.</p><p>In conclusion, <strong>don&#x2019;t force pushes when you are working with other developers</strong>, at least if you don&#x2019;t want to have an intense argument with them.</p><p>If you Google for &#x201C;git force push&#x201D; in the images section, you will see some memes that perfectly explain graphically what a forced push is considered as.</p><h3 id="section_6_6">6.6. Deleting things in remote repository</h3><p>As with forced pushes, things in remote repositories must be deleted with extreme precaution. <strong>Before deleting anything, every collaborator should be informed about it</strong>.</p><p>Actually, when we are pushing commits, branches, etc., we are pushing them to a ref destination, but we don&#x2019;t have to specify the destination explicitly.</p><p>The explicit syntax is the following:</p><pre class="brush:bash">git push origin &lt;source&gt;:&lt;destination&gt;</pre><p>So, the way of deleting remote things is updating the refs to prior states, or pushing &#x201C;nothing&#x201D;.</p><p>Let&#x2019;s see how to do it for every case.</p><h4>6.6.1. Deleting commits</h4><p>This is just the same as deleting commits locally, for example, to delete the last two commits:</p><pre class="brush:bash">git push origin HEAD~2:master --force</pre><p>If we are using <code>HEAD</code> to refer the commits to remove, we must ensure that it&#x2019;s located on the same branch as remote.</p><p>Note that these pushes have to be forced too.</p><h4>6.6.2. Deleting branches</h4><p>This is quite simple, is just about pushing &#x201C;nothing&#x201D;, as said before. The following would remove <code>dev</code> branch from remote repository:</p><pre class="brush:bash">git push origin :dev</pre><p><strong>Remote branches should be removed when the local branch is removed</strong>.</p><h4>6.6.3. Deleting tags</h4><p>As same as with branches, we have to push &#x201C;nothing&#x201D;, e.g.:</p><pre class="brush:bash">git push origin --tags :v1.0</pre><h2 id="section_7">7. Patches</h2><p>You will have probably ever seen a software being updated with something called <em>patch</em>. A patch is just a file that describes the changes that have to be made over a program, indicating which code lines have to be removed, and which have to be added. With Git, a path is just the output of a&#xA0;<code>diff</code> saved into a file.</p><p>Take into account that a patch is an update, but an update does not have to be a patch necessarily. <strong>Patches are thought for hotfixes</strong>, or also critical features that have to be fixed or implemented <em>right now</em>, not for being the common update and deploying strategy.</p><h3 id="section_7_1">7.1. Creating patches</h3><p>As said, a patch for Git is just the output of a <code>diff</code>. So, we would have to redirect that output to a file:</p><pre class="brush:bash">git diff &lt;expression&gt; &gt; &lt;patch-name&gt;.patch # The extension is not important.</pre><p>For example:</p><pre class="brush:bash">git diff master..issue-1 &gt; issue-1-fix.patch</pre><p><strong>Note</strong>: a patch cannot be modified. <strong>If a patch file suffers any modification, Git will mark it as corrupt and it won&#x2019;t apply it.</strong></p><h3 id="section_7_2">7.2. Applying patches</h3><p>The patches are applied with <code>apply</code> command. It&#x2019;s as simple as specifying the path to the path file:</p><pre class="brush:bash">git apply &lt;patch-file&gt;</pre><p>If patching goes well, no message will be displayed (if you haven&#x2019;t used the <code>--verbose</code> flag). If the patch is not applicable, Git will show which are the files causing problems.</p><p>Is quite common to get errors due to just whitespace differences. These errors can be ignored with <code>--ignore-space-change</code> and <code>--ignore-whitespace</code> flags.</p><h2 id="section_8">8. Cherry picking</h2><p>There may be some scenarios in where we are interested in porting into a branch just a specific set of changes made on another branch, instead of merging it.</p><p>To do this, Git allows to cherry pick commits from branches, with the <code>cherry-pick</code> command. The mechanism is the same as merging, but, in this case, specifying the commit SHA1 id, for example:</p><pre class="brush:bash">git cherry-pick -x aba6c1b # Several commits can be cherry picked.</pre><p>A cherry pick creates a new commit, with the same message as the original&#x2019;s one. The <code>-x</code> option is for adding to that commit message a line indicating that is a cherry pick, and from which commit has been picked:</p><blockquote><p>(cherry picked from commit aba6c1bf9a0a7d6d9ccceeab2b5dfc64f6c115c2)</p></blockquote><p><strong>The cherry picking should not be a recurrent practice in your workflow, since it does not leave a track in the history</strong>, just a line indicating where has been picked from.</p><h2 id="section_9">9. Hooks</h2><p>Git hooks are <strong>custom scripts that are triggered when important events occur</strong>, for example, a commit or a merge.</p><p>Let&#x2019;s say that you want to notify someone with an email when your production branch is updated, or to run a test suite; but in an automated way. The hooks can do this for you.</p><p>The scripts are located in <code>.git/hooks</code> directory. By default, some sample hooks are provided. Each hook has to have a concrete name, that we will see later, with no extension; and has to be marked as executable. You can use other scripting languages such us PHP or Python, apart from shell code.</p><p>There are two kind of hooks: client-side, and server-side.</p><h3 id="section_9_1">9.1. Client-side hooks</h3><p>The client-side hooks are those that are fired when the local repository suffers changes. These are the most common:</p><ul><li><code>pre-commit</code>: invoked by <code>git commit</code> command, before the commit is saved. A commit can be aborted with this hook exiting with a non-zero status.</li><li><code>post-commit</code>: invoked by <code>git commit</code> too, but this time when the commit has been saved. At this point, the commit cannot be aborted.</li><li><code>post-merge</code>: as same as with <code>post-commit</code>, but being this one fired by <code>git merge</code>.</li><li><code>pre-push</code>: fired by <code>git push</code>, before the remote any object has been transferred.</li></ul><p>The following script shows an example applicable for both&#xA0;<code>post-commit</code> and&#xA0;<code>post-commit</code> hooks, for notification purposes:</p><pre class="brush:bash">#!/bin/sh

branch=$(git rev-parse --abbrev-ref HEAD)

if [ "$branch" = "master" ]; then
&#xA0;&#xA0;&#xA0; echo "Notifying release to everyone..."
&#xA0;&#xA0;&#xA0; # Send the notification...
fi</pre><p>To use it for both cases, you would have to create both hooks.</p><h3 id="section_9_2">9.2. Server-side hooks</h3><p>These hooks reside in the server where the remote repository is hosted. As it is obvious, if you are using services such as GitHub for hosting your repositories, you won&#x2019;t be permitted to execute arbitrary code. In GitHub&#x2019;s case, you have available third-party services, but never hooks with your own code. For using executing your code, you will have to have your own server for hosting.</p><p>The most used hooks are:</p><ul><li><code>pre-receive</code>: this is fired after someone makes a push, and before the references get updated in the remote. So, with this hook, you can deny any push.</li><li><code>update</code>: almost exact to the previous one, but this is executed for each reference pushed. That is, if 5 references have been pushed, this hook will be executed 5 times, unlike <code>pre-receive</code>, which is executed for the push as a whole.</li><li><code>post-receive</code>: this one is executed once the push has been successful, so it can be used for notification purposes also.</li></ul><h3 id="section_9_3">9.3. Hooks are not included in the history</h3><p>The hooks only exist in the local repository. If you make a push in a repository that has custom hooks, these will not be sent to the remote. So, if every developer should share the same hooks, they would have to be included in the working directory, and installed them manually.</p><h2 id="section_10">10. An approach to Continuous Integration</h2><p>Continuous Integration (CI) is a software engineering practice that is closely related to version controlling, and it&#x2019;s worth mentioning it, at least to know it conceptually.</p><p><strong>CI consists on making several integrations of the code </strong>(at least, once a day)<strong>, in a completely automated way, with the aim of finding errors in early phases of the development</strong>.</p><p>The concept is almost the same of the hooks, but in a much more <strong>scalable and maintainable way</strong>.</p><p>Here are some of the actions that are performed in each integration:</p><ul><li>Test execution: unit, acceptance, integration, regression, and a large etc.</li><li>Quality Assurance, with software metrics checking: cyclomatic complexity, code coverage, and another large etc.</li><li>Software coding standard compliance checking.</li></ul><p>Continuous Integration allows to perform those actions, and more, automatically, without the need of having to execute it manually, <strong>just with a push or commit</strong>. Interesting, isn&#x2019;t it?</p><p>Probably, the most used CI options are the following:</p><ul><li>Travis CI: cloud-based, which allows to fire integrations with pushes, without the need of having your own server.</li><li>Jenkins: self-hosted, for which a server is needed, but which is completely configurable. Compatible with many build tools, like Ant, Gradle, Maven, Phing, Grunt&#x2026;</li></ul><h2 id="section_11">11. Conclusion</h2><p>Version control systems help to fulfill one of the dreams of every developer: having identified each point of the entire history of a project, being able to return to any point at any time. The VCS we have seen in this guide is Git, the preferred by the software developer community.</p><p>After reading this guide, if it&#x2019;s your first time with Git, you will probably be thinking how couldn&#x2019;t you live without Git until today.</p><h2 id="section_12">12. Resources</h2><p>The best resource possible is Pro Git (2nd edition), by Scott Chacon and Ben Straub, which covers almost every topic about Git. You can read it free at <a href="https://git-scm.com/book/en/v2">Git official page</a>.</p></div> </div>
</body></html>
