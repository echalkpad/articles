<!DOCTYPE html><html><head><title>Dancer2::Manual - A gentle introduction to Dancer2</title></head><body>
<h1>Dancer2::Manual - A gentle introduction to Dancer2</h1><p><a href="https://metacpan.org/pod/Dancer2::Manual" target="_new">Original URL</a></p>
<p><blockquote>NAME Dancer2::Manual - A gentle introduction to Dancer2 VERSION version 0.165000 DESCRIPTION Dancer2 is a free and open source web application framework written in Perl. It's a complete rewrite of&hellip;</blockquote></p>
<div><div class="pod content anchors">



<h2 id="NAME">NAME</h2>

<p>Dancer2::Manual - A gentle introduction to Dancer2</p>

<h2 id="VERSION">VERSION</h2>

<p>version 0.165000</p>

<h2 id="DESCRIPTION">DESCRIPTION</h2>

<p>Dancer2 is a free and open source web application framework written in Perl.</p>

<p>It's a complete rewrite of <a href="https://metacpan.org/pod/Dancer">Dancer</a>, based on <a href="https://metacpan.org/pod/Moo">Moo</a> and using a more robust and extensible fully-OO design.</p>

<p>It's designed to be powerful and flexible, but also easy to use - getting up and running with your web app is trivial, and an ecosystem of adaptors for common template engines, session storage, logging methods, serializers, and plugins to make common tasks easy means you can do what you want to do, your way, easily.</p>

<h2 id="INSTALL">INSTALL</h2>

<p>Installation of Dancer2 is simple:</p>

<pre><code> perl -MCPAN -e 'install Dancer2'</code></pre>

<p>Thanks to the magic of cpanminus, if you do not have CPAN.pm configured, or just want a quickfire way to get running, the following should work, at least on Unix-like systems:</p>

<pre><code> wget -O - http://cpanmin.us | sudo perl - Dancer2</code></pre>

<p>(If you don't have root access, omit the 'sudo', and cpanminus will install Dancer2 and prereqs into <code>~/perl5</code>.)</p>

<h2 id="BOOTSTRAPPING-A-NEW-APP">BOOTSTRAPPING A NEW APP</h2>

<p>Create a web application using the dancer script:</p>

<pre><code> $ dancer2 -a mywebapp &amp;&amp; cd mywebapp
 + mywebapp
 + mywebapp/Makefile.PL
 + mywebapp/config.yml
 + mywebapp/cpanfile
 + mywebapp/MANIFEST.SKIP
 + mywebapp/environments
 + mywebapp/environments/development.yml
 + mywebapp/environments/production.yml
 + mywebapp/bin
 + mywebapp/bin/app.pl
 + mywebapp/public
 + mywebapp/public/dispatch.fcgi
 + mywebapp/public/dispatch.cgi
 + mywebapp/public/500.html
 + mywebapp/public/404.html
 + mywebapp/public/favicon.ico
 + mywebapp/public/javascripts
 + mywebapp/public/javascripts/jquery.js
 + mywebapp/public/images
 + mywebapp/public/images/perldancer-bg.jpg
 + mywebapp/public/images/perldancer.jpg
 + mywebapp/public/css
 + mywebapp/public/css/error.css
 + mywebapp/public/css/style.css
 + mywebapp/views
 + mywebapp/views/index.tt
 + mywebapp/views/layouts
 + mywebapp/views/layouts/main.tt
 + mywebapp/lib
 + mywebapp/lib/mywebapp.pm
 + mywebapp/t
 + mywebapp/t/001_base.t
 + mywebapp/t/002_index_route.t</code></pre>

<p>It creates a directory named after the name of the app, along with a configuration file, a views directory (where your templates and layouts will live), an environments directory (where environment-specific settings live), a module containing the actual guts of your application, and a script to start it. A default skeleton is used to bootstrap the new application, but you can use the <code>-s</code> option to provide another skeleton. For example:</p>

<pre><code> $ dancer2 -a mywebapp -s ~/mydancerskel</code></pre>

<p>For an example of a skeleton directory check the default one available in the <code>share/</code> directory of your Dancer2 distribution.</p>

<p>Because Dancer2 is a <a href="https://metacpan.org/pod/PSGI">PSGI</a> web application framework, you can use the <code>plackup</code> tool (provided by <a href="https://metacpan.org/pod/Plack">Plack</a>) for launching the application:</p>

<pre><code> plackup -p 5000 bin/app.psgi</code></pre>

<p>View the web application at:</p>

<pre><code> http://localhost:5000</code></pre>

<h2 id="USAGE">USAGE</h2>

<p>When Dancer2 is imported to a script, that script becomes a webapp, and at this point, all the script has to do is declare a list of <b>routes</b>. A route handler is composed by an HTTP method, a path pattern and a code block. <code>strict</code> and <code>warnings</code> pragmas are also imported with Dancer2.</p>

<p>The code block given to the route handler has to return a string which will be used as the content to render to the client.</p>

<p>Routes are defined for a given HTTP method. For each method supported, a keyword is exported by the module.</p>

<h2 id="HTTP-Methods">HTTP Methods</h2>

<p>Here are some of the standard HTTP methods which you can use to define your route handlers.</p>

<ul>

<li><p><b>GET</b> The GET method retrieves information, and is the most common</p>

<p>GET requests should be used for typical "fetch" requests - retrieving information. They should not be used for requests which change data on the server or have other effects.</p>

<p>When defining a route handler for the GET method, Dancer2 automatically defines a route handler for the HEAD method (in order to honour HEAD requests for each of your GET route handlers).</p>

<p>To define a GET action, use the <a href="https://metacpan.org/pod/distribution/Dancer2/lib/Dancer2/Manual.pod#get">get</a> keyword.</p>

</li>
<li><p><b>POST</b> The POST method is used to create a resource on the server.</p>

<p>To define a POST action, use the <a href="https://metacpan.org/pod/distribution/Dancer2/lib/Dancer2/Manual.pod#post">post</a> keyword.</p>

</li>
<li><p><b>PUT</b> The PUT method is used to replace an existing resource.</p>

<p>To define a PUT action, use the <a href="https://metacpan.org/pod/distribution/Dancer2/lib/Dancer2/Manual.pod#put">put</a> keyword.</p>

<p>a PUT request should replace the existing resource with that specified - for instance - if you wanted to just update an email address for a user, you'd have to specify all attributes of the user again; to make a partial update, a PATCH request is used.</p>

</li>
<li><p><b>PATCH</b> The PATCH method updates some attributes of an existing resource.</p>

<p>To define a PATCH action, use the <a href="https://metacpan.org/pod/distribution/Dancer2/lib/Dancer2/Manual.pod#patch">patch</a> keyword.</p>

</li>
<li><p><b>DELETE</b> The DELETE method requests that the origin server delete the resource identified by the Request-URI.</p>

<p>To define a DELETE action, use the <a href="https://metacpan.org/pod/distribution/Dancer2/lib/Dancer2/Manual.pod#del">del</a> keyword.</p>

</li>
</ul>

<h3 id="Handling-multiple-HTTP-request-methods">Handling multiple HTTP request methods</h3>

<p>Routes can use <code>any</code> to match all, or a specified list of HTTP methods.</p>

<p>The following will match any HTTP request to the path <code>/myaction</code>:</p>

<pre><code> any '/myaction' =&gt; sub {
 # code
 }</code></pre>

<p>The following will match GET or POST requests to <code>/myaction</code>:</p>

<pre><code> any ['get', 'post'] =&gt; '/myaction' =&gt; sub {
 # code
 };</code></pre>

<p>For convenience, any route which matches GET requests will also match HEAD requests.</p>

<h2 id="Route-Handlers">Route Handlers</h2>

<p>The route action is the code reference declared. It can access parameters through the <code>params</code> keyword, which returns a hashref. This hashref is a merge of the route pattern matches and the request params.</p>

<p>You can have more details about how params are built and how to access them in the <a href="https://metacpan.org/pod/Dancer2::Core::Request">Dancer2::Core::Request</a> documentation.</p>

<p>You can also use the various parameters keywords to reach the specific parameters you want: <code>route_parameters</code>, <code>query_parameters</code>, and <code>body_parameters</code>.</p>

<h3 id="Declaring-Routes">Declaring Routes</h3>

<p>To control what happens when a web request is received by your webapp, you'll need to declare <code>routes</code>. A route declaration indicates which HTTP method(s) it is valid for, the path it matches (e.g. <code>/foo/bar</code>), and a coderef to execute, which returns the response.</p>

<pre><code> get '/hello/:name' =&gt; sub {
 return "Hi there " . params-&gt;{name};
 # or better:
 return "Hi there " . route_parameters-&gt;get('name');
 };</code></pre>

<p>The above route specifies that, for GET requests to <code>/hello/...</code>, the code block provided should be executed.</p>

<h3 id="Retrieving-request-parameters">Retrieving request parameters</h3>

<p>The <a href="https://metacpan.org/pod/distribution/Dancer2/lib/Dancer2/Manual.pod#params">params</a> keyword returns a hashref of request parameters; these will be parameters supplied on the query string within the path itself (with named placeholders) and, for HTTP POST requests, the content of the POST body.</p>

<p>The <a href="https://metacpan.org/pod/distribution/Dancer2/lib/Dancer2/Manual.pod#query_parameters">query_parameters</a> keyword provides a <a href="https://metacpan.org/pod/Hash::MultiValue">Hash::MultiValue</a> result from the request parameters. It is considered much safer and is recommended instead of <code>params</code>.</p>

<h3 id="Named-matching">Named matching</h3>

<p>A route pattern can contain one or more tokens (a word prefixed with ':'). Each token found in a route pattern is used as a named-pattern match. Any match will be set in the params hashref.</p>

<pre><code> get '/hello/:name' =&gt; sub {
 "Hey ".param('name').", welcome here!";
 # or
 "Hey " . query_parameters-&gt;get('name') . ", welcome here!";
 };</code></pre>

<p>Tokens can be optional, for example:</p>

<pre><code> get '/hello/:name?' =&gt; sub {
 "Hello there, " .
 (defined param('name') ? param('name') : "whoever you are!");
 };</code></pre>

<h3 id="Wildcard-Matching">Wildcard Matching</h3>

<p>A route can contain a wildcard (represented by a <code>*</code>). Each wildcard match will be placed in a list, which the <code>splat</code> keyword returns.</p>

<pre><code> get '/download/*.*' =&gt; sub {
 my ($file, $ext) = splat;
 # do something with $file.$ext here
 };</code></pre>

<p>An extensive, greedier wildcard represented by <code>**</code> (A.K.A. "megasplat") can be used to define a route. The additional path is broken down and returned as an arrayref:</p>

<pre><code> get '/entry/*/tags/**' =&gt; sub {
 my ( $entry_id, $tags ) = splat;
 my @tags = @{$tags};
 };</code></pre>

<p>The <code>splat</code> keyword in the above example for the route <i>/entry/1/tags/one/two</i> would set <code>$entry_id</code> to <code>1</code> and <code>$tags</code> to <code>['one', 'two']</code>.</p>

<h3 id="Mixed-named-and-wildcard-matching">Mixed named and wildcard matching</h3>

<p>A route can combine named (token) matching and wildcard matching. This is useful when chaining actions:</p>

<pre><code> get '/team/:team/**' =&gt; sub {
 var team =&gt; param('team');
 pass;
 };

 prefix '/team/:team';

 get '/player/*' =&gt; sub {
 my ($player) = splat;

 # etc...
 };

 get '/score' =&gt; sub {
 return score_for( vars-&gt;{'team'} );
 };</code></pre>

<h3 id="Regular-Expression-Matching">Regular Expression Matching</h3>

<p>A route can be defined with a Perl regular expression.</p>

<p>In order to tell Dancer2 to consider the route as a real regexp, the route must be defined explicitly with <code>qr{}</code>, like the following:</p>

<pre><code> get qr{/hello/([\w]+)} =&gt; sub {
 my ($name) = splat;
 return "Hello $name";
 };</code></pre>

<p>For Perl 5.10+, a route regex may use named capture groups. The <code>captures</code> keyword will return a reference to a copy of <code>%+</code>.</p>

<h3 id="Conditional-Matching">Conditional Matching</h3>

<p>Routes may include some matching conditions (on content_type, agent, user_agent, content_length and path_info):</p>

<pre><code> get '/foo', {agent =&gt; 'Songbird (\d\.\d)[\d\/]*?'} =&gt; sub {
 'foo method for songbird'
 }

 get '/foo' =&gt; sub {
 'all browsers except songbird'
 }</code></pre>

<h2 id="Prefix">Prefix</h2>

<p>A prefix can be defined for each route handler, like this:</p>

<pre><code> prefix '/home';</code></pre>

<p>From here, any route handler is defined to /home/*</p>

<pre><code> get '/page1' =&gt; sub {}; # will match '/home/page1'</code></pre>

<p>You can unset the prefix value</p>

<pre><code> prefix '/'; # or: prefix undef;
 get '/page1' =&gt; sub {}; # will match /page1</code></pre>

<p>Alternatively, to prevent you from ever forgetting to undef the prefix, you can use lexical prefix like this:</p>

<pre><code> prefix '/home' =&gt; sub {
 get '/page1' =&gt; sub {}; # will match '/home/page1'
 }; ## prefix reset to previous value on exit

 get '/page1' =&gt; sub {}; # will match /page1</code></pre>

<h2 id="Delayed-responses-Async-Streaming">Delayed responses (Async/Streaming)</h2>

<p><a href="https://metacpan.org/pod/Dancer2">Dancer2</a> can provide delayed (otherwise known as <i>asynchronous</i>) responses using the <code>delayed</code> keyword. These responses are streamed, although you can set the content all at once, if you prefer.</p>

<pre><code> get '/status' =&gt; sub {
 delayed {
 add_header 'X-Foo' =&gt; 'Bar';

 # flush headers (in case of streaming)
 flush;

 # send content to the user
 content 'Hello, world!';

 # you can write more content
 # all streaming
 content 'Hello, again!';

 # when done, close the connection
 done;

 # do whatever you want else, asynchronously
 # the user socket closed by now
 ...
 };
 };</code></pre>

<p>If you are streaming (calling <code>content</code> several times), you must call <code>flush</code> first. If you're sending only once, you don't need to call <code>flush</code>.</p>

<p>Here is an example of using delayed responses with <a href="https://metacpan.org/pod/AnyEvent">AnyEvent</a>:</p>

<pre><code> use Dancer2;
 use AnyEvent;

 my %timers;
 my $count = 5;
 get '/drums' =&gt; sub {
 delayed {
 print "Stretching...\n";
 flush; # necessary, since we're streaming

 $timers{'Snare'} = AE::timer 1, 1, delayed {
 $timers{'HiHat'} ||= AE::timer 0, 0.5, delayed {
 content "Tss...\n";
 };

 content "Bap!\n";

 if ( $count-- == 0 ) {
 %timers = ();
 content "Tugu tugu tugu dum!\n";
 done;

 print "&lt;enter sound of applause&gt;\n\n";
 $timers{'Applause'} = AE::timer 3, 0, sub {
 # the DSL will not available here
 # because we didn't call the "delayed" keyword
 print "&lt;applause dies out&gt;\n";
 };
 }
 };
 };
 };</code></pre>

<p>If an error happens during a write operation, a warning will be issued to the logger.</p>

<p>You can handle the error yourself by providing an <code>on_error</code> handler:</p>

<pre><code> get '/' =&gt; sub {
 delayed {
 flush;
 content "works";

 # ... user disconnected here ...

 content "fails";

 # ... error triggered ...

 done; # doesn't even get run
 } on_error =&gt; sub {
 # delayed{} not needed, DSL already available
 my ($error) = @_;
 # do something with $error
 };
 };</code></pre>

<h2 id="Action-Skipping">Action Skipping</h2>

<p>An action can choose not to serve the current request and ask Dancer2 to process the request with the next matching route.</p>

<p>This is done with the <b>pass</b> keyword, like in the following example</p>

<pre><code> get '/say/:word' =&gt; sub {
 return pass if (params-&gt;{word} =~ /^\d+$/);
 "I say a word: ".params-&gt;{word};
 };

 get '/say/:number' =&gt; sub {
 "I say a number: ".params-&gt;{number};
 };</code></pre>

<h2 id="HOOKS">HOOKS</h2>

<p>Hooks are code references (or anonymous subroutines) that are triggered at specific moments during the resolution of a request.</p>

<p>Many of them are supported by the core but plugins and engines can also define their own.</p>

<ul>

<li><p><code>before</code> hooks</p>

<p><code>before</code> hooks are evaluated before each request within the context of the request and receives as argument the app (a <a href="https://metacpan.org/pod/Dancer2::Core::App">Dancer2::Core::App</a> object).</p>

<p>It's possible to define variables which will be accessible in the action blocks with the keyword <code>var</code>.</p>

<pre><code> hook before =&gt; sub {
 var note =&gt; 'Hi there';
 };

 get '/foo/*' =&gt; sub {
 my ($match) = splat; # 'oversee';
 vars-&gt;{note}; # 'Hi there'
 };</code></pre>

<p>For another example, this can be used along with session support to easily give non-logged-in users a login page:</p>

<pre><code> hook before =&gt; sub {
 if (!session('user') &amp;&amp; request-&gt;dispatch_path !~ m{^/login}) {
 # Pass the original path requested along to the handler:
 forward '/login', { requested_path =&gt; request-&gt;dispatch_path };
 }
 };</code></pre>

<p>The request keyword returns the current <a href="https://metacpan.org/pod/Dancer2::Core::Request">Dancer2::Core::Request</a> object representing the incoming request.</p>

</li>
<li><p><code>after</code> hooks</p>

<p><code>after</code> hooks are evaluated after the response has been built by a route handler, and can alter the response itself, just before it's sent to the client.</p>

<p>This hook runs after a request has been processed, but before the response is sent.</p>

<p>It receives a <a href="https://metacpan.org/pod/Dancer2::Core::Response">Dancer2::Core::Response</a> object, which it can modify if it needs to make changes to the response which is about to be sent.</p>

<p>The hook can use other keywords in order to do whatever it wants.</p>

<pre><code> hook after =&gt; sub {
 response-&gt;content(
 q{The "after" hook can alter the response's content here!}
 );
 };</code></pre>

</li>
</ul>

<h2 id="Templates">Templates</h2>

<ul>

<li><p><code>before_template_render</code></p>

<p><code>before_template_render</code> hooks are called whenever a template is going to be processed, they are passed the tokens hash which they can alter.</p>

<pre><code> hook before_template_render =&gt; sub {
 my $tokens = shift;
 $tokens-&gt;{foo} = 'bar';
 };</code></pre>

<p>The tokens hash will then be passed to the template with all the modifications performed by the hook. This is a good way to setup some global vars you like to have in all your templates, like the name of the user logged in or a section name.</p>

</li>
<li><p><code>after_template_render</code></p>

<p><code>after_template_render</code> hooks are called after the view has been rendered. They receive as their first argument the reference to the content that has been produced. This can be used to post-process the content rendered by the template engine.</p>

<pre><code> hook after_template_render =&gt; sub {
 my $ref_content = shift;
 my $content = ${$ref_content};

 # do something with $content
 ${$ref_content} = $content;
 };</code></pre>

</li>
<li><p><code>before_layout_render</code></p>

<p><code>before_layout_render</code> hooks are called whenever the layout is going to be applied to the current content. The arguments received by the hook are the current tokens hashref and a reference to the current content.</p>

<pre><code> hook before_layout_render =&gt; sub {
 my ($tokens, $ref_content) = @_;
 $tokens-&gt;{new_stuff} = 42;
 $ref_content = \"new content";
 };</code></pre>

</li>
<li><p><code>after_layout_render</code></p>

<p><code>after_layout_render</code> hooks are called once the complete content of the view has been produced, after the layout has been applied to the content. The argument received by the hook is a reference to the complete content string.</p>

<pre><code> hook after_layout_render =&gt; sub {
 my $ref_content = shift;
 # do something with ${ $ref_content }, which reflects directly
 # in the caller
 };</code></pre>

</li>
</ul>

<h2 id="Error-Handling">Error Handling</h2>

<p>Refer to <a href="https://metacpan.org/pod/distribution/Dancer2/lib/Dancer2/Manual.pod#error-handling-1">Error Handling</a> for details about the following hooks:</p>

<ul>

<li><p><code>init_error</code></p>

</li>
<li><p><code>before_error</code></p>

</li>
<li><p><code>after_error</code></p>

</li>
<li><p><code>on_route_exception</code></p>

</li>
</ul>

<h2 id="File-Rendering">File Rendering</h2>

<p>Refer to <a href="https://metacpan.org/pod/distribution/Dancer2/lib/Dancer2/Manual.pod#file-handler">File Rendering</a> for details on the following hooks:</p>

<ul>

<li><p><code>before_file_render</code></p>

</li>
<li><p><code>after_file_render</code></p>

</li>
</ul>

<h2 id="Serializers">Serializers</h2>

<ul>

<li><p><code>before_serializer</code> is called before serializing the content, and receives the content to serialize as an argument.</p>

<pre><code> hook before_serializer =&gt; sub {
 my $content = shift;
 ...
 };</code></pre>

</li>
<li><p><code>after_serializer</code> is called after the payload has been serialized, and receives the serialized content as an argument.</p>

<pre><code> hook after_serializer =&gt; sub {
 my $serialized_content = shift;
 ...
 };</code></pre>

</li>
</ul>

<h2 id="HANDLERS">HANDLERS</h2>

<h2 id="File-Handler">File Handler</h2>

<p>Whenever a content is produced out of the parsing of a static file, the <a href="https://metacpan.org/pod/Dancer2::Handler::File">Dancer2::Handler::File</a> component is used. This component provides two hooks, <code>before_file_render</code> and <code>after_file_render</code>.</p>

<p><code>before_file_render</code> hooks are called just before starting to parse the file, the hook receives as its first argument the file path that is going to be processed.</p>

<pre><code> hook before_file_render =&gt; sub {
 my $path = shift;
 };</code></pre>

<p><code>after_file_render</code> hooks are called after the file has been parsed and the response content produced. It receives the response object (<a href="https://metacpan.org/pod/Dancer2::Core::Response">Dancer2::Core::Response</a>) produced.</p>

<pre><code> hook after_file_render =&gt; sub {
 my $response = shift;
 };</code></pre>

<h2 id="Auto-page">Auto page</h2>

<p>Whenever a page that matches an existing template needs to be served, the <a href="https://metacpan.org/pod/Dancer2::Handler::AutoPage">Dancer2::Handler::AutoPage</a> component is used.</p>

<h2 id="Writing-your-own">Writing your own</h2>

<p>A route handler is a class that consumes the <a href="https://metacpan.org/pod/Dancer2::Core::Role::Handler">Dancer2::Core::Role::Handler</a> role. The class must implement a set of methods: <code>methods</code>, <code>regexp</code> and <code>code</code> which will be used to declare the route.</p>

<p>Let's look at <a href="https://metacpan.org/pod/Dancer2::Handler::AutoPage">Dancer2::Handler::AutoPage</a> for example.</p>

<p>First, the matching methods are <code>get</code> and <code>head</code>:</p>

<pre><code> sub methods { qw(head get) }</code></pre>

<p>Then, the <code>regexp</code> or the <i>path</i> we want to match:</p>

<pre><code> sub regexp { '/:page' }</code></pre>

<p>Anything will be matched by this route, since we want to check if there's a view named with the value of the <code>page</code> token. If not, the route needs to <code>pass</code>, letting the dispatching flow to proceed further.</p>

<pre><code> sub code {
 sub {
 my $app = shift;

 my $template = $app-&gt;template_engine;
 if ( !defined $template ) {
 $app-&gt;response-&gt;has_passed(1);
 return;
 }

 my $page = $app-&gt;request-&gt;path;
 my $layout_dir = $template-&gt;layout_dir;
 if ( $page =~ m{^/\Q$layout_dir\E/} ) {
 $app-&gt;response-&gt;has_passed(1);
 return;
 }

 my $view_path = $template-&gt;view_pathname($page);

 if ( !-f $view_path ) {
 $app-&gt;response-&gt;has_passed(1);
 return;
 }

 my $ct = $template-&gt;process( $page );
 $app-&gt;response-&gt;header( 'Content-Length', length($ct) );
 return ( $app-&gt;request-&gt;method eq 'GET' ) ? $ct : '';
 };
 }</code></pre>

<p>The <code>code</code> method passed the <a href="https://metacpan.org/pod/Dancer2::Core::App">Dancer2::Core::App</a> object which provides access to anything needed to process the request.</p>

<p>A <code>register</code> is then implemented to add the route to the registry and if the <code>auto_page setting</code> is off, it does nothing.</p>

<pre><code> sub register {
 my ($self, $app) = @_;

 return unless $app-&gt;config-&gt;{auto_page};

 $app-&gt;add_route(
 method =&gt; $_,
 regexp =&gt; $self-&gt;regexp,
 code =&gt; $self-&gt;code,
 ) for $self-&gt;methods;
 }</code></pre>

<p>The config parser looks for a <code>route_handlers</code> section and any handler defined there is loaded. Thus, any random handler can be added to your app. For example, the default config file for any Dancer2 application is as follows:</p>

<pre><code> route_handlers:
 File:
 public_dir: /path/to/public
 AutoPage: 1</code></pre>

<h2 id="ERRORS">ERRORS</h2>

<h2 id="Error-Pages">Error Pages</h2>

<p>When an HTTP error occurs (the action responds with a status code other than 200), Dancer2 first looks in the public directory for a corresponding HTML file matching the error code (eg: 500.html or 404.html).</p>

<p>If such a file exists, it's used to report the error, otherwise, a default error page will be rendered on the fly.</p>

<p>Note that in order to provide more informative diagnostics, the default error page will override the error-code HTML files for errors with a <code>5xx</code> status when <b>show_errors</b> is set to true. For more information see <a href="https://metacpan.org/pod/distribution/Dancer2/lib/Dancer2/Config.pod">Dancer2::Config</a>.</p>

<h2 id="Execution-Errors">Execution Errors</h2>

<p>When an error occurs during the route execution, Dancer2 will render an error page with the HTTP status code 500.</p>

<p>It's possible either to display the content of the error message or to hide it with a generic error page.</p>

<p>This is a choice left to the end-user and can be set with the <b>show_errors</b> setting.</p>

<p>Note that you can also choose to consider all warnings in your route handlers as errors when the setting <b>warnings</b> is set to 1.</p>

<h2 id="Error-handling">Error handling</h2>

<p>When an error is caught by Dancer2's core, an exception object is built (of the class <a href="https://metacpan.org/pod/Dancer2::Core::Error">Dancer2::Core::Error</a>). This class provides a hook to let the user alter the error workflow if needed.</p>

<p><code>init_error</code> hooks are called whenever an error object is built, the object is passed to the hook.</p>

<pre><code> hook init_error =&gt; sub {
 my $error = shift;
 # do something with $error
 };</code></pre>

<p><i>This hook was named <b>before_error_init</b> in Dancer, both names currently are synonyms for backward-compatibility.</i></p>

<p><code>before_error</code> hooks are called whenever an error is going to be thrown, it receives the error object as its sole argument.</p>

<pre><code> hook before_error =&gt; sub {
 my $error = shift;
 # do something with $error
 };</code></pre>

<p><i>This hook was named <b>before_error_render</b> in Dancer, both names currently are synonyms for backward-compatibility.</i></p>

<p><code>after_error</code> hooks are called whenever an error object has been thrown, it receives a <a href="https://metacpan.org/pod/Dancer2::Core::Response">Dancer2::Core::Response</a> object as its sole argument.</p>

<pre><code> hook after_error =&gt; sub {
 my $response = shift;
 };</code></pre>

<p><i>This hook was named <b>after_error_render</b> in Dancer, both names currently are synonyms for backward-compatibility.</i></p>

<p><code>on_route_exception</code> is called when an exception has been caught, at the route level, just before rethrowing it higher. This hook receives a <a href="https://metacpan.org/pod/Dancer2::Core::App">Dancer2::Core::App</a> and the error as arguments.</p>

<pre><code> hook on_route_exception =&gt; sub {
 my ($app, $error) = @_;
 };</code></pre>

<h2 id="SESSIONS">SESSIONS</h2>

<h2 id="Handling-sessions">Handling sessions</h2>

<p>It's common to want to use sessions to give your web applications state; for instance, allowing a user to log in, creating a session, and checking that session on subsequent requests.</p>

<p>By default Dancer 2 has <a href="https://metacpan.org/pod/Dancer2::Session::Simple">Simple</a> sessions enabled. It implements a very simple in-memory session storage. This will be fast and useful for testing, but such sessions will not persist between restarts of your app.</p>

<p>If you'd like to use a different session engine you must declare it in the configuration file.</p>

<p>For example to use YAML file base sessions you need to add the following to your <i>config.yml</i>:</p>

<pre><code> session: YAML</code></pre>

<p>Or, to enable session support from within your code,</p>

<pre><code> set session =&gt; 'YAML';</code></pre>

<p>(However, controlling settings is best done from your config file.)</p>

<p>The <a href="https://metacpan.org/pod/Dancer2::Session::YAML">Dancer2::Session::YAML</a> backend implements a file-based YAML session storage to help with debugging, but shouldn't be used on production systems.</p>

<p>There are other session backends, such as <a href="https://metacpan.org/pod/Dancer2::Session::Memcached">Dancer2::Session::Memcached</a>, which are recommended for production use.</p>

<p>You can then use the <a href="https://metacpan.org/pod/Dancer2#session">session</a> keyword to manipulate the session:</p>

<h3 id="Storing-data-in-the-session">Storing data in the session</h3>

<p>Storing data in the session is as easy as:</p>

<pre><code> session varname =&gt; 'value';</code></pre>

<h3 id="Retrieving-data-from-the-session">Retrieving data from the session</h3>

<p>Retrieving data from the session is as easy as:</p>

<pre><code> session('varname')</code></pre>

<p>Or, alternatively,</p>

<pre><code> session-&gt;read("varname")</code></pre>

<h3 id="Controlling-where-sessions-are-stored">Controlling where sessions are stored</h3>

<p>For disc-based session backends like <a href="https://metacpan.org/pod/Dancer2::Session::YAML">Dancer2::Session::YAML</a>, <a href="https://metacpan.org/pod/Dancer2::Session::Storable">Dancer2::Session::Storable</a> etc., session files are written to the session dir specified by the <code>session_dir</code> setting, which defaults to <code>./sessions</code> if not specifically set.</p>

<p>If you need to control where session files are created, you can do so quickly and easily within your config file, for example:</p>

<pre><code> session: YAML
 engines:
 session:
 YAML:
 session_dir: /tmp/dancer-sessions</code></pre>

<p>If the directory you specify does not exist, Dancer2 will attempt to create it for you.</p>

<h3 id="Destroying-a-session">Destroying a session</h3>

<p>When you're done with your session, you can destroy it:</p>

<pre><code> app-&gt;destroy_session</code></pre>

<h2 id="Sessions-and-logging-in">Sessions and logging in</h2>

<p>A common requirement is to check the user is logged in, and, if not, require them to log in before continuing.</p>

<p>This can easily be handled using a before hook to check their session:</p>

<pre><code> use Dancer2;
 set session =&gt; "Simple";

 hook before =&gt; sub {
 if (!session('user') &amp;&amp; request-&gt;dispatch_path !~ m{^/login}) {
 forward '/login', { requested_path =&gt; request-&gt;dispatch_path };
 }
 };

 get '/' =&gt; sub { return "Home Page"; };

 get '/secret' =&gt; sub { return "Top Secret Stuff here"; };

 get '/login' =&gt; sub {
 # Display a login page; the original URL they requested is available as
 # param('requested_path'), so could be put in a hidden field in the form
 template 'login', { path =&gt; param('requested_path') };
 };

 post '/login' =&gt; sub {
 # Validate the username and password they supplied
 if (param('user') eq 'bob' &amp;&amp; param('pass') eq 'letmein') {
 session user =&gt; param('user');
 redirect param('path') || '/';
 } else {
 redirect '/login?failed=1';
 }
 };

 dance();</code></pre>

<p>Here is what the corresponding <code>login.tt</code> file should look like. You should place it in a directory called <code>views/</code>:</p>

<pre><code> &lt;html&gt;
 &lt;head&gt;
 &lt;title&gt;Session and logging in&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
 &lt;form action='/login' method='POST'&gt;
 User Name : &lt;input type='text' name='user'/&gt;
 Password: &lt;input type='password' name='pass' /&gt;

 &lt;!-- Put the original path requested into a hidden
 field so it's sent back in the POST and can be
 used to redirect to the right page after login --&gt;
 &lt;input type='hidden' name='path' value='[% path %]'/&gt;

 &lt;input type='submit' value='Login' /&gt;
 &lt;/form&gt;
 &lt;/body&gt;
 &lt;/html&gt;</code></pre>

<p>Of course, you'll probably want to validate your users against a database table, or maybe via IMAP/LDAP/SSH/POP3/local system accounts via PAM etc. <a href="https://metacpan.org/pod/Authen::Simple">Authen::Simple</a> is probably a good starting point here!</p>

<p>A simple working example of handling authentication against a database table yourself (using <a href="https://metacpan.org/pod/Dancer2::Plugin::Database">Dancer2::Plugin::Database</a> which provides the <code>database</code> keyword, and <a href="https://metacpan.org/pod/Crypt::SaltedHash">Crypt::SaltedHash</a> to handle salted hashed passwords (well, you wouldn't store your users passwords in the clear, would you?)) follows:</p>

<pre><code> post '/login' =&gt; sub {
 my $user_value = body_parameters-&gt;get('user');
 my $pass_value = body_parameters-&gt;get('pass');

 my $user = database-&gt;quick_select('users',
 { username =&gt; $user_value }
 );
 if (!$user) {
 warning "Failed login for unrecognised user $user_value";
 redirect '/login?failed=1';
 } else {
 if (Crypt::SaltedHash-&gt;validate($user-&gt;{password}, $pass_value))
 {
 debug "Password correct";
 # Logged in successfully
 session user =&gt; $user;
 redirect body_parameters-&gt;get('path') || '/';
 } else {
 debug("Login failed - password incorrect for " . $user_value);
 redirect '/login?failed=1';
 }
 }
 };</code></pre>

<h3 id="Retrieve-complete-hash-stored-in-session">Retrieve complete hash stored in session</h3>

<p>Get complete hash stored in session:</p>

<pre><code> my $hash = session;</code></pre>

<h2 id="Writing-a-session-engine">Writing a session engine</h2>

<p>In Dancer 2, a session backend consumes the role <a href="https://metacpan.org/pod/Dancer2::Core::Role::SessionFactory">Dancer2::Core::Role::SessionFactory</a>.</p>

<p>The following example using the Reddis session demonstrates how session engines are written in Dancer 2.</p>

<p>First thing to do is to create the class for the session engine, we'll name it <code>Dancer2::Session::Redis</code>:</p>

<pre><code> package Dancer2::Session::Redis;
 use Moo;
 with 'Dancer2::Core::Role::SessionFactory';</code></pre>

<p>we want our backend to have a handle over a Redis connection. To do that, we'll create an attribute <code>redis</code></p>

<pre><code> use JSON;
 use Redis;
 use Dancer2::Core::Types; # brings helper for types

 has redis =&gt; (
 is =&gt; 'rw',
 isa =&gt; InstanceOf['Redis'],
 lazy =&gt; 1,
 builder =&gt; '_build_redis',
 );</code></pre>

<p>The lazy attribute says to Moo that this attribute will be built (initialized) only when called the first time. It means that the connection to Redis won't be opened until necessary.</p>

<pre><code> sub _build_redis {
 my ($self) = @_;
 Redis-&gt;new(
 server =&gt; $self-&gt;server,
 password =&gt; $self-&gt;password,
 encoding =&gt; undef,
 );
 }</code></pre>

<p>Two more attributes, <code>server</code> and <code>password</code> need to be created. We do this by defining them in the config file. Dancer2 passes anything defined in the config to the engine creation.</p>

<pre><code> # config.yml
 ...
 engines:
 session:
 Redis:
 server: foo.mydomain.com
 password: S3Cr3t</code></pre>

<p>The server and password entries are now passed to the constructor of the Redis session engine and can be accessed from there.</p>

<pre><code> has server =&gt; (is =&gt; 'ro', required =&gt; 1);
 has password =&gt; (is =&gt; 'ro');</code></pre>

<p>Next, we define the subroutine <code>_retrieve</code> which will return a session object for a session ID it has passed. Since in this case, sessions are going to be stored in Redis, the session ID will be the key, the session the value. So retrieving is as easy as doing a get and decoding the JSON string returned:</p>

<pre><code> sub _retrieve {
 my ($self, $session_id) = @_;
 my $json = $self-&gt;redis-&gt;get($session_id);
 my $hash = from_json( $json );
 return bless $hash, 'Dancer2::Core::Session';
 }</code></pre>

<p>The <code>_flush</code> method is called by Dancer when the session needs to be stored in the backend. That is actually a write to Redis. The method receives a <code>Dancer2::Core::Session</code> object and is supposed to store it.</p>

<pre><code> sub _flush {
 my ($self, $session) = @_;
 my $json = to_json( { %{ $session } } );
 $self-&gt;redis-&gt;set($session-&gt;id, $json);
 }</code></pre>

<p>For the <code>_destroy</code> method which is supposed to remove a session from the backend, deleting the key from Redis is enough.</p>

<pre><code> sub _destroy {
 my ($self, $session_id) = @_;
 $self-&gt;redis-&gt;del($session_id);
 }</code></pre>

<p>The <code>_sessions</code> method which is supposed to list all the session IDs currently stored in the backend is done by listing all the keys that Redis has.</p>

<pre><code> sub _sessions {
 my ($self) = @_;
 my @keys = $self-&gt;redis-&gt;keys('*');
 return \@keys;
 }</code></pre>

<p>The session engine is now ready.</p>

<h3 id="The-Session-keyword">The Session keyword</h3>

<p>When Dancer 2 executes a route handler to process a request, it creates a <a href="https://metacpan.org/pod/Dancer::Core::Context">Dancer::Core::Context</a> object. This context is passed to all the components of Dancer that can play with it, to build the response. For instance, a before hook will receive that context object.</p>

<p>The session handle for the current client, is thus found in the context. Thus, the builder only has to look if the client has a dancer.session cookie, and if so, try to retrieve the session from the storage engine, with the value of the cookie (the session ID).</p>

<pre><code> has session =&gt; (
 is =&gt; 'rw',
 isa =&gt; Session,
 lazy =&gt; 1,
 builder =&gt; '_build_session',
 );

 sub _build_session {
 my ($self) = @_;
 my $session;

 # Find the session engine
 my $engine = $self-&gt;app-&gt;setting('session');
 croak "No session engine defined, cannot use session."
 if ! defined $engine;

 # find the session cookie if any
 my $session_id;
 my $session_cookie = $self-&gt;cookie('dancer.session');
 if (defined $session_cookie) {
 $session_id = $session_cookie-&gt;value;
 }

 # if we have a session cookie, try to retrieve the session
 if (defined $session_id) {
 eval { $session = $engine-&gt;retrieve(id =&gt; $session_id) };
 croak "Fail to retrieve session: $@"
 if $@ &amp;&amp; $@ !~ /Unable to retrieve session/;
 }

 # create the session if none retrieved
 return $session ||= $engine-&gt;create();
 }</code></pre>

<p>So the very first time session is called, the object is either retrieved from the backend, or a new <code>Dancer2::Core::Session</code> is created, and stored in the context. Then, a before hook makes sure a cookie dancer.session is added to the headers.</p>

<pre><code> # Hook to add the session cookie in the headers, if a session is defined
 $self-&gt;add_hook(Dancer2::Core::Hook-&gt;new(
 name =&gt; 'core.app.before_request',
 code =&gt; sub {
 my $context = shift;

 # make sure an engine is defined, if not, nothing to do
 my $engine = $self-&gt;setting('session');
 return if ! defined $engine;

 # push the session in the headers
 $context-&gt;response-&gt;push_header('Set-Cookie',
 $context-&gt;session-&gt;cookie-&gt;to_header);
 }
 ));</code></pre>

<p>At this time, the user's code comes into play, using the session keyword</p>

<pre><code> sub session {
 my ($self, $key, $value) = @_;

 my $session = $self-&gt;context-&gt;session;
 croak "No session available, a session engine needs to be set"
 if ! defined $session;

 # return the session object if no key
 return $session if @_ == 1;

 # read if a key is provided
 return $session-&gt;read($key) if @_ == 2;

 # write to the session
 $session-&gt;write($key =&gt; $value);
 }</code></pre>

<p>To conclude, an <code>after</code> hook is set to call the flush method of the storage backend.</p>

<pre><code> # Hook to flush the session at the end of the request, this way, we're sure we
 # flush only once per request
 $self-&gt;add_hook(
 Dancer2::Core::Hook-&gt;new(
 name =&gt; 'core.app.after_request',
 code =&gt; sub {
 # make sure an engine is defined, if not, nothing to do
 my $engine = $self-&gt;setting('session');
 return if ! defined $engine;
 return if ! defined $self-&gt;context;
 $engine-&gt;flush(session =&gt; $self-&gt;context-&gt;session);
 },
 )
 );</code></pre>

<p>The code for this can be found on <a href="https://github.com/sukria/Dancer-Session-Redis/blob/master/lib/Dancer/Session/Redis.pm">Github</a></p>

<h2 id="TEMPLATES">TEMPLATES</h2>

<p>Returning plain content is all well and good for examples or trivial apps, but soon you'll want to use templates to maintain separation between your code and your content. Dancer2 makes this easy.</p>

<p>Your route handlers can use the <a href="https://metacpan.org/pod/distribution/Dancer2/lib/Dancer2/Manual.pod#template">template</a> keyword to render templates.</p>

<h2 id="Views">Views</h2>

<p>It's possible to render the action's content with a template, this is called a view. The <code>appdir/views</code> directory is the place where views are located.</p>

<p>You can change this location by changing the setting 'views'. For instance if your templates are located in the 'templates' directory, do the following:</p>

<pre><code> set views =&gt; path(dirname(__FILE__), 'templates');</code></pre>

<p>By default, the internal template engine <a href="https://metacpan.org/pod/Dancer2::Template::Simple">Dancer2::Template::Simple</a> is used, but you may want to upgrade to <a href="http://www.template-toolkit.org/">Template Toolkit</a>. If you do so, you have to enable this engine in your settings as explained in <a href="https://metacpan.org/pod/Dancer2::Template::TemplateToolkit">Dancer2::Template::TemplateToolkit</a> and you'll also have to install the <a href="https://metacpan.org/pod/Template">Template</a> module.</p>

<p>In order to render a view, just call the <a href="https://metacpan.org/pod/distribution/Dancer2/lib/Dancer2/Manual.pod#template">template</a> keyword at the end of the action by giving the view name and the HASHREF of tokens to interpolate in the view (note that for convenience, the request, session, params, and vars are automatically accessible in the view, named <code>request</code>, <code>session</code>, <code>params</code> and <code>vars</code>) - for example:</p>

<pre><code> hook before =&gt; sub { var time =&gt; scalar(localtime) };

 get '/hello/:name' =&gt; sub {
 my $name = route_parameters-&gt;get('name');
 template 'hello.tt', { name =&gt; $name };
 };</code></pre>

<p>The template <code>hello.tt</code> could contain, for example:</p>

<pre><code> &lt;p&gt;Hi there, [% name %]!&lt;/p&gt;
 &lt;p&gt;You're using [% request.user_agent %]&lt;/p&gt;
 [% IF session.username %]
 &lt;p&gt;You're logged in as [% session.username %]&lt;/p&gt;
 [% END %]
 It's currently [% vars.time %]</code></pre>

<p>For a full list of the tokens automatically added to your template (like <code>session</code>, <code>request</code>, and <code>vars</code>, refer to <a href="https://metacpan.org/pod/Dancer2::Core::Role::Template">Dancer2::Core::Role::Template</a>).</p>

<p>By default, views use a <i>.tt</i> extension. This can be overridden by setting the <code>extension</code> attribute in the template engine configuration:</p>

<pre><code> set engines =&gt; {
 template =&gt; {
 template_toolkit =&gt; {
 extension =&gt; 'foo',
 },
 },
 };</code></pre>

<h2 id="Layouts">Layouts</h2>

<p>A layout is a special view, located in the <i>layouts</i> directory (inside the views directory) which must have a token named <code>content</code>. That token marks the place where to render the action view. This lets you define a global layout for your actions, and have each individual view contain only specific content. This is a good thing and helps avoid lots of needless duplication of HTML. :)</p>

<p>For example, the layout <i>views/layouts/main.tt</i>:</p>

<pre><code> &lt;html&gt;
 &lt;head&gt;...&lt;/head&gt;
 &lt;body&gt;
 &lt;div id="header"&gt;
 ...
 &lt;/div&gt;

 &lt;div id="content"&gt;
 [% content %]
 &lt;/div&gt;

 &lt;/body&gt;
 &lt;/html&gt;</code></pre>

<p>You can tell your app which layout to use with <code>layout: name</code> in the config file, or within your code:</p>

<pre><code> set layout =&gt; 'main';</code></pre>

<p>You can control which layout to use (or whether to use a layout at all) for a specific request without altering the layout setting by passing an options hashref as the third param to the template keyword:</p>

<pre><code> template 'index.tt', {}, { layout =&gt; undef };</code></pre>

<p>If your application is not mounted under root (<code>/</code>), you can use a <code>before_template</code> hook instead of hardcoding the path into your application for your CSS, images and JavaScript:</p>

<pre><code> hook before_template_render =&gt; sub {
 my $tokens = shift;
 $tokens-&gt;{uri_base} = request-&gt;base-&gt;path;
 };</code></pre>

<p>Then in your layout, modify your CSS inclusion as follows:</p>

<pre><code> &lt;link rel="stylesheet" href="[% uri_base %]/css/style.css" /&gt;</code></pre>

<p>From now on you can mount your application wherever you want, without any further modification of the CSS inclusion.</p>

<h2 id="Encoding">Encoding</h2>

<p>If you use <a href="https://metacpan.org/pod/Plack">Plack</a> and have a Unicode problem with your Dancer2 application, don't forget to check if you have set your template engine to use Unicode, and set the default charset to UTF-8. So, if you are using template toolkit, your config file will look like this:</p>

<pre><code> charset: UTF-8
 engines:
 template:
 template_toolkit:
 ENCODING: utf8</code></pre>

<h2 id="STATIC-FILES">STATIC FILES</h2>

<h2 id="Static-Directory">Static Directory</h2>

<p>Static files are served from the <i>./public</i> directory. You can specify a different location by setting the <code>public_dir</code> option:</p>

<pre><code> set public_dir =&gt; path(dirname(__FILE__), 'static');</code></pre>

<p>When you modify default public_dir you have to set <code>static_handler</code> option.</p>

<pre><code> set static_handler =&gt; true;</code></pre>

<p>Note that the public directory name is not included in the URL. A file <i>./public/css/style.css</i> is made available as <a href="http://example.com/css/style.css">http://example.com/css/style.css</a>.</p>

<h2 id="Static-File-from-a-Route-Handler">Static File from a Route Handler</h2>

<p>It's possible for a route handler to send a static file, as follows:</p>

<pre><code> get '/download/*' =&gt; sub {
 my ($file) = splat;

 send_file $file;
 };</code></pre>

<p>Or even if you want your index page to be a plain old <i>index.html</i> file, just do:</p>

<pre><code> get '/' =&gt; sub {
 send_file '/index.html'
 };</code></pre>

<h2 id="FILE-UPLOADS">FILE UPLOADS</h2>

<p>Files are uploaded in Dancer2 using the class <a href="https://metacpan.org/pod/Dancer2::Core::Request::Upload">Dancer2::Core::Request::Upload</a>. The objects are accessible within the route handlers using the <code>upload</code> keyword:</p>

<pre><code> post '/upload/:file' =&gt; sub {
 my $upload_dir = "MyApp/UPLOADS";
 my $filename = route_parameters-&gt;get('file') # route param
 my $upload = upload('file_input_name'); # upload object
 $upload-&gt;copy_to("$upload_dir/$filename");
 };</code></pre>

<h2 id="CONFIGURATION">CONFIGURATION</h2>

<h2 id="Configuration-and-environments">Configuration and environments</h2>

<p>Configuring a Dancer2 application can be done in many ways. The easiest one (and maybe the dirtiest) is to put all your settings statements at the top of your script, before calling the <code>dance()</code> method.</p>

<p>Other ways are possible: for example, you can define all your settings in the file <code>appdir/config.yml</code>. For this, you must have installed the <a href="https://metacpan.org/pod/YAML">YAML</a> module, and of course, write the config file in YAML.</p>

<p>That's better than the first option, but it's still not perfect as you can't switch easily from an environment to another without rewriting the config file.</p>

<p>A better solution is to have one <i>config.yml</i> file with default global settings, like the following:</p>

<pre><code> # appdir/config.yml
 logger: 'file'
 layout: 'main'</code></pre>

<p>And then write as many environment files as you like in <code>appdir/environments</code>. That way, the appropriate environment config file will be loaded according to the running environment (if none is specified, it will be 'development').</p>

<p>Note that you can change the running environment using the <code>--environment</code> command line switch.</p>

<p>Typically, you'll want to set the following values in a development config file:</p>

<pre><code> # appdir/environments/development.yml
 log: 'debug'
 startup_info: 1
 show_errors: 1</code></pre>

<p>And in a production one:</p>

<pre><code> # appdir/environments/production.yml
 log: 'warning'
 startup_info: 0
 show_errors: 0</code></pre>

<p>Please note that you are not limited to writing configuration files in YAML. Dancer2 supports any file format that is supported by <a href="https://metacpan.org/pod/Config::Any">Config::Any</a>, such as JSON, XML, INI files, and Apache-style config files.</p>



<p>A Dancer2 application can use the <code>config</code> keyword to easily access the settings within its config file, for instance:</p>

<pre><code> get '/appname' =&gt; sub {
 return "This is " . config-&gt;{appname};
 };</code></pre>

<p>This makes keeping your application's settings all in one place simple and easy - you shouldn't need to worry about implementing all that yourself. :)</p>

<h2 id="Settings">Settings</h2>

<p>It's possible to change almost every parameter of the application via the settings mechanism.</p>

<p>A setting is a key/value pair assigned by the keyword <b>set</b>:</p>

<pre><code> set setting_name =&gt; 'setting_value';</code></pre>

<p>More usefully, settings can be defined in a configuration file. Environment-specific settings can also be defined in environment-specific files (for instance, you do not want to show error stacktraces in production, and might want extra logging in development).</p>

<h2 id="Serializers1">Serializers</h2>

<p>When writing a webservice, data serialization/deserialization is a common issue to deal with. Dancer2 can automatically handle that for you, via a serializer.</p>

<p>When setting up a serializer, a new behaviour is authorized for any route handler you define: any non-scalar response will be rendered as a serialized string, via the current serializer.</p>

<p>Here is an example of a route handler that will return a hashref:</p>

<pre><code> use Dancer2;
 set serializer =&gt; 'JSON';

 get '/user/:id/' =&gt; sub {
 { foo =&gt; 42,
 number =&gt; 100234,
 list =&gt; [qw(one two three)],
 }
 };</code></pre>

<p>Dancer2 will render the response via the current serializer.</p>

<p>Hence, with the JSON serializer set, the route handler above would result in a content like the following:</p>

<pre><code> {"number":100234,"foo":42,"list":["one","two","three"]}</code></pre>

<p>If you send a value which is validated serialized data, but is not in the form a key and value pair (such as a serialized string or a JSON array), the data will not be available in <code>params</code> but will be available in <code>request-&gt;data</code>.</p>

<p>The following serializers are available, be aware they dynamically depend on Perl modules you may not have on your system.</p>

<ul>

<li><p><b>JSON</b></p>

<p>Requires <a href="https://metacpan.org/pod/JSON">JSON</a>.</p>

</li>
<li><p><b>YAML</b></p>

<p>Requires <a href="https://metacpan.org/pod/YAML">YAML</a>,</p>

</li>
<li><p><b>XML</b></p>

<p>Requires <a href="https://metacpan.org/pod/XML::Simple">XML::Simple</a>.</p>

</li>
<li><p><b>Mutable</b></p>

<p>Will try to find the appropriate serializer using the <b>Content-Type</b> and <b>Accept-type</b> header of the request.</p>

</li>
</ul>

<h2 id="Importing-using-Appname">Importing using Appname</h2>

<p>An app in Dancer2 uses the class name (defined by the <code>package</code> function) to define the App name. Thus separating the App to multiple files, actually means creating multiple applications. This means that any engine defined in an application, because the application is a complete separate scope, will not be available to a different application:</p>

<pre><code> package MyApp::User {
 use Dancer2;
 set serializer =&gt; 'JSON';
 get '/view' =&gt; sub {...};
 }

 package MyApp::User::Edit {
 use Dancer2;
 get '/edit' =&gt; sub {...};
 }</code></pre>

<p>These are two different Dancer2 Apps. They have different scopes, contexts, and thus different engines. While <code>MyApp::User</code> has a serializer defined, <code>MyApp::User::Edit</code> will not have that configuration.</p>

<p>By using the import option <code>appname</code>, we can ask Dancer2 to extend an App without creating a new one:</p>

<pre><code> package MyApp::User {
 use Dancer2;
 set serializer =&gt; 'JSON';
 get '/view' =&gt; sub {...};
 }

 package MyApp::User::Edit {
 use Dancer2 appname =&gt; 'MyApp::User'; # extending MyApp::User
 get '/edit' =&gt; sub {...};
 }</code></pre>

<p>The import option <code>appname</code> allows you to seamlessly extend Dancer2 Apps without creating unnecessary additional applications or repeat any definitions. This allows you to spread your application routes across multiple files and allow ease of mind when developing it, and accommodate multiple developers working on the same codebase.</p>

<pre><code> # app.pl
 use MyApp::User;
 use MyApp::User::Edit;

 # single application composed of routes provided in multiple files
 MyApp::User-&gt;to_app;</code></pre>

<p>This way only one class needs to be loaded while creating an app:</p>

<pre><code> # app.pl:
 use MyApp::User;
 MyApp::User-&gt;to_app;</code></pre>

<h2 id="LOGGING">LOGGING</h2>

<h2 id="Configuring-logging">Configuring logging</h2>

<p>It's possible to log messages generated by the application and by Dancer2 itself.</p>

<p>To start logging, select the logging engine you wish to use with the <code>logger</code> setting; Dancer2 includes built-in log engines named <code>file</code> and <code>console</code>, which log to a logfile and to the console respectively.</p>

<p>To enable logging to a file, add the following to your config file:</p>

<pre><code> logger: 'file'</code></pre>

<p>Then you can choose which kind of messages you want to actually log:</p>

<pre><code> log: 'core' # will log debug, info, warnings, errors,
 # and messages from Dancer2 itself
 log: 'debug' # will log debug, info, warning and errors
 log: 'info' # will log info, warning and errors
 log: 'warning' # will log warning and errors
 log: 'error' # will log only errors</code></pre>

<p>If you're using the <code>file</code> logging engine, a directory <code>appdir/logs</code> will be created and will host one logfile per environment. The log message contains the time it was written, the PID of the current process, the message and the caller information (file and line).</p>

<h2 id="Logging-your-own-messages">Logging your own messages</h2>

<p>Just call <a href="https://metacpan.org/pod/Dancer2::Manual#debug">debug</a>, <a href="https://metacpan.org/pod/Dancer2::Manual#info">info</a>, <a href="https://metacpan.org/pod/Dancer2::Manual#warning">warning</a> or <a href="https://metacpan.org/pod/Dancer2::Manual#error">error</a> with your message:</p>

<pre><code> debug "This is a debug message from my app.";</code></pre>

<h2 id="TESTING">TESTING</h2>

<h2 id="Using-Plack::Test">Using Plack::Test</h2>

<p><a href="https://metacpan.org/pod/Plack::Test">Plack::Test</a> receives a common web request (using standard <a href="https://metacpan.org/pod/HTTP::Request">HTTP::Request</a> objects), fakes a web server in order to create a proper PSGI request, and sends it to the web application. When the web application returns a PSGI response (which Dancer applications do), it will then convert it to a common web response (as a standard <a href="https://metacpan.org/pod/HTTP::Response">HTTP::Response</a> object).</p>

<p>This allows you to then create requests in your test, create the code reference for your web application, call them, and receive a response object, which can then be tested.</p>

<h3 id="Basic-Example">Basic Example</h3>

<p>Assuming there is a web application:</p>

<pre><code> # MyApp.pm
 package MyApp;
 use Dancer2;
 get '/' =&gt; sub {'OK'};
 1;</code></pre>

<p>The following test <i>base.t</i> is created:</p>

<pre><code> # base.t
 use strict;
 use warnings;
 use Test::More tests =&gt; 2;
 use Plack::Test;
 use HTTP::Request;
 use MyApp;</code></pre>

<p>Creating a coderef for the application using the <code>to_app</code> keyword:</p>

<pre><code> my $app = MyApp-&gt;to_app;</code></pre>

<p>Creating a test object from <a href="https://metacpan.org/pod/Plack::Test">Plack::Test</a> for the application:</p>

<pre><code> my $test = Plack::Test-&gt;create($app);</code></pre>

<p>Creating the first request object and sending it to the test object to receive a response:</p>

<pre><code> my $request = HTTP::Request-&gt;new( GET =&gt; '/' );
 my $response = $test-&gt;request($request);</code></pre>

<p>It can now be tested:</p>

<pre><code> ok( $response-&gt;is_success, '[GET /] Successful request' );
 is( $response-&gt;content, 'OK', '[GET /] Correct content' );</code></pre>

<h3 id="Putting-it-together">Putting it together</h3>

<pre><code> # base.t
 use strict;
 use warnings;
 use Test::More;
 use Plack::Test;
 use HTTP::Request::Common;
 use MyApp;

 my $test = Plack::Test-&gt;create( MyApp-&gt;to_app );
 my $response = $test-&gt;request( GET '/' );

 ok( $response-&gt;is_success, '[GET /] Successful request' );
 is( $response-&gt;content, 'OK', '[GET /] Correct content' );

 done_testing();</code></pre>



<p>Tests can be separated using <a href="https://metacpan.org/pod/Test::More">Test::More</a>'s <code>subtest</code> functionality, thus creating multiple self-contained tests that don't overwrite each other.</p>

<p>Assuming we have a different app that has two states we want to test:</p>

<pre><code> # MyApp.pm
 package MyApp;
 use Dancer2;
 set serializer =&gt; 'JSON';

 get '/' =&gt; sub {
 my $user = param('user');

 $user and return { user =&gt; $user };

 return {};
 };

 1;</code></pre>

<p>This is a contrived example of a route that checks for a user parameter. If it exists, it returns it in a hash with the key 'user'. If not, it returns an empty hash</p>

<pre><code> # param.t
 use strict;
 use warnings;
 use Test::More;
 use Plack::Test;
 use HTTP::Request::Common;
 use MyApp;

 my $test = Plack::Test-&gt;create( MyApp-&gt;to_app );

 subtest 'A empty request' =&gt; sub {
 my $res = $test-&gt;request( GET '/' );
 ok( $res-&gt;is_success, 'Successful request' );
 is( $res-&gt;content '{}', 'Empty response back' );
 };

 subtest 'Request with user' =&gt; sub {
 my $res = $test-&gt;request( GET '/?user=sawyer_x' );
 ok( $res-&gt;is_success, 'Successful request' );
 is( $res-&gt;content '{"user":"sawyer_x"}', 'Empty response back' );
 };

 done_testing();</code></pre>

<h3 id="Cookies">Cookies</h3>

<p>To handle cookies, which are mostly used for maintaining sessions, the following modules can be used:</p>

<ul>

<li><p><a href="https://metacpan.org/pod/Test::WWW::Mechanize::PSGI">Test::WWW::Mechanize::PSGI</a></p>

</li>
<li><p><a href="https://metacpan.org/pod/LWP::Protocol::PSGI">LWP::Protocol::PSGI</a></p>

</li>
<li><p><a href="https://metacpan.org/pod/HTTP::Cookies">HTTP::Cookies</a></p>

</li>
</ul>

<p>Taking the previous test, assuming it actually creates and uses cookies for sessions:</p>

<pre><code> # ... all the use statements
 use HTTP::Cookies;

 my $jar = HTTP::Cookies-&gt;new;
 my $test = Plack::Test-&gt;create( MyApp-&gt;to_app );

 subtest 'A empty request' =&gt; sub {
 my $res = $test-&gt;request( GET '/' );
 ok( $res-&gt;is_success, 'Successful request' );
 is( $res-&gt;content '{}', 'Empty response back' );
 $jar-&gt;extract_cookies($res);
 ok( $jar-&gt;as_string, 'We have cookies!' );
 };

 subtest 'Request with user' =&gt; sub {
 my $req = GET '/?user=sawyer_x';
 $jar-&gt;add_cookie_header($req);
 my $res = $test-&gt;request($req);
 ok( $res-&gt;is_success, 'Successful request' );
 is( $res-&gt;content '{"user":"sawyer_x"}', 'Empty response back' );
 $jar-&gt;extract_cookies($res);

 ok( ! $jar-&gt;as_string, 'All cookies deleted' );
 };

 done_testing();</code></pre>

<p>Here a cookie jar is created, all requests and responses, existing cookies, as well as cookies that were deleted by the response, are checked.</p>

<h3 id="Accessing-the-configuration-file">Accessing the configuration file</h3>

<p>By importing Dancer2 in the command line scripts, there is full access to the configuration using the imported keywords:</p>

<pre><code> use strict;
 use warnings;
 use Test::More;
 use Plack::Test;
 use HTTP::Request::Common;
 use MyApp;
 use Dancer2;

 my $appname = config-&gt;{'appname'};
 diag "Testing $appname";

 # ...</code></pre>

<h2 id="PACKAGING">PACKAGING</h2>

<h2 id="Carton">Carton</h2>

<h3 id="What-it-does">What it does</h3>

<p><a href="https://metacpan.org/pod/Carton">Carton</a> sets up a local copy of your project prerequisites. You only need to define them in a file and ask Carton to download all of them and set them up. When you want to deploy your app, you just carry the git clone and ask Carton to set up the environment again and you will then be able to run it.</p>

<p>The benefits are multifold:</p>

<ul>

<li><p>Local Directory copy</p>

<p>By putting all the dependencies in a local directory, you can make sure they aren't updated by someone else by accident and their versions locked to the version you picked.</p>

</li>
<li><p>Sync versions</p>

<p>Deciding which versions of the dependent modules your project needs allows you to sync this with other developers as well. Now you're all using the same version and they don't change unless you want update the versions you want. When updated everyone again uses the same new version of everything.</p>

</li>
<li><p>Carry only the requirement, not bundled modules</p>

<p>Instead of bundling the modules, you only actually bundle the requirements. Carton builds them for you when you need it.</p>

</li>
</ul>

<h3 id="Setting-it-up">Setting it up</h3>

<p>First set up a new app:</p>

<pre><code> $ dancer2 -a MyApp
 ...</code></pre>

<p>Delete the files that are not needed:</p>

<pre><code> $ rm -f Makefile.PL MANIFEST MANIFEST.SKIP</code></pre>

<p>Create a git repo:</p>

<pre><code> $ git init &amp;&amp; git add . &amp;&amp; git commit -m "initial commit"</code></pre>

<p>Add a requirement using the <a href="https://metacpan.org/pod/cpanfile">cpanfile</a> format:</p>

<pre><code> $ cat &gt; cpanfile
 requires 'Dancer2' =&gt; 0.155000;
 requires 'Template' =&gt; 0;
 recommends 'URL::Encode::XS' =&gt; 0;
 recommends 'CGI::Deurl::XS' =&gt; 0;
 recommends 'HTTP::Parser::XS' =&gt; 0;</code></pre>

<p>Ask carton to set it up:</p>

<pre><code> $ carton install
 Installing modules using [...]
 Successfully installed [...]
 ...
 Complete! Modules were install into [...]/local</code></pre>

<p>Now we have two files: <i>cpanfile</i> and <i>cpanfile.snapshot</i>. We add both of them to our Git repository and we make sure we don't accidentally add the <i>local/</i> directory Carton created which holds the modules it installed:</p>

<pre><code> $ echo local/ &gt;&gt; .gitignore
 $ git add .gitignore cpanfile cpanfile.snapshot
 $ git commit -m "Start using carton"</code></pre>

<p>When we want to update the versions on the production machine, we simply call:</p>

<pre><code> $ carton install --deployment</code></pre>

<p>By using --deployment we make sure we only install the modules we have in our cpanfile.snapshot file and do not fallback to querying the CPAN.</p>

<h2 id="FatPacker">FatPacker</h2>

<p><a href="https://metacpan.org/pod/App::FatPacker">App::FatPacker</a> (using its command line interface, <a href="https://metacpan.org/pod/fatpack">fatpack</a>) packs dependencies into a single file, allowing you to carry a single file instead of a directory tree.</p>

<p>As long as your application is pure-Perl, you could create a single file with your application and all of Dancer2 in it.</p>

<p>The following example will demonstrate how this can be done:</p>

<p>Assuming we have an application in <i>lib/MyApp.pm</i>:</p>

<pre><code> package MyApp;
 use Dancer2;
 get '/' =&gt; sub {'OK'};
 1;</code></pre>

<p>And we have a handler in <i>bin/app.pl</i>:</p>

<pre><code> use strict;
 use warnings;
 use FindBin;
 use lib "$FindBin::Bin/../lib";
 use MyApp;

 MyApp-&gt;to_app;</code></pre>

<p>To fatpack it, we begin by tracing the script:</p>

<pre><code> $ fatpack trace bin/app.pl</code></pre>

<p>This creates a <i>fatpacker.trace</i> file. From this we create the packlists:</p>

<pre><code> $ fatpack packlists-for `cat fatpacker.trace` &gt; packlists</code></pre>

<p>The packlists are stored in a file called <i>packlists</i>.</p>

<p>Now we create the tree using the following command:</p>

<pre><code> $ fatpack tree `cat packlists`</code></pre>

<p>The tree is created under the directory <i>fatlib</i>.</p>

<p>Now we create a file containing the dependency tree, and add our script to it, using the following command:</p>

<pre><code> $ (fatpack file; cat bin/app.pl) &gt; myapp.pl</code></pre>

<p>This creates a file called <i>myapp.pl</i> with everything in it. Dancer2 uses <a href="https://metacpan.org/pod/MIME::Types">MIME::Types</a> which has a database of all MIME types and helps translate those. The small database file containing all of these types is a binary and therefore cannot be fatpacked. Hence, it needs to be copied to the current directory so our script can find it:</p>

<pre><code> $ cp fatlib/MIME/types.db .</code></pre>

<h2 id="MIDDLEWARES">MIDDLEWARES</h2>

<h2 id="Plack-middlewares">Plack middlewares</h2>

<p>If you want to use Plack middlewares, you need to enable them using <a href="https://metacpan.org/pod/Plack::Builder">Plack::Builder</a> as such:</p>

<pre><code> # in app.psgi or any other handler
 use Dancer2;
 use MyWebApp;
 use Plack::Builder;

 builder {
 enable 'Deflater';
 enable 'Session', store =&gt; 'File';
 enable 'Debug', panels =&gt; [ qw&lt;DBITrace Memory Timer&gt; ];
 dance;
 };</code></pre>

<p>The nice thing about this setup is that it will work seamlessly through Plack or through the internal web server.</p>

<pre><code> # load dev web server (without middlewares)
 perl -Ilib app.psgi

 # load plack web server (with middlewares)
 plackup -I lib app.psgi</code></pre>

<p>You do not need to provide different files for either server.</p>

<h3 id="Path-based-middlewares">Path-based middlewares</h3>

<p>If you want to set up a middleware for a specific path, you can do that using <a href="https://metacpan.org/pod/Plack::Builder">Plack::Builder</a> which uses <a href="https://metacpan.org/pod/Plack::App::URLMap">Plack::App::URLMap</a>:</p>

<pre><code> # in your app.psgi or any other handler
 use Dancer2;
 use MyWebApp;
 use Plack::Builder;

 my $special_handler = sub { ... };

 builder {
 mount '/' =&gt; dance;
 mount '/special' =&gt; $special_handler;
 };</code></pre>

<h3 id="Running-on-Perl-web-servers-with-plackup">Running on Perl web servers with plackup</h3>

<p>A number of Perl web servers supporting PSGI are available on CPAN:</p>

<ul>

<li><p><a href="http://search.cpan.org/dist/Starman/">Starman</a></p>

<p><code>Starman</code> is a high performance web server, with support for preforking, signals, multiple interfaces, graceful restarts and dynamic worker pool configuration.</p>

</li>
<li><p><a href="http://search.cpan.org/dist/Twiggy/">Twiggy</a></p>

<p><code>Twiggy</code> is an <code>AnyEvent</code> web server, it's light and fast.</p>

</li>
<li><p><a href="http://search.cpan.org/dist/Corona/">Corona</a></p>

<p><code>Corona</code> is a <code>Coro</code> based web server.</p>

</li>
</ul>

<p>To start your application, just run plackup (see <a href="https://metacpan.org/pod/Plack">Plack</a> and specific servers above for all available options):</p>

<pre><code> $ plackup bin/app.psgi
 $ plackup -E deployment -s Starman --workers=10 -p 5001 -a bin/app.psgi</code></pre>

<p>As you can see, the scaffolded Perl script for your app can be used as a PSGI startup file.</p>

<h4 id="Enabling-content-compression">Enabling content compression</h4>

<p>Content compression (gzip, deflate) can be easily enabled via a Plack middleware (see <a href="https://metacpan.org/pod/Plack#Plack::Middleware">"Plack::Middleware" in Plack</a>): <a href="https://metacpan.org/pod/Plack::Middleware::Deflater">Plack::Middleware::Deflater</a>. It's a middleware to encode the response body in gzip or deflate, based on the <code>Accept-Encoding</code> HTTP request header.</p>

<p>Enable it as you would enable any Plack middleware. First you need to install <a href="https://metacpan.org/pod/Plack::Middleware::Deflater">Plack::Middleware::Deflater</a>, then in the handler (usually <i>app.psgi</i>) edit it to use <a href="https://metacpan.org/pod/Plack::Builder">Plack::Builder</a>, as described above:</p>

<pre><code> use Dancer2;
 use MyWebApp;
 use Plack::Builder;

 builder {
 enable 'Deflater';
 dance;
 };</code></pre>

<p>To test if content compression works, trace the HTTP request and response before and after enabling this middleware. Among other things, you should notice that the response is gzip or deflate encoded, and contains a header <code>Content-Encoding</code> set to <code>gzip</code> or <code>deflate</code>.</p>

<h3 id="Running-multiple-apps-with-Plack::Builder">Running multiple apps with Plack::Builder</h3>

<p>You can use <a href="https://metacpan.org/pod/Plack::Builder">Plack::Builder</a> to mount multiple Dancer2 applications on a <a href="https://metacpan.org/pod/PSGI">PSGI</a> webserver like <a href="https://metacpan.org/pod/Starman">Starman</a>.</p>

<p>Start by creating a simple app.psgi file:</p>

<pre><code> use OurWiki; # first app
 use OurForum; # second app
 use Plack::Builder;

 builder {
 mount '/wiki' =&gt; OurWiki-&gt;to_app;
 mount '/forum' =&gt; OurForum-&gt;to_app;
 };</code></pre>

<p>and now use <a href="https://metacpan.org/pod/Starman">Starman</a></p>

<pre><code> plackup -a app.psgi -s Starman</code></pre>

<p>Currently this still demands the same appdir for both (default circumstance) but in a future version this will be easier to change while staying very simple to mount.</p>

<h3 id="Running-from-Apache-with-Plack">Running from Apache with Plack</h3>

<p>You can run your app from Apache using PSGI (Plack), with a config like the following:</p>

<pre><code> &lt;VirtualHost myapp.example.com&gt;
 ServerName www.myapp.example.com
 ServerAlias myapp.example.com
 DocumentRoot /websites/myapp.example.com

 &lt;Directory /home/myapp/myapp&gt;
 AllowOverride None
 Order allow,deny
 Allow from all
 &lt;/Directory&gt;

 &lt;Location /&gt;
 SetHandler perl-script
 PerlResponseHandler Plack::Handler::Apache2
 PerlSetVar psgi_app /websites/myapp.example.com/app.psgi
 &lt;/Location&gt;

 ErrorLog /websites/myapp.example.com/logs/error_log
 CustomLog /websites/myapp.example.com/logs/access_log common
 &lt;/VirtualHost&gt;</code></pre>

<p>To set the environment you want to use for your application (production or development), you can set it this way:</p>

<pre><code> &lt;VirtualHost&gt;
 ...
 SetEnv DANCER_ENVIRONMENT "production"
 ...
 &lt;/VirtualHost&gt;</code></pre>

<h2 id="PLUGINS">PLUGINS</h2>

<h2 id="Writing-a-plugin">Writing a plugin</h2>

<h3 id="A-plugin-that-does-nothing">A plugin that does nothing</h3>

<p>All that is needed for this is <a href="https://metacpan.org/pod/Dancer2::Plugin">Dancer2::Plugin</a> to provide all the keywords needed to write a plugin.</p>

<pre><code> package Dancer2::Plugin::Kitteh;
 use Dancer2::Plugin;

 # we do nothing, just like most cats do

 register_plugin;

 1;</code></pre>

<h3 id="Introducing-keywords">Introducing keywords</h3>

<p>New keywords that the application will receive when it uses your plugin need to be introduced using the <code>register</code> keyword:</p>

<pre><code> register meow =&gt; sub {
 my ( $dsl ) = plugin_args(@_);
 my $app = $dsl-&gt;app;
 };</code></pre>

<p>The keyword receives an object which represents the DSL object the app is connected to. It can be used in order to access the Dancer2 core application connected to the user's scope.</p>

<p>Whether a keyword is <code>app-global</code>, can also be controlled. It can be called from anywhere in an app or only from a route, which means during a request:</p>

<pre><code> register meow =&gt; sub {
 debug 'Meow!';
 }, { is_global =&gt; 0 };</code></pre>

<h3 id="Route-Decorators">Route Decorators</h3>

<p>Some plugins generate routes from other routes, which makes them look a little bit like route decorators. Take <a href="https://metacpan.org/pod/Dancer2::Plugin::Auth::Tiny">Dancer2::Plugin::Auth::Tiny</a> for example:</p>

<pre><code> get '/private' =&gt; needs login =&gt; sub { ... };</code></pre>

<p>This works by taking the route sub as a parameter and creating its own route which calls it.</p>

<pre><code> package Dancer2::Plugin::OnTuesday;
 # ABSTRACT: Make sure a route only works on Tuesday
 use Dancer2::Plugin;

 register on_tuesday =&gt; sub {
 my ( $dsl, $route_sub, @args ) = plugin_args(@_);

 my $day = (localtime)[6];
 $day == 2 or return pass;

 return $route_sub-&gt;( $dsl, @args );
 };

 register_plugin;</code></pre>

<p>Now the plugin can be used as such:</p>

<pre><code> package MyApp;
 use Dancer2;
 use Dancer2::Plugin::OnTuesday;

 get '/' =&gt; on_tuesday =&gt; sub { ... };

 # every other day
 get '/' =&gt; sub { ... };</code></pre>

<h3 id="Reading-the-configuration">Reading the configuration</h3>

<p>While a user can change the configuration using both the configuration file and the <code>set</code> keyword, a single source is needed for all configuration options for the plugin. This is handled automatically using the <code>plugin_setting</code> keyword:</p>

<pre><code> register meow =&gt; sub {
 my $dsl = shift;
 my $vol = plugin_setting-&gt;{'volume'} || 3;
 };</code></pre>

<h2 id="EXPORTS">EXPORTS</h2>

<p>By default, <code>use Dancer2</code> exports all the DSL keywords and sets up the webapp under the name of the current package. The following tags control exports and webapp namespace.</p>

<ul>

<li><p><b>!keyword</b></p>

<p>If you want to prevent Dancer2 from exporting specific keywords (perhaps you plan to implement them yourself in a different way, or they clash with another module you're loading), you can simply exclude them:</p>

<pre><code> use Test::More;
 use Dancer2 qw(!pass);</code></pre>

<p>The above would import all keywords as usual, with the exception of <code>pass</code>.</p>

</li>
<li><p><b>appname</b></p>

<p>A larger application may split its source between several packages to aid maintainability. Dancer2 will create a separate application for each package, each having separate hooks, config and/or engines. You can force Dancer2 to collect the route and hooks into a single application with the <code>appname</code> tag; e.g.</p>

<pre><code> package MyApp;
 use Dancer2;
 get '/foo' =&gt; sub {...};

 package MyApp::Private;
 use Dancer2 appname =&gt; MyApp;
 get '/bar' =&gt; sub {...};</code></pre>

<p>The above would add the <code>bar</code> route to the MyApp application. Dancer2 will <i>not</i> create an application with the name <code>MyApp::Private</code>.</p>

</li>
<li><p><b>:nopragmas</b></p>

<p>By default <a href="https://metacpan.org/pod/Dancer2">Dancer2</a> will import three pragmas: <a href="https://metacpan.org/pod/strict">strict</a>, <a href="https://metacpan.org/pod/warnings">warnings</a>, and <a href="https://metacpan.org/pod/utf8">utf8</a>. If you require control over the imported pragmas, you can add <b>:nopragmas</b> to the importing flags, in which case Dancer2 will not import any pragmas:</p>

<pre><code> use strict;
 use warnings;
 no warnings 'experimental::smartmatch'; # for example...
 use Dancer2 ':nopragmas'; # do not touch the existing pragmas</code></pre>

<p>This way importing <code>Dancer2</code> does not change the existing pragmas setup you have.</p>

</li>
</ul>

<p>When you <code>use Dancer2</code>, you get an <code>import</code> method added into the current package. This <b>will</b> override previously declared import methods from other sources, such as <a href="https://metacpan.org/pod/Exporter">Exporter</a>. Dancer2 applications support the following tags on import:</p>

<ul>

<li><p><b>with</b></p>

<p>The <code>with</code> tag allows an app to pass one or more config entries to another app, when it <code>use</code>s it.</p>

<pre><code> package MyApp;
 use Dancer2;

 BEGIN { set session =&gt; 'YAML' };
 use Blog with =&gt; { session =&gt; engine('session') };</code></pre>

<p>In this example, the session engine is passed to the <code>Blog</code> app. That way, anything done in the session will be shared between both apps.</p>

<p>Anything that is defined in the config entry can be passed that way. If we want to pass the whole config object, it can be done like so:</p>

<pre><code> use SomeApp with =&gt; { %{config()} };</code></pre>

</li>
</ul>

<h2 id="DSL-KEYWORDS">DSL KEYWORDS</h2>

<p>Dancer2 provides you with a DSL (Domain-Specific Language) which makes implementing your web application trivial.</p>

<p>For example, take the following example:</p>

<pre><code> use Dancer2;

 get '/hello/:name' =&gt; sub {
 my $name = route_parameters-&gt;get('name');
 };
 dance;</code></pre>

<p><code>get</code> and <code>route_parameters</code> are keywords provided by Dancer2.</p>

<p>This document lists all keywords provided by Dancer2. It does not cover additional keywords which may be provided by loaded plugins; see the documentation for plugins you use to see which additional keywords they make available to you.</p>

<h2 id="any">any</h2>

<p>Defines a route for multiple HTTP methods at once:</p>

<pre><code> any ['get', 'post'] =&gt; '/myaction' =&gt; sub {
 # code
 };</code></pre>

<p>Or even, a route handler that would match any HTTP methods:</p>

<pre><code> any '/myaction' =&gt; sub {
 # code
 };</code></pre>

<h2 id="cookies">cookies</h2>

<p>Accesses cookies values, it returns a hashref of <a href="https://metacpan.org/pod/Dancer2::Core::Cookie">Dancer2::Core::Cookie</a> objects:</p>

<pre><code> get '/some_action' =&gt; sub {
 my $cookie = cookies-&gt;{name};
 return $cookie-&gt;value;
 };</code></pre>

<p>In case you have stored something other than a scalar in your cookie:</p>

<pre><code> get '/some_action' =&gt; sub {
 my $cookie = cookies-&gt;{oauth};
 my %values = $cookie-&gt;value;
 return ($values{token}, $values{token_secret});
 };</code></pre>

<h2 id="cookie">cookie</h2>

<p>Accesses a cookie value (or sets it). Note that this method will eventually be preferred over <code>set_cookie</code>.</p>

<pre><code> cookie lang =&gt; "fr-FR"; # set a cookie and return its value
 cookie lang =&gt; "fr-FR", expires =&gt; "2 hours"; # extra cookie info
 cookie "lang" # return a cookie value</code></pre>

<p>If your cookie value is a key/value URI string, like</p>

<pre><code> token=ABC&amp;user=foo</code></pre>

<p><code>cookie</code> will only return the first part (<code>token=ABC</code>) if called in scalar context. Use list context to fetch them all:</p>

<pre><code> my @values = cookie "name";</code></pre>

<h2 id="config">config</h2>

<p>Accesses the configuration of the application:</p>

<pre><code> get '/appname' =&gt; sub {
 return "This is " . config-&gt;{appname};
 };</code></pre>

<h2 id="content">content</h2>

<p>Sets the content for the response. This <b>only</b> works within a delayed response.</p>

<p>This will crash:</p>

<pre><code> get '/' =&gt; sub {
 # THIS WILL CRASH
 content 'Hello, world!';
 };</code></pre>

<p>But this will work just fine:</p>

<pre><code> get '/' =&gt; sub {
 delayed {
 content 'Hello, world!';
 ...
 };
 };</code></pre>

<h2 id="content_type">content_type</h2>

<p>Sets the <b>content-type</b> rendered, for the current route handler:</p>

<pre><code> get '/cat/:txtfile' =&gt; sub {
 content_type 'text/plain';

 # here we can dump the contents of param('txtfile')
 };</code></pre>

<p>You can use abbreviations for content types. For instance:</p>

<pre><code> get '/svg/:id' =&gt; sub {
 content_type 'svg';

 # here we can dump the image with id param('id')
 };</code></pre>

<p>Note that if you want to change the default content-type for every route, it is easier to change the <code>content_type</code> setting instead.</p>

<h2 id="dance">dance</h2>

<p>Alias for the <code>start</code> keyword.</p>

<h2 id="dancer_version">dancer_version</h2>

<p>Returns the version of Dancer. If you need the major version, do something like:</p>

<pre><code> int(dancer_version);</code></pre>

<h2 id="debug">debug</h2>

<p>Logs a message of debug level:</p>

<pre><code> debug "This is a debug message";</code></pre>

<p>See <a href="https://metacpan.org/pod/Dancer2::Core::Role::Logger">Dancer2::Core::Role::Logger</a> for details on how to configure where log messages go.</p>

<h2 id="dirname">dirname</h2>

<p>Returns the dirname of the path given:</p>

<pre><code> my $dir = dirname($some_path);</code></pre>

<h2 id="engine">engine</h2>

<p>Given a namespace, returns the current engine object</p>

<pre><code> my $template_engine = engine 'template';
 my $html = $template_engine-&gt;apply_renderer(...);
 $template_engine-&gt;apply_layout($html);</code></pre>

<h2 id="error">error</h2>

<p>Logs a message of error level:</p>

<pre><code> error "This is an error message";</code></pre>

<p>See <a href="https://metacpan.org/pod/Dancer2::Core::Role::Logger">Dancer2::Core::Role::Logger</a> for details on how to configure where log messages go.</p>

<h2 id="false">false</h2>

<p>Constant that returns a false value (0).</p>

<h2 id="forward">forward</h2>

<p>Runs an "internal redirect" of the current route to another route. More formally; when <code>forward</code> is executed, the current dispatch of the route is aborted, the request is modified (altering query params or request method), and the modified request following a new route is dispatched again. Any remaining code (route and hooks) from the current dispatch will never be run and the modified route's dispatch will execute hooks for the new route normally.</p>

<p>It effectively lets you chain routes together in a clean manner.</p>

<pre><code> get '/demo/articles/:article_id' =&gt; sub {

 # you'll have to implement this next sub yourself :)
 change_the_main_database_to_demo();

 forward "/articles/" . params-&gt;{article_id};
 };</code></pre>

<p>In the above example, the users that reach <i>/demo/articles/30</i> will actually reach <i>/articles/30</i> but we've changed the database to demo before.</p>

<p>This is pretty cool because it lets us retain our paths and offer a demo database by merely going to <i>/demo/...</i>.</p>

<p>You'll notice that in the example we didn't indicate whether it was <b>GET</b> or <b>POST</b>. That is because <code>forward</code> chains the same type of route the user reached. If it was a <b>GET</b>, it will remain a <b>GET</b> (but if you do need to change the method, you can do so; read on below for details.)</p>

<p>Also notice that <code>forward</code> only redirects to a new route. It does not redirect the requests involving static files. This is because static files are handled before <a href="https://metacpan.org/pod/Dancer2">Dancer2</a> tries to match the request to a route - static files take higher precedence.</p>

<p>This means that you will not be able to <code>forward</code> to a static file. If you wish to do so, you have two options: either redirect (asking the browser to make another request, but to a file path instead) or use <code>send_file</code> to provide a file.</p>

<p><b>WARNING:</b> Any code after a <code>forward</code> is ignored, until the end of the route. It's not necessary to use <code>return</code> with <code>forward</code> anymore.</p>

<pre><code> get '/foo/:article_id' =&gt; sub {
 if ($condition) {
 forward "/articles/" . params-&gt;{article_id};
 # The following code WILL NOT BE executed
 do_stuff();
 }

 more_stuff();
 };</code></pre>

<p>Note that <code>forward</code> doesn't parse GET arguments. So, you can't use something like:</p>

<pre><code> forward '/home?authorized=1';</code></pre>

<p>But <code>forward</code> supports an optional hashref with parameters to be added to the actual parameters:</p>

<pre><code> forward '/home', { authorized =&gt; 1 };</code></pre>

<p>Finally, you can add some more options to the <code>forward</code> method, in a third argument, also as a hashref. That option is currently only used to change the method of your request. Use with caution.</p>

<pre><code> forward '/home', { auth =&gt; 1 }, { method =&gt; 'POST' };</code></pre>

<h2 id="from_dumper-structure">from_dumper ($structure)</h2>

<p>Deserializes a Data::Dumper structure.</p>

<h2 id="from_json-structure-options">from_json ($structure, \%options)</h2>

<p>Deserializes a JSON structure. Can receive optional arguments. Those arguments are valid <a href="https://metacpan.org/pod/JSON">JSON</a> arguments to change the behaviour of the default <code>JSON::from_json</code> function.</p>

<h2 id="from_yaml-structure">from_yaml ($structure)</h2>

<p>Deserializes a YAML structure.</p>

<h2 id="get">get</h2>

<p>Defines a route for HTTP <b>GET</b> requests to the given path:</p>

<pre><code> get '/' =&gt; sub {
 return "Hello world";
 }</code></pre>

<p>Note that a route to match <b>HEAD</b> requests is automatically created as well.</p>

<h2 id="halt">halt</h2>

<p>Sets a response object with the content given.</p>

<p>When used as a return value from a hook, this breaks the execution flow and renders the response immediately:</p>

<pre><code> hook before =&gt; sub {
 if ($some_condition) {
 halt("Unauthorized");

 # this code is not executed
 do_stuff();
 }
 };

 get '/' =&gt; sub {
 "hello there";
 };</code></pre>

<p><b>WARNING:</b> Issuing a halt immediately exits the current route, and performs the halt. Thus, any code after a halt is ignored, until the end of the route. Hence, it's not necessary anymore to use <code>return</code> with halt.</p>



<p>Adds custom headers to responses:</p>

<pre><code> get '/send/headers', sub {
 headers 'X-Foo' =&gt; 'bar', 'X-Bar' =&gt; 'foo';
 }</code></pre>



<p>adds a custom header to response:</p>

<pre><code> get '/send/header', sub {
 header 'x-my-header' =&gt; 'shazam!';
 }</code></pre>

<p>Note that it will overwrite the old value of the header, if any. To avoid that, see <a href="https://metacpan.org/pod/Dancer2::Manual#push_header">"push_header"</a>.</p>



<p>Do the same as <code>header</code>, but allow for multiple headers with the same name.</p>

<pre><code> get '/send/header', sub {
 push_header 'x-my-header' =&gt; '1';
 push_header 'x-my-header' =&gt; '2';
 will result in two headers "x-my-header" in the response
 }</code></pre>

<h2 id="hook">hook</h2>

<p>Adds a hook at some position. For example :</p>

<pre><code> hook before_serializer =&gt; sub {
 my $content = shift;
 ...
 };</code></pre>

<p>There can be multiple hooks assigned to a given position, and each will be executed in order.</p>



<p>Logs a message of <code>info</code> level:</p>

<pre><code> info "This is an info message";</code></pre>

<p>See <a href="https://metacpan.org/pod/Dancer2::Core::Role::Logger">Dancer2::Core::Role::Logger</a> for details on how to configure where log messages go.</p>

<h2 id="mime">mime</h2>

<p>Shortcut to access the instance object of <a href="https://metacpan.org/pod/Dancer2::Core::MIME">Dancer2::Core::MIME</a>. You should read the <a href="https://metacpan.org/pod/Dancer2::Core::MIME">Dancer2::Core::MIME</a> documentation for full details, but the most commonly-used methods are summarized below:</p>

<pre><code> # set a new mime type
 mime-&gt;add_type( foo =&gt; 'text/foo' );

 # set a mime type alias
 mime-&gt;add_alias( f =&gt; 'foo' );

 # get mime type for an alias
 my $m = mime-&gt;for_name( 'f' );

 # get mime type for a file (based on extension)
 my $m = mime-&gt;for_file( "foo.bar" );

 # get current defined default mime type
 my $d = mime-&gt;default;

 # set the default mime type using config.yml
 # or using the set keyword
 set default_mime_type =&gt; 'text/plain';</code></pre>

<h2 id="params">params</h2>

<p><i>This method should be called from a route handler</i>. It's an alias for the <a href="https://metacpan.org/pod/Dancer2::Core::Request#params-source">Dancer2::Core::Request params accessor</a>. It returns a hash (in list context) or a hash reference (in scalar context) to all defined parameters. Check <code>param</code> below to access quickly to a single parameter value.</p>

<p>We now recommend using one of the specific keywords for parameters (<code>route_parameters</code>, <code>query_parameters</code>, and <code>body_parameters</code>) instead of <code>params</code> or <code>param</code>.</p>

<h2 id="param">param</h2>

<p><i>This method should be called from a route handler</i>. This method is an accessor to the parameters hash table.</p>

<pre><code> post '/login' =&gt; sub {
 my $username = param "user";
 my $password = param "pass";
 # ...
 }</code></pre>

<p>We now recommend using one of the specific keywords for parameters (<code>route_parameters</code>, <code>query_parameters</code>, and <code>body_parameters</code>) instead of <code>params</code> or <code>param</code>.</p>

<h2 id="route_parameters">route_parameters</h2>

<p>Returns a <a href="https://metacpan.org/pod/Hash::MultiValue">Hash::MultiValue</a> object from the route parameters.</p>

<pre><code> # /hello
 get '/:foo' =&gt; sub {
 my $foo = route_parameters-&gt;get('foo');
 };</code></pre>

<h2 id="query_parameters">query_parameters</h2>

<p>Returns a <a href="https://metacpan.org/pod/Hash::MultiValue">Hash::MultiValue</a> object from the request parameters.</p>

<pre><code> /?foo=hello
 get '/' =&gt; sub {
 my $name = query_parameters-&gt;get('foo');
 };

 /?name=Alice&amp;name=Bob
 get '/' =&gt; sub {
 my @names = query_parameters-&gt;get_all('name');
 };</code></pre>

<h2 id="body_parameters">body_parameters</h2>

<p>Returns a <a href="https://metacpan.org/pod/Hash::MultiValue">Hash::MultiValue</a> object from the body parameters.</p>

<pre><code> post '/' =&gt; sub {
 my $last_name = body_parameters-&gt;get('name');
 my @all_names = body_parameters-&gt;get('name');
 };</code></pre>

<h2 id="pass">pass</h2>

<p><i>This method should be called from a route handler</i>. Tells Dancer2 to pass the processing of the request to the next matching route.</p>

<p><b>WARNING:</b> Issuing a pass immediately exits the current route, and performs the pass. Thus, any code after a pass is ignored, until the end of the route. Hence, it's not necessary anymore to use <code>return</code> with pass.</p>

<pre><code> get '/some/route' =&gt; sub {
 if (...) {
 # we want to let the next matching route handler process this one
 pass(...);

 # this code will be ignored
 do_stuff();
 }
 };</code></pre>

<p><b>WARNING:</b> You cannot set the content before passing and have it remain, even if you use the <code>content</code> keyword or set it directly in the response object.</p>

<h2 id="patch">patch</h2>

<p>Defines a route for HTTP <b>PATCH</b> requests to the given URL:</p>

<pre><code> patch '/resource' =&gt; sub { ... };</code></pre>

<p>(<code>PATCH</code> is a relatively new and not-yet-common HTTP verb, which is intended to work as a "partial-PUT", transferring just the changes; please see <a href="http://tools.ietf.org/html/rfc5789">RFC5789</a> for further details.)</p>

<h2 id="path">path</h2>

<p>Concatenates multiple paths together, without worrying about the underlying operating system:</p>

<pre><code> my $path = path(dirname($0), 'lib', 'File.pm');</code></pre>

<p>It also normalizes (cleans) the path aesthetically. It does not verify whether the path exists, though.</p>

<h2 id="post">post</h2>

<p>Defines a route for HTTP <b>POST</b> requests to the given URL:</p>

<pre><code> post '/' =&gt; sub {
 return "Hello world";
 }</code></pre>

<h2 id="prefix">prefix</h2>

<p>Defines a prefix for each route handler, like this:</p>

<pre><code> prefix '/home';</code></pre>

<p>From here, any route handler is defined to /home/*:</p>

<pre><code> get '/page1' =&gt; sub {}; # will match '/home/page1'</code></pre>

<p>You can unset the prefix value:</p>

<pre><code> prefix undef;
 get '/page1' =&gt; sub {}; # will match /page1</code></pre>

<p>For a safer alternative you can use lexical prefix like this:</p>

<pre><code> prefix '/home' =&gt; sub {
 ## Prefix is set to '/home' here

 get ...;
 get ...;
 };
 ## prefix reset to the previous version here</code></pre>

<p>This makes it possible to nest prefixes:</p>

<pre><code> prefix '/home' =&gt; sub {
 ## some routes

 prefix '/private' =&gt; sub {
 ## here we are under /home/private...

 ## some more routes
 };
 ## back to /home
 };
 ## back to the root</code></pre>

<p><b>Notice:</b> Once you have a prefix set, do not add a caret to the regex:</p>

<pre><code> prefix '/foo';
 get qr{^/bar} =&gt; sub { ... } # BAD BAD BAD
 get qr{/bar} =&gt; sub { ... } # Good!</code></pre>

<h2 id="del">del</h2>

<p>Defines a route for HTTP <b>DELETE</b> requests to the given URL:</p>

<pre><code> del '/resource' =&gt; sub { ... };</code></pre>

<h2 id="options">options</h2>

<p>Defines a route for HTTP <b>OPTIONS</b> requests to the given URL:</p>

<pre><code> options '/resource' =&gt; sub { ... };</code></pre>

<h2 id="put">put</h2>

<p>Defines a route for HTTP <b>PUT</b> requests to the given URL:</p>

<pre><code> put '/resource' =&gt; sub { ... };</code></pre>

<h2 id="redirect">redirect</h2>

<p>Generates a HTTP redirect (302). You can either redirect to a complete different site or within the application:</p>

<pre><code> get '/twitter', sub {
 redirect 'http://twitter.com/me';
 # Any code after the redirect will not be executed.
 };</code></pre>

<p><b>WARNING:</b> Issuing a <code>redirect</code> immediately exits the current route. Thus, any code after a <code>redirect</code> is ignored, until the end of the route. Hence, it's not necessary anymore to use <code>return</code> with <code>redirect</code>.</p>

<p>You can also force Dancer to return a specific 300-ish HTTP response code:</p>

<pre><code> get '/old/:resource', sub {
 redirect '/new/'.params-&gt;{resource}, 301;
 };</code></pre>

<h2 id="request">request</h2>

<p>Returns a <a href="https://metacpan.org/pod/Dancer2::Core::Request">Dancer2::Core::Request</a> object representing the current request.</p>

<p>See the <a href="https://metacpan.org/pod/Dancer2::Core::Request">Dancer2::Core::Request</a> documentation for the methods you can call, for example:</p>

<pre><code> request-&gt;referer; # value of the HTTP referer header
 request-&gt;remote_address; # user's IP address
 request-&gt;user_agent; # User-Agent header value</code></pre>

<h2 id="send_error">send_error</h2>

<p>Returns a HTTP error. By default the HTTP code returned is 500:</p>

<pre><code> get '/photo/:id' =&gt; sub {
 if (...) {
 send_error("Not allowed", 403);
 } else {
 # return content
 }
 }</code></pre>

<p><b>WARNING:</b> Issuing a send_error immediately exits the current route, and performs the <code>send_error</code>. Thus, any code after a <code>send_error</code> is ignored, until the end of the route. Hence, it's not necessary anymore to use <code>return</code> with <code>send_error</code>.</p>

<pre><code> get '/some/route' =&gt; sub {
 if (...) {
 # Something bad happened, stop immediately!
 send_error(..);

 # this code will be ignored
 do_stuff();
 }
 };</code></pre>

<h2 id="send_file">send_file</h2>

<p>Lets the current route handler send a file to the client. Note that the path of the file must be relative to the <b>public</b> directory unless you use the <code>system_path</code> option (see below).</p>

<pre><code> get '/download/:file' =&gt; sub {
 return send_file(params-&gt;{file});
 }</code></pre>

<p><b>WARNING:</b> Issuing a <code>send_file</code> immediately exits the current route, and performs the <code>send_file</code>. Thus, any code after a <code>send_file</code> is ignored, until the end of the route. Hence, it's not necessary anymore to use <code>return</code> with <code>send_file</code>.</p>

<pre><code> get '/some/route' =&gt; sub {
 if (...) {
 # OK, send her what she wants...
 send_file(...);

 # this code will be ignored
 do_stuff();
 }
 };</code></pre>

<p><code>send_file</code> will use PSGI streaming if the server supports it (most, if not all, do). You can explicitly disable streaming by passing <code>streaming =</code> 0&gt; as an option to <code>send_file</code>.</p>

<pre><code> get '/download/:file' =&gt; sub {
 send_file( params-&gt;{file}, streaming =&gt; 0 );
 }</code></pre>

<p>The content-type will be set depending on the current MIME types definition (see <code>mime</code> if you want to define your own).</p>

<p>If your filename does not have an extension, you are passing in a filehandle, or you need to force a specific mime type, you can pass it to <code>send_file</code> as follows:</p>

<pre><code> send_file(params-&gt;{file}, content_type =&gt; 'image/png');
 send_file($fh, content_type =&gt; 'image/png');</code></pre>

<p>Also, you can use your aliases or file extension names on <code>content_type</code>, like this:</p>

<pre><code> send_file(params-&gt;{file}, content_type =&gt; 'png');</code></pre>

<p>For files outside your <b>public</b> folder, you can use the <code>system_path</code> switch. Just bear in mind that its use needs caution as it can be dangerous.</p>

<pre><code> send_file('/etc/passwd', system_path =&gt; 1);</code></pre>

<p>If you have your data in a scalar variable, <code>send_file</code> can be useful as well. Pass a reference to that scalar, and <code>send_file</code> will behave as if there was a file with that contents:</p>

<pre><code> send_file( \$data, content_type =&gt; 'image/png' );</code></pre>

<p>Note that Dancer is unable to guess the content type from the data contents. Therefore you might need to set the <code>content_type</code> properly. For this kind of usage an attribute named <code>filename</code> can be useful. It is used as the Content-Disposition header, to hint the browser about the filename it should use.</p>

<pre><code> send_file( \$data, content_type =&gt; 'image/png'
 filename =&gt; 'onion.png' );</code></pre>

<h2 id="set">set</h2>

<p>Defines a setting:</p>

<pre><code> set something =&gt; 'value';</code></pre>

<p>You can set more than one value at once:</p>

<pre><code> set something =&gt; 'value', otherthing =&gt; 'othervalue';</code></pre>

<h2 id="setting">setting</h2>

<p>Returns the value of a given setting:</p>

<pre><code> setting('something'); # 'value'</code></pre>

<h2 id="session">session</h2>

<p>Provides access to all data stored in the user's session (if any).</p>

<p>It can also be used as a setter to store data in the session:</p>

<pre><code> # getter example
 get '/user' =&gt; sub {
 if (session('user')) {
 return "Hello, ".session('user')-&gt;name;
 }
 };

 # setter example
 post '/user/login' =&gt; sub {
 ...
 if ($logged_in) {
 session user =&gt; $user;
 }
 ...
 };</code></pre>

<p>You may also need to clear a session:</p>

<pre><code> # destroy session
 get '/logout' =&gt; sub {
 ...
 app-&gt;destroy_session;
 ...
 };</code></pre>

<p>If you need to fetch the session ID being used for any reason:</p>

<pre><code> my $id = session-&gt;id;</code></pre>

<h2 id="splat">splat</h2>

<p>Returns the list of captures made from a route handler with a route pattern which includes wildcards:</p>

<pre><code> get '/file/*.*' =&gt; sub {
 my ($file, $extension) = splat;
 ...
 };</code></pre>

<p>There is also the extensive splat (A.K.A. "megasplat"), which allows extensive greedier matching, available using two asterisks. The additional path is broken down and returned as an arrayref:</p>

<pre><code> get '/entry/*/tags/**' =&gt; sub {
 my ( $entry_id, $tags ) = splat;
 my @tags = @{$tags};
 };</code></pre>

<p>The <code>splat</code> keyword in the above example for the route <i>/entry/1/tags/one/two</i> would set <code>$entry_id</code> to <code>1</code> and <code>$tags</code> to <code>['one', 'two']</code>.</p>

<h2 id="start">start</h2>

<p>Starts the application or the standalone server (depending on the deployment choices).</p>

<p>This keyword should be called at the very end of the script, once all routes are defined. At this point, Dancer2 takes over.</p>

<h2 id="to_app">to_app</h2>

<p>Returns the PSGI coderef for the current (and only the current) application.</p>

<p>You can call it as a method on the class or as a DSL:</p>

<pre><code> my $app = MyApp-&gt;to_app;

 # or

 my $app = to_app;</code></pre>

<p>There is a <a href="http://advent.perldancer.org/2014/9">Dancer Advent Calendar article</a> covering this keyword and its usage further.</p>

<h2 id="psgi_app">psgi_app</h2>

<p>Provides the same functionality as <code>to_app</code> but uses the deprecated Dispatcher engine. You should use <code>to_app</code> instead.</p>

<h2 id="status">status</h2>

<p>Changes the status code provided by an action. By default, an action will produce an <code>HTTP 200 OK</code> status code, meaning everything is OK:</p>

<pre><code> get '/download/:file' =&gt; {
 if (! -f params-&gt;{file}) {
 status 'not_found';
 return "File does not exist, unable to download";
 }
 # serving the file...
 };</code></pre>

<p>In that example, Dancer will notice that the status has changed, and will render the response accordingly.</p>

<p>The <code>status</code> keyword receives either a numeric status code or its name in lower case, with underscores as a separator for blanks - see the list in <a href="https://metacpan.org/pod/Dancer2::Core::HTTP#HTTP-CODES">"HTTP CODES" in Dancer2::Core::HTTP</a>. As an example, The above call translates to setting the code to <code>404</code>.</p>

<h2 id="template">template</h2>

<p>Returns the response of processing the given template with the given parameters (and optional settings), wrapping it in the default or specified layout too, if layouts are in use.</p>

<p>An example of a route handler which returns the result of using template to build a response with the current template engine:</p>

<pre><code> get '/' =&gt; sub {
 ...
 return template 'some_view', { token =&gt; 'value'};
 };</code></pre>

<p>Note that <code>template</code> simply returns the content, so when you use it in a route handler, if execution of the route handler should stop at that point, make sure you use <code>return</code> to ensure your route handler returns the content.</p>

<p>Since <code>template</code> just returns the result of rendering the template, you can also use it to perform other templating tasks, e.g. generating emails:</p>

<pre><code> post '/some/route' =&gt; sub {
 if (...) {
 email {
 to =&gt; 'someone@example.com',
 from =&gt; 'foo@example.com',
 subject =&gt; 'Hello there',
 msg =&gt; template('emails/foo', { name =&gt; params-&gt;{name} }),
 };

 return template 'message_sent';
 } else {
 return template 'error';
 }
 };</code></pre>

<p>Compatibility notice: <code>template</code> was changed in version 1.3090 to immediately interrupt execution of a route handler and return the content, as it's typically used at the end of a route handler to return content. However, this caused issues for some people who were using <code>template</code> to generate emails etc, rather than accessing the template engine directly, so this change has been reverted in 1.3091.</p>

<p>The first parameter should be a template available in the views directory, the second one (optional) is a hashref of tokens to interpolate, and the third (again optional) is a hashref of options.</p>

<p>For example, to disable the layout for a specific request:</p>

<pre><code> get '/' =&gt; sub {
 template 'index', {}, { layout =&gt; undef };
 };</code></pre>

<p>Or to request a specific layout, of course:</p>

<pre><code> get '/user' =&gt; sub {
 template 'user', {}, { layout =&gt; 'user' };
 };</code></pre>

<p>Some tokens are automatically added to your template (<code>perl_version</code>, <code>dancer_version</code>, <code>settings</code>, <code>request</code>, <code>params</code>, <code>vars</code> and, if you have sessions enabled, <code>session</code>). Check <a href="https://metacpan.org/pod/Dancer2::Core::Role::Template">Dancer2::Core::Role::Template</a> for further details.</p>

<h2 id="to_dumper-structure">to_dumper ($structure)</h2>

<p>Serializes a structure with Data::Dumper.</p>

<p>Calling this function will <b>not</b> trigger the serialization's hooks.</p>

<h2 id="to_json-structure-options">to_json ($structure, \%options)</h2>

<p>Serializes a structure to JSON. Can receive optional arguments. Those arguments are valid <a href="https://metacpan.org/pod/JSON">JSON</a> arguments to change the behaviour of the default <code>JSON::to_json</code> function.</p>

<p>Calling this function will <b>not</b> trigger the serialization's hooks.</p>

<h2 id="to_yaml-structure">to_yaml ($structure)</h2>

<p>Serializes a structure to YAML.</p>

<p>Calling this function will <b>not</b> trigger the serialization's hooks.</p>

<h2 id="true">true</h2>

<p>Constant that returns a true value (1).</p>

<h2 id="upload">upload</h2>

<p>Provides access to file uploads. Any uploaded file is accessible as a <a href="https://metacpan.org/pod/Dancer2::Core::Request::Upload">Dancer2::Core::Request::Upload</a> object. You can access all parsed uploads via:</p>

<pre><code> post '/some/route' =&gt; sub {
 my $file = upload('file_input_foo');
 # $file is a Dancer2::Core::Request::Upload object
 };</code></pre>

<p>If you named multiple inputs of type "file" with the same name, the <code>upload</code> keyword would return an Array of <a href="https://metacpan.org/pod/Dancer2::Core::Request::Upload">Dancer2::Core::Request::Upload</a> objects:</p>

<pre><code> post '/some/route' =&gt; sub {
 my ($file1, $file2) = upload('files_input');
 # $file1 and $file2 are Dancer2::Core::Request::Upload objects
 };</code></pre>

<p>You can also access the raw hashref of parsed uploads via the current <code>request</code> object:</p>

<pre><code> post '/some/route' =&gt; sub {
 my $all_uploads = request-&gt;uploads;
 # $all_uploads-&gt;{'file_input_foo'} is a Dancer2::Core::Request::Upload object
 # $all_uploads-&gt;{'files_input'} is an arrayref of Dancer2::Core::Request::Upload objects
 };</code></pre>

<p>Note that you can also access the filename of the upload received via the <code>params</code> keyword:</p>

<pre><code> post '/some/route' =&gt; sub {
 # params-&gt;{'files_input'} is the filename of the file uploaded
 };</code></pre>

<p>See <a href="https://metacpan.org/pod/Dancer2::Core::Request::Upload">Dancer2::Core::Request::Upload</a> for details about the interface provided.</p>

<h2 id="uri_for">uri_for</h2>

<p>Returns a fully-qualified URI for the given path:</p>

<pre><code> get '/' =&gt; sub {
 redirect uri_for('/path');
 # can be something like: http://localhost:3000/path
 };</code></pre>

<h2 id="captures">captures</h2>

<p>Returns a reference to a copy of <code>%+</code>, if there are named captures in the route's regular expression.</p>

<p>Named captures are a feature of Perl 5.10, and are not supported in earlier versions:</p>

<pre><code> get qr{
 / (?&lt;object&gt; user | ticket | comment )
 / (?&lt;action&gt; delete | find )
 / (?&lt;id&gt; \d+ )
 /?$
 }x
 , sub {
 my $value_for = captures;
 "i don't want to $$value_for{action} the $$value_for{object} $$value_for{id} !"
 };</code></pre>

<h2 id="var">var</h2>

<p>Provides an accessor for variables shared between hooks and route handlers. Given a key/value pair, it sets a variable:</p>

<pre><code> hook before =&gt; sub {
 var foo =&gt; 42;
 };</code></pre>

<p>Later, route handlers and other hooks will be able to read that variable:</p>

<pre><code> get '/path' =&gt; sub {
 my $foo = var 'foo';
 ...
 };</code></pre>

<h2 id="vars">vars</h2>

<p>Returns the hashref of all shared variables set during the hook/route chain with the <code>var</code> keyword:</p>

<pre><code> get '/path' =&gt; sub {
 if (vars-&gt;{foo} eq 42) {
 ...
 }
 };</code></pre>

<h2 id="warning">warning</h2>

<p>Logs a warning message through the current logger engine:</p>

<pre><code> warning "This is a warning";</code></pre>

<p>See <a href="https://metacpan.org/pod/Dancer2::Core::Role::Logger">Dancer2::Core::Role::Logger</a> for details on how to configure where log messages go.</p>



<p>Dancer Core Developers</p>



<p>This software is copyright (c) 2015 by Alexis Sukrieh.</p>

<p>This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5 programming language system itself.</p>

	

</div>

 </div>
</body></html>
