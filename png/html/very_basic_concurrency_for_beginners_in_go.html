<!DOCTYPE html><html><head><title>Very basic concurrency for beginners in Go</title></head><body>
<h1>Very basic concurrency for beginners in Go</h1><p><a href="https://medium.com/@matryer/very-basic-concurrency-for-beginners-in-go-663e63c6ba07" target="_new">Original URL</a></p>
<p><blockquote>Computers can do things very quickly, and if you can make them do many things at the same time, jobs get finished even sooner. Modern computers have processors with many cores, and spreading load&hellip;</blockquote></p>
<section name="52db" class=" section--body section--first section--last" score="41.25"><div class="section-content" score="32.5"><div class="section-inner layoutSingleColumn" score="26.0"><p name="2381" id="2381" class="graf--p graf-after--h3">Computers can do things very quickly, and if you can make them do many things at the same time, jobs get finished even sooner. Modern computers have processors with many cores, and spreading load across those cores maximises performance, and therefore speed of execution. Coding such multi-threaded code was hard, until Go came along and ruined it by making it so easy.</p><p name="4847" id="4847" class="graf--p graf-after--p">In this article, we will explore:</p><ul class="postList"><li name="8c65" id="8c65" class="graf--li graf-after--p">The `go` command</li><li name="9b5a" id="9b5a" class="graf--li graf-after--li">A common gotcha when writing concurrent code</li><li name="c0e9" id="c0e9" class="graf--li graf-after--li">How to use the `sync.WaitGroup` to make sure our program doesn’t terminate prematurely</li><li name="2626" id="2626" class="graf--li graf-after--li">What kind of impact concurrent code can have on performance</li><li name="64bc" id="64bc" class="graf--li graf-after--li">How making code run concurrently introduces some unpredictability</li></ul><p name="efcd" id="efcd" class="graf--p graf-after--h4">To make a function run in the background, insert the keyword `go` before the call (like you do with `defer`).</p><p name="0f9e" id="0f9e" class="graf--p graf-after--p">So this:</p><pre name="9007" id="9007" class="graf--pre graf-after--p">func main(){<br> doSomething()<br>}</pre><p name="f1de" id="f1de" class="graf--p graf-after--pre">Becomes:</p><pre name="a8ee" id="a8ee" class="graf--pre graf-after--p">func main(){<br> go doSomething()<br>}</pre><p name="964c" id="964c" class="graf--p graf-after--pre">Now, the `doSomething` function will run in the background in a <em class="markup--em markup--p-em">goroutine</em>.</p><blockquote name="8ceb" id="8ceb" class="graf--blockquote graf-after--p">If you want to play along with this article but don’t have your Go environment setup yet, you can always use the Go playground over at <a href="http://play.golang.org" class="markup--anchor markup--blockquote-anchor" rel="nofollow">http://play.golang.org</a>.</blockquote><p name="3816" id="3816" class="graf--p graf-after--h4">Let’s explore this in a little more detail, and look at some common gotchas that can trip us up.</p><pre name="db70" id="db70" class="graf--pre graf-after--p">package main</pre><pre name="7975" id="7975" class="graf--pre graf-after--pre">import (<br> "fmt"<br>)</pre><pre name="93d0" id="93d0" class="graf--pre graf-after--pre">func main() {<br> fmt.Println("start")<br> doSomething()<br> fmt.Println("end")<br>}</pre><pre name="3b8b" id="3b8b" class="graf--pre graf-after--pre">func doSomething() {<br> fmt.Println("do something")<br>}</pre><blockquote name="336c" id="336c" class="graf--blockquote graf-after--pre">To run this code save it into a file called `one.go`, open a command line and do `go run one.go`</blockquote><p name="23b2" id="23b2" class="graf--p graf-after--blockquote">Executing the above code will produce the following output:</p><pre name="acf0" id="acf0" class="graf--pre graf-after--p">start<br>do something<br>end</pre><p name="5fe4" id="5fe4" class="graf--p graf-after--pre">It’s pretty predictable, because everything happens in the order in which we have written it.</p><p name="e48b" id="e48b" class="graf--p graf-after--p">Now let’s make the `doSomething` function run in the background by modifying the main function:</p><pre name="29ba" id="29ba" class="graf--pre graf-after--p">func main() {<br> fmt.Println(“start”)<br> go doSomething()<br> fmt.Println(“end”)<br>}</pre><blockquote name="8e95" id="8e95" class="graf--blockquote graf-after--pre">I really love that adding concurrency in Go takes only three key presses, g, o and a space.</blockquote><p name="a4b4" id="a4b4" class="graf--p graf-after--blockquote">Running this code now (probably) produces the following output:</p><pre name="feca" id="feca" class="graf--pre graf-after--p">start<br>end</pre><p name="fdd6" id="fdd6" class="graf--p graf-after--pre">Oh no — what happened? And why only “probably?”</p><blockquote name="c461" id="c461" class="graf--pullquote pullquote graf-after--p">In Go, when the main function exits, the program stops.</blockquote><p name="9e82" id="9e82" class="graf--p graf-after--pullquote">In our above code, the background task doesn’t get chance to write “do something,” before the program has ended — at which point, all goroutines are terminated.</p><p name="d493" id="d493" class="graf--p graf-after--p">To solve this, we could add a sleep operation at the bottom of our main function (with `time.Sleep`) but that’s not a very nice solution — because we don’t know how long our `doSomething` function might need to run.</p><p name="d82c" id="d82c" class="graf--p graf-after--h4">The standard library gives us a package called `sync`, that has some great features which we can use to solve this problem properly.</p><p name="cc57" id="cc57" class="graf--p graf-after--p">A `sync.WaitGroup` is essentially a counter that we can increase (to indicate we want to wait for things), and decrease (to indicate things are done). Then we can tell code to wait until the WaitGroup counter reaches zero, which would mean all things have finished.</p><p name="de35" id="de35" class="graf--p graf-after--p">Update your code to look like this:</p><pre name="1a13" id="1a13" class="graf--pre graf-after--p">package main</pre><pre name="8d79" id="8d79" class="graf--pre graf-after--pre">import (<br> “fmt”<br> “sync”<br>)</pre><pre name="4ac7" id="4ac7" class="graf--pre graf-after--pre">var wg sync.WaitGroup</pre><pre name="4c52" id="4c52" class="graf--pre graf-after--pre">func main() {<br> fmt.Println(“start”)<br> wg.Add(1) // indicate we are going to wait for one thing<br> go doSomething()<br> fmt.Println(“end”)<br> wg.Wait() // wait for all things to be done<br> // end of program<br>}</pre><pre name="9f4a" id="9f4a" class="graf--pre graf-after--pre">func doSomething() {<br> fmt.Println(“do something”)<br> wg.Done() // this is done<br>}</pre><p name="3708" id="3708" class="graf--p graf-after--pre">Some key pieces explained:</p><ul class="postList"><li name="760c" id="760c" class="graf--li graf-after--p">var wg sync.WaitGroup — defines a WaitGroup that is ready to use</li><li name="1b8f" id="1b8f" class="graf--li graf-after--li">wg.Add(1) — indicates that there is 1 thing to wait for (our doSomething function)</li><li name="4d8c" id="4d8c" class="graf--li graf-after--li">wg.Wait() — indicates that code should block until the WaitGroup counter reaches zero</li><li name="f600" id="f600" class="graf--li graf-after--li">wg.Done() — indicates that 1 thing has finished</li></ul><blockquote name="a7d1" id="a7d1" class="graf--blockquote graf-after--li">Notice that we don’t ever create a new WaitGroup, this is because in its default zero state (the state you get just by defining it), a WaitGroup is ready to use. Check out the <a href="https://golang.org/pkg/sync/#WaitGroup" class="markup--anchor markup--blockquote-anchor" rel="nofollow">sync.WaitGroup documentation</a> for more about how to use them.</blockquote><p name="d4ba" id="d4ba" class="graf--p graf-after--blockquote">Now re-run your code, and you’ll (probably) see the following output:</p><pre name="304b" id="304b" class="graf--pre graf-after--p">start<br>end<br>do something</pre><p name="2478" id="2478" class="graf--p graf-after--pre">What’s with all this “probably” talk? When we ask Go to run code concurrently, we can’t tell it exactly how and when to run the instructions. So it introduces some unpredictability in our code. As long as we understand this, it’s not a problem — and we can use things like WaitGroup objects to introduce synchronisation points between our goroutines.</p><blockquote name="c95a" id="c95a" class="graf--blockquote graf-after--p">If we move our wg.Wait() instruction to above the line where we write “end,” we can be sure that things happen in the order in which we intend. But then there wouldn’t be much point in running the code in the background, since we’d just be waiting in our ‘main goroutine’ anyway.</blockquote><p name="ceb6" id="ceb6" class="graf--p graf-after--h4">Create a new file called `times.go` with the following code:</p><pre name="8f4e" id="8f4e" class="graf--pre graf-after--p">package main</pre><pre name="ebc0" id="ebc0" class="graf--pre graf-after--pre">import “fmt”</pre><pre name="0729" id="0729" class="graf--pre graf-after--pre">func main() {<br> timestable(2)<br>}</pre><pre name="ac9b" id="ac9b" class="graf--pre graf-after--pre">func timestable(x int) {<br> for i := 1; i &lt;= 12; i++ {<br> fmt.Printf(“%d x %d = %d\n”, i, x, x*i)<br> time.Sleep(100 Adlm Android Art Articles bin Code Desktop Develop Documents dotfiles Downloads github go Locker maya Media Music ownCloud Pictures Projects Videos VirtualBox VMs vmware time.Millisecond)<br> }<br>}</pre><blockquote name="7c0b" id="7c0b" class="graf--blockquote graf-after--pre">The weird %d symbols in the Printf argument are special verbs that you can learn more about in the <a href="https://golang.org/pkg/fmt/" class="markup--anchor markup--blockquote-anchor" rel="nofollow">fmt documenation</a>. Essentially, it formats the numbers in a nice human readable way.</blockquote><p name="eb32" id="eb32" class="graf--p graf-after--blockquote">Running the above code will print out the multiplication table (we called it our “times table” at school) for the number 2:</p><pre name="701f" id="701f" class="graf--pre graf-after--p">$ go run times.go<br>1 x 2 = 2<br>2 x 2 = 4<br>3 x 2 = 6<br>4 x 2 = 8<br>5 x 2 = 10<br>6 x 2 = 12<br>7 x 2 = 14<br>8 x 2 = 16<br>9 x 2 = 18<br>10 x 2 = 20<br>11 x 2 = 22<br>12 x 2 = 24</pre><blockquote name="32c4" id="32c4" class="graf--blockquote graf-after--pre">The `time.Sleep` instruction tells the code to block (or wait) for 100ms, this is to slow things down so we can really see the impact of making code run concurrently — you would probably never do this in real code.</blockquote><p name="826b" id="826b" class="graf--p graf-after--blockquote">Let’s enhance our main function to give us the times tables for all numbers that we needed to learn at school:</p><pre name="93eb" id="93eb" class="graf--pre graf-after--p">func main() {<br> for n := 2; n &lt;= 12; n++ {<br> timestable(n)<br> }<br>}</pre><p name="ccf3" id="ccf3" class="graf--p graf-after--pre">Now, our code will call the timestable function for all numbers between 2 and 12 inclusively.</p><p name="ddb4" id="ddb4" class="graf--p graf-after--h4">On unix systems (including Macs), running a command prefixed by the `time` command will tell us how long our code took to execute. In my case it was just over 13 seconds:</p><pre name="fa12" id="fa12" class="graf--pre graf-after--p">$ time go run times.go<br>real 0m13.762s<br>user 0m0.261s<br>sys 0m0.059s</pre><blockquote name="6753" id="6753" class="graf--blockquote graf-after--pre">13 seconds to do this kind of work is embarassing if it weren’t for our time.Sleep instructions. But remember, it’s just to simulate some resource intensive task.</blockquote><p name="7d03" id="7d03" class="graf--p graf-after--h4">Now we are going to make the code run concurrently, to see if we can speed things up. Update the code:</p><pre name="c751" id="c751" class="graf--pre graf-after--p">package main</pre><pre name="e8e7" id="e8e7" class="graf--pre graf-after--pre">import (<br> "fmt"<br> "sync"<br> "time"<br>)</pre><pre name="1d26" id="1d26" class="graf--pre graf-after--pre">var wg sync.WaitGroup</pre><pre name="3f20" id="3f20" class="graf--pre graf-after--pre">func main() {<br> for n := 2; n &lt;= 12; n++ {<br> wg.Add(1)<br> go timestable(n)<br> }<br> wg.Wait()<br>}</pre><pre name="2e1f" id="2e1f" class="graf--pre graf-after--pre">func timestable(x int) {<br> for i := 1; i &lt;= 12; i++ {<br> fmt.Printf("%d x %d = %d\n", i, x, x*i)<br> time.Sleep(100 Adlm Android Art Articles bin Code Desktop Develop Documents dotfiles Downloads github go Locker maya Media Music ownCloud Pictures Projects Videos VirtualBox VMs vmware time.Millisecond)<br> }<br> wg.Done()<br>}</pre><p name="2795" id="2795" class="graf--p graf-after--pre"><em class="markup--em markup--p-em">see </em><a href="http://play.golang.org/p/NkNzaewRjH" class="markup--anchor markup--p-anchor" rel="nofollow"><em class="markup--em markup--p-em">http://play.golang.org/p/NkNzaewRjH</em></a></p><p name="4586" id="4586" class="graf--p graf-after--p">As we did before, we’ve made the `timestable` function run concurrently, and used a `sync.WaitGroup` to make sure our program doesn’t end before all calculations have finished.</p><blockquote name="2a60" id="2a60" class="graf--blockquote graf-after--p">This time, we have the wg.Add function call inside the for loop. This is more common, and allows us to calculate the times table for a variable number of things.</blockquote><p name="8318" id="8318" class="graf--p graf-after--blockquote">Running this code with the `time` command shows us the impact that making our code run concurrently has had:</p><pre name="778c" id="778c" class="graf--pre graf-after--p">$ time go run times.go<br>real 0m1.431s<br>user 0m0.253s<br>sys 0m0.053s</pre><p name="2bc8" id="2bc8" class="graf--p graf-after--pre">We’ve gone from over 13 seconds, to just under 1.5 seconds. Your results may differ, but they will be significantly improved.</p><p name="ac12" id="ac12" class="graf--p graf-after--h4">Taking a closer look at the output will reveal again that the order the instructions get executed in is unpredictable:</p><pre name="64f3" id="64f3" class="graf--pre graf-after--p">12 x 7 = 84<br>12 x 6 = 72<br>12 x 3 = 36<br>12 x 8 = 96<br>12 x 12 = 144<br>12 x 4 = 48<br>12 x 9 = 108<br>12 x 10 = 120<br>12 x 2 = 24<br>12 x 5 = 60<br>12 x 11 = 132</pre><p name="abf8" id="abf8" class="graf--p graf-after--pre">Even though we are counting sensibly upwards, the order the operations acrually occur varies. This is because each goroutine runs at its own pace, depending on things out of our control (like other things going on in the processor at the time.)</p><p name="bacc" id="bacc" class="graf--p graf-after--p">If we care about the order, then we’d need to use Go’s inbuilt Channels to send data safely across the goroutines. But that’s out of scope for this article.</p><p name="fb34" id="fb34" class="graf--p graf-after--h4">We saw that making code run concurrently in Go is as easy as three key presses, and provided we are careful about how that behaves, we can get some pretty staggering results.</p><ul class="postList"><li name="f107" id="f107" class="graf--li graf-after--p graf--last">Next, you should learn about Channels.</li></ul></div></div></section>
</body></html>
