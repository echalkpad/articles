<!DOCTYPE html><html><head><title>Go programming for beginner — Map & Function (part 3)</title></head><body>
<h1>Go programming for beginner — Map & Function (part 3)</h1><p><a href="https://medium.com/@kyawmyintthein/go-programming-for-beginner-map-function-part-3-c374eea78bfe" target="_new">Original URL</a></p>
<p><blockquote>Map is a collections of key/value pair and also known as an associative array, hash, table and dictionary. Map can look up the value with associated key. Go also support map as built-in type.</blockquote></p>
<section name="9059" class=" section--body section--first section--last" score="41.25"><div class="section-content" score="32.5"><div class="section-inner layoutSingleColumn" score="-2.5"><figure name="f3b2" id="f3b2" class="graf--figure graf--layoutOutsetLeft graf-after--h3" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://cdn-images-1.medium.com/max/600/1*-IJJI9lCV8ykMHSS_JjTDw.png"></div></figure><p name="dc86" id="dc86" class="graf--p graf-after--h4"><strong class="markup--strong markup--p-strong">Map </strong>is a collections of key/value pair and also known as an associative array, hash, table and dictionary. <strong class="markup--strong markup--p-strong">Map</strong> can look up the <strong class="markup--strong markup--p-strong">value</strong> with associated <strong class="markup--strong markup--p-strong">key</strong>. <strong class="markup--strong markup--p-strong">Go</strong> also support map as built-in type.</p><p name="423a" id="423a" class="graf--p graf-after--p">Define a <strong class="markup--strong markup--p-strong">map</strong> in Go Programming:</p><pre name="19bb" id="19bb" class="graf--pre graf-after--p">var x map[string]int</pre><p name="8d33" id="8d33" class="graf--p graf-after--pre">The map type is represented as <strong class="markup--strong markup--p-strong">map</strong> keyword, followed by the<strong class="markup--strong markup--p-strong"> key type in brackets</strong> and the <strong class="markup--strong markup--p-strong">value type</strong>.</p><p name="ec43" id="ec43" class="graf--p graf-after--p">In “x” map, “[string]” is key type and “int” is value type.</p><p name="7306" id="7306" class="graf--p graf-after--p">You can set <strong class="markup--strong markup--p-strong">value</strong> to “x” <strong class="markup--strong markup--p-strong">map</strong> by:</p><pre name="7050" id="7050" class="graf--pre graf-after--p">x["key1"] = 10</pre><p name="5a4c" id="5a4c" class="graf--p graf-after--pre">So, you can also retrieve the <strong class="markup--strong markup--p-strong">value from map</strong> by using <strong class="markup--strong markup--p-strong">key</strong>.</p><pre name="50e3" id="50e3" class="graf--pre graf-after--p">fmt.Println(x["key1"])<br>10</pre><p name="321e" id="321e" class="graf--p graf-after--pre">You can use <strong class="markup--strong markup--p-strong">make</strong> built-in function to create a <strong class="markup--strong markup--p-strong">map</strong>.</p><pre name="d376" id="d376" class="graf--pre graf-after--p">var x = make(map[string]int)</pre><p name="db35" id="db35" class="graf--p graf-after--pre">You can delete the <strong class="markup--strong markup--p-strong">map value</strong> by <strong class="markup--strong markup--p-strong">key</strong>:</p><pre name="1b3b" id="1b3b" class="graf--pre graf-after--p">delete(x, "key1")</pre><p name="51ac" id="51ac" class="graf--p graf-after--pre">If you retrieve the <strong class="markup--strong markup--p-strong">map value</strong> with <strong class="markup--strong markup--p-strong">invalid key</strong>, that will return zero value for the value type (which for strings is the empty string). You can check the that condition with:</p><pre name="c76d" id="c76d" class="graf--pre graf-after--p">if x["key2"] == ""{<br> //do something<br>}</pre><p name="72e6" id="72e6" class="graf--p graf-after--pre">Go provide better way to check as follow:</p><pre name="ada3" id="ada3" class="graf--pre graf-after--p">value, ok := x["key2"] </pre><p name="69a1" id="69a1" class="graf--p graf-after--pre">You can also define map by shorter way:</p><pre name="fd46" id="fd46" class="graf--pre graf-after--p">x := map[string]int{<br> "key1": 1",<br> "key2": 2",<br>}</pre><p name="eeaa" id="eeaa" class="graf--p graf-after--h4">A <strong class="markup--strong markup--p-strong">function</strong> is a type of procedure or routine which returns a value, and a procedure, which performs some operation but does not return a value.</p><p name="5803" id="5803" class="graf--p graf-after--p">You already use function in <strong class="markup--strong markup--p-strong">Go programming </strong>which is,</p><pre name="00de" id="00de" class="graf--pre graf-after--p">func main() {}</pre><p name="632c" id="632c" class="graf--p graf-after--pre">main() function is an entry point of the <strong class="markup--strong markup--p-strong">Go program</strong>.</p><p name="1a65" id="1a65" class="graf--p graf-after--p">You can also create your own function with <strong class="markup--strong markup--p-strong">func</strong> keyword, followed by the function’s name. for example:</p><pre name="c296" id="c296" class="graf--pre graf-after--p">func sum() {}</pre><p name="345d" id="345d" class="graf--p graf-after--pre">In a function, you can accept parameters as follow:</p><pre name="d98d" id="d98d" class="graf--pre graf-after--p">func sum(a int,b int) {}</pre><p name="f60b" id="f60b" class="graf--p graf-after--pre">sum function accept 2 parameters with “int” type. You can also use shorter way if your parameter data type is same.</p><pre name="6065" id="6065" class="graf--pre graf-after--p">func sum(a,b int) {}</pre><p name="2b9c" id="2b9c" class="graf--p graf-after--pre">You can also return value or function from a function. But, you need to define return type.</p><pre name="88e5" id="88e5" class="graf--pre graf-after--p">func sum(a,b int) int{}</pre><p name="af8d" id="af8d" class="graf--p graf-after--pre">In Go programming, you can return multiple value from a function</p><pre name="6d9b" id="6d9b" class="graf--pre graf-after--p">func sum(a,b int) (int,error){}</pre><p name="c0fa" id="c0fa" class="graf--p graf--startsWithDoubleQuote graf-after--pre">“sum” function will return “int” and error type.</p><p name="6b95" id="6b95" class="graf--p graf-after--p">Finally You can have the function body which is a series of statements between curly braces.</p><pre name="24b0" id="24b0" class="graf--pre graf-after--p">import "strconv"<br>func sum(a,b int) (int,error){</pre><pre name="112f" id="112f" class="graf--pre graf-after--pre"> var err error <br> var total int<br> if _, err = strconv.Atoi(a); err != nil {<br> return total, err<br> }</pre><pre name="5d1c" id="5d1c" class="graf--pre graf-after--pre"> if _, err = strconv.Atoi(b); err != nil {<br> return total, err<br> }</pre><pre name="898b" id="898b" class="graf--pre graf-after--pre"> total = a + b<br> return total, err</pre><pre name="7a35" id="7a35" class="graf--pre graf-after--pre">}</pre><p name="d862" id="d862" class="graf--p graf-after--pre">In “sum” function, we check the parameters value are type by using “strconv” built-in package and sum the two parameter and return the total and error value. There is not error, error type will return nil.</p><p name="11e8" id="11e8" class="graf--p graf-after--p">You can call “sum” function as follow:</p><pre name="dfa8" id="dfa8" class="graf--pre graf-after--p">t, err := sum(1,2)</pre><p name="100c" id="100c" class="graf--p graf-after--pre">Functions are built up in a “stack”. Suppose we had this program:</p><pre name="cbd4" id="cbd4" class="graf--pre graf-after--p">func main() {<br> fmt.Println(f1())<br>}<br>func f1() int {<br> return f2()<br>}<br>func f2() int {<br> return 1<br>}</pre><figure name="2aeb" id="2aeb" class="graf--figure graf-after--pre" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://cdn-images-1.medium.com/max/800/1*-BL4CZ-AspNCeWT1UqOebQ.png"></div><figcaption class="imageCaption">credit: http://www.golang-book.com/book/intro/7</figcaption></figure><p name="a8a8" id="a8a8" class="graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">Variadic Functions</strong></p><p name="3018" id="3018" class="graf--p graf-after--p">You can accept zero or more parameter by using … value in function.</p><pre name="3985" id="3985" class="graf--pre graf-after--p">func f2(args ...int){<br> fmt.Println(args)<br>}</pre><p name="a73b" id="a73b" class="graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Closure</strong></p><p name="a7ed" id="a7ed" class="graf--p graf-after--p">It is possible to create functions inside of functions:</p><pre name="214a" id="214a" class="graf--pre graf-after--p">func intSeq() func() int {<br> i := 0<br> return func() int {<br> i += 1<br> return i<br> }<br>}<br>newInts := intSeq()<br>fmt.Println(newInts())<br>fmt.Println(newInts())</pre><pre name="b343" id="b343" class="graf--pre graf-after--pre">Result:<br>1<br>2</pre><p name="779f" id="779f" class="graf--p graf-after--pre">intSeq function is closure function, which returns another function, which we define anonymously in the body of intSeq. The returned function <em class="markup--em markup--p-em">closes over</em> the variable i to form a closure.</p><p name="850a" id="850a" class="graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Recursion</strong></p><p name="c9d6" id="c9d6" class="graf--p graf-after--p">A function able to call itself is recursion</p><pre name="b569" id="b569" class="graf--pre graf-after--p">func factorial(x uint) uint {<br> if x == 0 {<br> return 1<br> }<br> return x articles _articles bin CAs devops Documents dotfiles gethtml go hnews jason js MITIE netdata png pngquant start-thesrc thesrc ucii factorial(x-1)<br>}</pre><p name="99d3" id="99d3" class="graf--p graf-after--h4"><strong class="markup--strong markup--p-strong">Defer</strong> is special statement in Go programming, which schedules a function call to be run after the function completes. For example, in file read/write program, you need to close the file after read/write. At that time, you can use defer statement.</p><pre name="56a2" id="56a2" class="graf--pre graf-after--p">f, _ := os.Open(filename)<br>defer f.Close()</pre><p name="bc40" id="bc40" class="graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Panic</strong> is a function to cause a run time error. For example,</p><pre name="d935" id="d935" class="graf--pre graf-after--p">f, err:= os.Open(filename)</pre><pre name="2799" id="2799" class="graf--pre graf-after--pre">if err != nil{<br> panic(err) // if error occur, program will stop here<br>}<br>defer f.Close()</pre><p name="e00b" id="e00b" class="graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Recover </strong>We can handle a run-time panic with the built-in recover function. recover stops the panic and returns the value that was passed to the call to <strong class="markup--strong markup--p-strong">panic</strong>.</p><pre name="0b95" id="0b95" class="graf--pre graf-after--p">f, err:= os.Open(filename)</pre><pre name="7572" id="7572" class="graf--pre graf-after--pre graf--last">if err != nil{<br> panic(err) // if error occur, program will stop here recoverErr:= recover()<br> fmt.Println(recoverErr)<br>}<br>defer f.Close()</pre></div></div></section>
</body></html>
