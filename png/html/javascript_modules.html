<!DOCTYPE html><html><head><title>JavaScript Modules</title></head><body>
<h1>JavaScript Modules</h1><p><a href="https://medium.freecodecamp.com/javascript-modules-a-beginner-s-guide-783f7d7a5fcc?gi=f56f6ac066e" target="_new">Original URL</a></p>
<p><blockquote>If you&#x2019;re a newcomer to JavaScript, jargon like &#x201C;module bundlers vs. module loaders,&#x201D; &#x201C;Webpack vs. Browserify&#x201D; and &#x201C;AMD vs. CommonJS&#x201D; can quickly&hellip;</blockquote></p>
<div><div class="section-inner layoutSingleColumn"><p name="7ef6" id="7ef6" class="graf--p graf-after--figure">If you&#x2019;re a newcomer to JavaScript, jargon like &#x201C;module bundlers vs. module loaders,&#x201D; &#x201C;Webpack vs. Browserify&#x201D; and &#x201C;AMD vs. CommonJS&#x201D; can quickly become overwhelming.</p><p name="aa99" id="aa99" class="graf--p graf-after--p">The JavaScript module system may be intimidating, but understanding it is vital for web developers.</p><p name="3016" id="3016" class="graf--p graf-after--p">In this post, I&#x2019;ll unpack these buzzwords for you in plain English (and a few code samples). I hope you find it helpful!</p><p name="95f4" id="95f4" class="graf--p graf-after--p"><em class="markup--em markup--p-em">Note: for simplicity&#x2019;s sake, this will be divided into two sections: Part 1 will dive into explaining what modules are and why we use them. Part 2 (posted next week) will walk through what it means to bundle modules and the different ways to do so.</em></p><p name="cc40" id="cc40" class="graf--p graf-after--h3">Good authors divide their books into chapters and sections; good programmers divide their programs into modules.</p><p name="aba1" id="aba1" class="graf--p graf-after--p">Like a book chapter, modules are just clusters of words (or code, as the case may be).</p><p name="fd5f" id="fd5f" class="graf--p graf-after--p">Good modules, however, are highly self-contained with distinct functionality, allowing them to be shuffled, removed, or added as necessary, without disrupting the system as a whole.</p><p name="52d5" id="52d5" class="graf--p graf-after--h3">There are a lot of benefits to using modules in favor of a sprawling, interdependent codebase. The most important ones, in my opinion, are:</p><p name="2f93" id="2f93" class="graf--p graf-after--p"><strong class="markup--strong markup--p-strong">1) Maintainability:</strong> By definition, a module is self-contained. A well-designed module aims to lessen the dependencies on parts of the codebase as much as possible, so that it can grow and improve independently. Updating a single module is much easier when the module is decoupled from other pieces of code.</p><p name="a55f" id="a55f" class="graf--p graf-after--p">Going back to our book example, if you wanted to update a chapter in your book, it would be a nightmare if a small change to one chapter required you to tweak every other chapter as well. Instead, you&#x2019;d want to write each chapter in such a way that improvements could be made without affecting other chapters.</p><p name="5c56" id="5c56" class="graf--p graf-after--p"><strong class="markup--strong markup--p-strong">2) Namespacing:</strong> In JavaScript, variables outside the scope of a top-level function are global (meaning, everyone can access them). Because of this, it&#x2019;s common to have &#x201C;namespace pollution&#x201D;, where completely unrelated code shares global variables.</p><p name="5e73" id="5e73" class="graf--p graf-after--p">Sharing global variables between unrelated code is a big <a href="http://c2.com/cgi/wiki?GlobalVariablesAreBad" class="markup--anchor markup--p-anchor" rel="nofollow">no-no in development</a>.</p><p name="20d1" id="20d1" class="graf--p graf-after--p">As we&#x2019;ll see later in this post, modules allow us to avoid namespace pollution by creating a private space for our variables.</p><p name="59ca" id="59ca" class="graf--p graf-after--p"><strong class="markup--strong markup--p-strong">3) Reusability:</strong> Let&#x2019;s be honest here: we&#x2019;ve all copied code we previously wrote into new projects at one point or another. For example, let&#x2019;s imagine you copied some utility methods you wrote from a previous project to your current project.</p><p name="d9d2" id="d9d2" class="graf--p graf-after--p">That&#x2019;s all well and good, but if you find a better way to write some part of that code you&#x2019;d have to go back and remember to update it everywhere else you wrote it.</p><p name="635d" id="635d" class="graf--p graf-after--p">This is obviously a huge waste of time. Wouldn&#x2019;t it be much easier if there was&#x200A;&#x2014;&#x200A;wait for it&#x200A;&#x2014;&#x200A;a module that we can reuse over and over again?</p><p name="dfbf" id="dfbf" class="graf--p graf-after--h3">There are many ways to incorporate modules into your programs. Let&#x2019;s walk through a few of them:</p><p name="e987" id="e987" class="graf--p graf-after--h4">The Module pattern is used to mimic the concept of classes (since JavaScript doesn&#x2019;t natively support classes) so that we can store both public and private methods and variables inside a single object&#x200A;&#x2014;&#x200A;similar to how classes are used in other programming languages like Java or Python. That allows us to create a public facing API for the methods that we want to expose to the world, while still encapsulating private variables and methods in a closure scope.</p><p name="7077" id="7077" class="graf--p graf-after--p">There are several ways to accomplish the module pattern. In this first example, I&#x2019;ll use an anonymous closure. That&#x2019;ll help us accomplish our goal by putting all our code in an anonymous function. (Remember: in JavaScript, functions are the only way to create new scope.)</p><p name="1d62" id="1d62" class="graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Example 1: Anonymous closure</strong></p><figure name="a2c1" id="a2c1" class="graf--figure graf--iframe graf-after--p"></figure><p name="a96f" id="a96f" class="graf--p graf-after--figure">With this construct, our anonymous function has its own evaluation environment or &#x201C;closure&#x201D;, and then we immediately evaluate it. This lets us hide variables from the parent (global) namespace.</p><p name="fe72" id="fe72" class="graf--p graf-after--p">What&#x2019;s nice about this approach is that is that you can use local variables inside this function without accidentally overwriting existing global variables, yet still access the global variables, like so:</p><figure name="d632" id="d632" class="graf--figure graf--iframe graf-after--p"></figure><p name="1e74" id="1e74" class="graf--p graf-after--figure">Note that the parenthesis around the anonymous function are required, because statements that begin with the keyword <em class="markup--em markup--p-em">function</em> are always considered to be function declarations (remember, you can&#x2019;t have unnamed function declarations in JavaScript.) Consequently, the surrounding parentheses create a function expression instead. If you&#x2019;re curious, you can <a href="http://stackoverflow.com/questions/1634268/explain-javascripts-encapsulated-anonymous-function-syntax" class="markup--anchor markup--p-anchor" rel="nofollow">read more here</a>.</p><p name="df8a" id="df8a" class="graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Example 2: Global import </strong><br>Another popular approach used by libraries like <a href="https://github.com/jquery/jquery/tree/master/src" class="markup--anchor markup--p-anchor" rel="nofollow">jQuery</a> is global import. It&#x2019;s similar to the anonymous closure we just saw, except now we pass in globals as parameters:</p><figure name="d1ac" id="d1ac" class="graf--figure graf--iframe graf-after--p"></figure><p name="d233" id="d233" class="graf--p graf-after--figure">In this example, <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">globalVariable</em></strong> is the only variable that&#x2019;s global. The benefit of this approach over anonymous closures is that you declare the global variables upfront, making it crystal clear to people reading your code.</p><p name="2c9a" id="2c9a" class="graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Example 3: Object interface</strong><br>Yet another approach is to create modules using a self-contained object interface, like so:</p><figure name="5a50" id="5a50" class="graf--figure graf--iframe graf-after--p"></figure><p name="acbb" id="acbb" class="graf--p graf-after--figure">As you can see, this approach lets us decide what variables/methods we want to keep private (e.g. <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">myGrades</em></strong>) and what variables/methods we want to expose by putting them in the return statement (e.g. <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">average</em></strong> &amp; <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">failing</em></strong>).</p><p name="9c0c" id="9c0c" class="graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Example 4: Revealing module pattern</strong><br>This is very similar to the above approach, except that it ensures all methods and variables are kept private until explicitly exposed:</p><figure name="84ad" id="84ad" class="graf--figure graf--iframe graf-after--p"></figure><p name="d19d" id="d19d" class="graf--p graf-after--figure">That may seem like a lot to take in, but it&#x2019;s just the tip of the iceberg when it comes to module patterns. Here are a few of the resources I found useful in my own explorations:</p><p name="cbae" id="cbae" class="graf--p graf-after--h3">The approaches above all have one thing in common: the use of a single global variable to wrap its code in a function, thereby creating a private namespace for itself using a closure scope.</p><p name="5a59" id="5a59" class="graf--p graf-after--p">While each approach is effective in its own way, they have their downsides.</p><p name="6f8b" id="6f8b" class="graf--p graf-after--p">For one, as a developer, you need to know the right dependency order to load your files in. For instance, let&#x2019;s say you&#x2019;re using Backbone in your project, so you include the script tag for Backbone&#x2019;s source code in your file.</p><p name="af13" id="af13" class="graf--p graf-after--p">However, since Backbone has a hard dependency on Underscore.js, the script tag for the Backbone file can&#x2019;t be placed before the Underscore.js file.</p><p name="c5eb" id="c5eb" class="graf--p graf-after--p">As a developer, managing dependencies and getting these things right can sometimes be a headache.</p><p name="4c50" id="4c50" class="graf--p graf-after--p">Another downside is that they can still lead to namespace collisions. For example, what if two of your modules have the same name? Or what if you have two versions of a module, and you need both?</p><p name="c33a" id="c33a" class="graf--p graf-after--p">So you&#x2019;re probably wondering: can we design a way to ask for a module&#x2019;s interface without going through the global scope?</p><p name="1a59" id="1a59" class="graf--p graf-after--p">Fortunately, the answer is yes.</p><p name="9786" id="9786" class="graf--p graf-after--p">There are two popular and well-implemented approaches: CommonJS and AMD.</p><p name="2a74" id="2a74" class="graf--p graf-after--h4">CommonJS is a volunteer working group that designs and implements JavaScript APIs for declaring modules.</p><p name="4a5a" id="4a5a" class="graf--p graf-after--p">A CommonJS module is essentially a reusable piece of JavaScript which exports specific objects, making them available for other modules to <em class="markup--em markup--p-em">require</em> in their programs. If you&#x2019;ve programmed in Node.js, you&#x2019;ll be very familiar with this format.</p><p name="7ef1" id="7ef1" class="graf--p graf-after--p">With CommonJS, each JavaScript file stores modules in its own unique module context (just like wrapping it in a closure). In this scope, we use the <em class="markup--em markup--p-em">module.exports</em> object to expose modules, and <em class="markup--em markup--p-em">require</em> to import them.</p><p name="8601" id="8601" class="graf--p graf-after--p">When you&#x2019;re defining a CommonJS module, it might look something like this:</p><figure name="43c9" id="43c9" class="graf--figure graf--iframe graf-after--p"></figure><p name="6cf7" id="6cf7" class="graf--p graf-after--figure">We use the special object module and place a reference of our function into <em class="markup--em markup--p-em">module.exports</em>. This lets the CommonJS module system know what we want to expose so that other files can consume it.</p><p name="85b8" id="85b8" class="graf--p graf-after--p">Then when someone wants to use <em class="markup--em markup--p-em">myModule</em>, they can require it in their file, like so:</p><figure name="e309" id="e309" class="graf--figure graf--iframe graf-after--p"></figure><p name="b77b" id="b77b" class="graf--p graf-after--figure">There are two obvious benefits to this approach over the module patterns we discussed before:</p><p name="ddd6" id="ddd6" class="graf--p graf-after--p">1. Avoiding global namespace pollution<br>2. Making our dependencies explicit</p><p name="4edc" id="4edc" class="graf--p graf-after--p">Moreover, the syntax is very compact, which I personally love.</p><p name="4790" id="4790" class="graf--p graf-after--p">Another thing to note is that CommonJS takes a server-first approach and synchronously loads modules. This matters because if we have three other modules we need to <em class="markup--em markup--p-em">require</em>, it&#x2019;ll load them one by one.</p><p name="3592" id="3592" class="graf--p graf-after--p">Now, that works great on the server but, unfortunately, makes it harder to use when writing JavaScript for the browser. Suffice it to say that reading a module from the web takes a <em class="markup--em markup--p-em">lot</em> longer than reading from disk. For as long as the script to load a module is running, it blocks the browser from running anything else until it finishes loading. It behaves this way because the JavaScript thread stops until the code has been loaded. (I&#x2019;ll cover how we can work around this issue in Part 2 when we discuss module bundling. For now, that&#x2019;s all we need to know).</p><p name="fa89" id="fa89" class="graf--p graf-after--h4">CommonJS is all well and good, but what if we want to load modules asynchronously? The answer is called Asynchronous Module Definition, or AMD for short.</p><p name="7d25" id="7d25" class="graf--p graf-after--p">Loading modules using AMD looks something like this:</p><figure name="e51d" id="e51d" class="graf--figure graf--iframe graf-after--p"></figure><p name="82e3" id="82e3" class="graf--p graf-after--figure">What&#x2019;s happening here is that the <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">define</em></strong> function takes as its first argument an array of each of the module&#x2019;s dependencies. These dependencies are loaded in the background (in a non-blocking manner), and once loaded <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">define</em></strong> calls the callback function it was given.</p><p name="8e92" id="8e92" class="graf--p graf-after--p">Next, the callback function takes, as arguments, the dependencies that were loaded&#x200A;&#x2014;&#x200A;in our case, <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">myModule</em></strong> and <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">myOtherModule&#x200A;&#x2014;&#x200A;</em></strong>allowing the function to use these dependencies. Finally, the dependencies themselves must also be defined using the <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">define</em></strong> keyword.</p><p name="52be" id="52be" class="graf--p graf-after--p">For example, <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">myModule</em></strong> might look like this:</p><figure name="a8dd" id="a8dd" class="graf--figure graf--iframe graf-after--p"></figure><p name="3df4" id="3df4" class="graf--p graf-after--figure">So again, unlike CommonJS, AMD takes a browser-first approach alongside asynchronous behavior to get the job done. (Note, there are a lot of people who strongly believe that dynamically loading files piecemeal as you start to run code isn&#x2019;t favorable, which we&#x2019;ll explore more when in the next section on module-building).</p><p name="15d7" id="15d7" class="graf--p graf-after--p">Aside from asynchronicity, another benefit of AMD is that your modules can be objects, functions, constructors, strings, JSON and many other types, while CommonJS only supports objects as modules.</p><p name="3d6e" id="3d6e" class="graf--p graf-after--p">That being said, AMD isn&#x2019;t compatible with io, filesystem, and other server-oriented features available via CommonJS, and the function wrapping syntax is a bit more verbose compared to a simple <em class="markup--em markup--p-em">require</em> statement.</p><p name="7549" id="7549" class="graf--p graf-after--h4">For projects that require you to support both AMD and CommonJS features, there&#x2019;s yet another format: Universal Module Definition (UMD).</p><p name="8db6" id="8db6" class="graf--p graf-after--p">UMD essentially creates a way to use either of the two, while also supporting the global variable definition. As a result, UMD modules are capable of working on both client and server.</p><p name="b7d7" id="b7d7" class="graf--p graf-after--p">Here&#x2019;s a quick taste of how UMD goes about its business:</p><figure name="ef5e" id="ef5e" class="graf--figure graf--iframe graf-after--p"></figure><p name="4f5e" id="4f5e" class="graf--p graf-after--figure">For more examples of UMD formats, check out this <a href="https://github.com/umdjs/umd" class="markup--anchor markup--p-anchor" rel="nofollow">enlightening repo</a> on GitHub.</p><p name="d49d" id="d49d" class="graf--p graf-after--h3">Phew! Are you still around? I haven&#x2019;t lost you in the woods here? Good! Because we have *one more* type of module to define before we&#x2019;re done.</p><p name="461c" id="461c" class="graf--p graf-after--p">As you probably noticed, none of the modules above were native to JavaScript. Instead, we&#x2019;ve created ways to <em class="markup--em markup--p-em">emulate</em> a modules system by using either the module pattern, CommonJS or AMD.</p><p name="c828" id="c828" class="graf--p graf-after--p">Fortunately, the smart folks at TC39 (the standards body that defines the syntax and semantics of ECMAScript) have introduced built-in modules with ECMAScript 6 (ES6).</p><p name="047a" id="047a" class="graf--p graf-after--p">ES6 offers up a variety of possibilities for importing and exporting modules which others have done a great job explaining&#x200A;&#x2014;&#x200A;here are a few of those resources:</p><ul class="postList"><li name="390f" id="390f" class="graf--li graf-after--p"><a href="http://jsmodules.io/cjs.html" class="markup--anchor markup--li-anchor" rel="nofollow">jsmodules.io</a></li><li name="f143" id="f143" class="graf--li graf-after--li"><a href="http://exploringjs.com/es6/ch_modules.html" class="markup--anchor markup--li-anchor" rel="nofollow">exploringjs.com</a></li></ul><p name="9fad" id="9fad" class="graf--p graf-after--li">What&#x2019;s great about ES6 modules relative to CommonJS or AMD is how it manages to offer the best of both worlds: compact and declarative syntax <em class="markup--em markup--p-em">and</em> asynchronous loading, plus added benefits like better support for cyclic dependencies.</p><p name="fa08" id="fa08" class="graf--p graf-after--p">Probably my favorite feature of ES6 modules is that imports are <em class="markup--em markup--p-em">live</em> read-only views of the exports. (Compare this to CommonJS, where imports are copies of exports and consequently not alive).</p><p name="cb5d" id="cb5d" class="graf--p graf-after--p">Here&#x2019;s an example of how that works:</p><figure name="2f6a" id="2f6a" class="graf--figure graf--iframe graf-after--p"></figure><p name="1edb" id="1edb" class="graf--p graf-after--figure">In this example, we basically make two copies of the module: one when we export it, and one when we require it.</p><p name="faa5" id="faa5" class="graf--p graf-after--p">Moreover, the copy in main.js is now disconnected from the original module. That&#x2019;s why even when we increment our counter it still returns 1&#x200A;&#x2014;&#x200A;because the counter variable that we imported is a disconnected copy of the counter variable from the module.</p><p name="1fd1" id="1fd1" class="graf--p graf-after--p">So, incrementing the counter will increment it in the module, but won&#x2019;t increment your copied version. The only way to modify the copied version of the counter variable is to do so manually:</p><figure name="d055" id="d055" class="graf--figure graf--iframe graf-after--p"></figure><p name="cb46" id="cb46" class="graf--p graf-after--figure">On the other hand, ES6 creates a live read-only view of the modules we import:</p><figure name="c026" id="c026" class="graf--figure graf--iframe graf-after--p"></figure><p name="b564" id="b564" class="graf--p graf-after--figure">Cool stuff, huh? What I find really compelling about live read-only views is how they allow you to split your modules into smaller pieces without losing functionality.</p><p name="4115" id="4115" class="graf--p graf-after--p">Then you can turn around and merge them again, no problem. It just &#x201C;works.&#x201D;</p><p name="999e" id="999e" class="graf--p graf-after--h3">Wow! Where does the time go? That was a wild ride, but I sincerely hope it gave you a better understanding of modules in JavaScript.</p><p name="2b7b" id="2b7b" class="graf--p graf-after--p">In the next section I&#x2019;ll walk through module bundling, covering core topics including:</p><ul class="postList"><li name="7252" id="7252" class="graf--li graf-after--p">Why we bundle modules</li><li name="b658" id="b658" class="graf--li graf-after--li">Different approaches to bundling</li><li name="6d39" id="6d39" class="graf--li graf-after--li">ECMAScript&#x2019;s module loader API</li><li name="a2ec" id="a2ec" class="graf--li graf-after--li">&#x2026;and more.&#xA0;:)</li></ul><p name="8a9c" id="8a9c" class="graf--p graf-after--li graf--last"><em class="markup--em markup--p-em">NOTE: To keep things simple, I skipped over some of the nitty-gritty details (think: cyclic dependencies) in this post. If I left out anything important and/or fascinating, please let me know in the comments!</em></p></div></div>
</body></html>
