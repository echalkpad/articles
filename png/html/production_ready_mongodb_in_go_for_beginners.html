<!DOCTYPE html><html><head><title>Production ready MongoDB in Go (for beginners)</title></head><body>
<h1>Production ready MongoDB in Go (for beginners)</h1><p><a href="https://medium.com/@matryer/production-ready-mongodb-in-go-for-beginners-ef6717a77219" target="_new">Original URL</a></p>
<p><blockquote>In this tutorial, we will build an API in Go that interacts with MongoDB. The code won&#x2019;t be illustrative, and will actually form the basis for a real production ready project.The source code&hellip;</blockquote></p>
<div score="30.0"><section name="ca01" class=" section--body section--first" score="41.25"><div class="section-content" score="32.5"><div class="section-inner layoutSingleColumn" score="19.0"><p name="0151" id="0151" class="graf--p graf-after--h3">In this tutorial, we will build an API in Go that interacts with MongoDB. The code won&#x2019;t be illustrative, and will actually form the basis for a real production ready project.</p><blockquote name="1a0b" id="1a0b" class="graf--blockquote graf--hasDropCapModel graf-after--p"><a href="https://github.com/matryer/articles/blob/master/mongodb-in-go/commentsapp/main.go" class="markup--anchor markup--blockquote-anchor" rel="nofollow">The source code for this article can be found on GitHub</a>.</blockquote><p name="89e2" id="89e2" class="graf--p graf-after--blockquote">MongoDB is a document datastore. Rather than storing spreadsheet like tables (columns and rows), it&#x2019;s more like a set of folders (or buckets) into which JSON files (documents) can be put, then queried.</p><p name="8947" id="8947" class="graf--p graf-after--p">In this tutorial, we&#x2019;ll write a simple comments API in Go that:</p><ul class="postList"><li name="a162" id="a162" class="graf--li graf-after--p">Connects to MongoDB</li><li name="a05f" id="a05f" class="graf--li graf-after--li">Inserts some comments data</li><li name="f12b" id="f12b" class="graf--li graf-after--li">Reads that comments data</li></ul><p name="ab82" id="ab82" class="graf--p graf-after--li">Once you know how to do these basic things, you&#x2019;ll be able to build the foundation of any kind of data-backed app. Then, as you need more advanced things, you can build on that knowledge where appropriate.</p><blockquote name="060b" id="060b" class="graf--blockquote graf-after--p">We&#x2019;ll use the <a href="https://medium.com/@matryer/writing-middleware-in-golang-and-how-go-makes-it-so-much-fun-4375c1246e81" class="markup--anchor markup--blockquote-anchor">Adapter pattern described in &#x201C;Writing middleware in #golang and how Go makes it so much fun&#x201D;</a>, so please make yourself familiar with that before proceeding (there&#x2019;s no need to watch the video&#x200A;&#x2014;&#x200A;just read the article).</blockquote><p name="b0ba" id="b0ba" class="graf--p graf-after--h4">Before we get started, be sure to:</p><ul class="postList"><li name="eb5b" id="eb5b" class="graf--li graf-after--p"><a href="https://docs.mongodb.org/manual/installation/" class="markup--anchor markup--li-anchor" rel="nofollow">Install MongoDB</a></li><li name="cd75" id="cd75" class="graf--li graf-after--li">Get the <a href="https://labix.org/mgo" class="markup--anchor markup--li-anchor" rel="nofollow">mgo package</a>&#x200A;&#x2014;&#x200A;a &#x2018;driver&#x2019; that will let us interact with MongoDB</li></ul><p name="8269" id="8269" class="graf--p graf-after--li">Create a new folder called `commentsapp`&#x200A;&#x2014;&#x200A;this is where our Go code will live. Inside that, create a subfolder called `db` which is where we&#x2019;ll ask MongoDB to keep the data.</p><p name="9f9a" id="9f9a" class="graf--p graf-after--p">Start MongoDB by running the following in a command terminal after navigating to the `commentsapp` folder:</p><pre name="4edf" id="4edf" class="graf--pre graf-after--p">mongod --dbpath=&#x201D;./db&#x201D;</pre><p name="510c" id="510c" class="graf--p graf-after--pre graf--last">You should see some output including something like the line: &#x201C;waiting for connections on port 27017&#x201D;&#x200A;&#x2014;&#x200A;then we konw we&#x2019;re good to go.</p></div></div></section><section name="7bf5" class=" section--body" score="41.25"><div class="section-content" score="31.25"><div class="section-inner layoutSingleColumn"><p name="baa5" id="baa5" class="graf--p graf-after--h3">Before we can write the code that interacts with the data, we need to put together the architecture for our project.</p><p name="009c" id="009c" class="graf--p graf-after--h4">Inside `commentsapp`create a main.go file and add the following boilerplate code:</p><pre name="3e4e" id="3e4e" class="graf--pre graf-after--p">package main</pre><pre name="7220" id="7220" class="graf--pre graf-after--pre">func main() {</pre><pre name="8eb9" id="8eb9" class="graf--pre graf-after--pre">}</pre><p name="f341" id="f341" class="graf--p graf-after--pre">Following the <a href="https://medium.com/@matryer/writing-middleware-in-golang-and-how-go-makes-it-so-much-fun-4375c1246e81" class="markup--anchor markup--p-anchor">Adapter pattern</a>, add this interface and helper method:</p><pre name="5655" id="5655" class="graf--pre graf-after--p">type Adapter func(http.Handler) http.Handler</pre><pre name="8627" id="8627" class="graf--pre graf-after--pre">func Adapt(h http.Handler, adapters ...Adapter) http.Handler {<br> for _, adapter := range adapters {<br> h = adapter(h)<br> }<br> return h<br>}</pre><p name="4bf5" id="4bf5" class="graf--p graf-after--pre">This Adapter function type will allow us to write code that can be run before and/or after HTTP requests that come into our API. We&#x2019;re going to use it to create a session that connects to MongoDB before the request handler code runs, and then clean up that session once the handler code has finished.</p><blockquote name="d2b5" id="d2b5" class="graf--blockquote graf-after--p">Be sure to import the appropriate packages as you go along, or check out the <a href="https://godoc.org/golang.org/x/tools/cmd/goimports" class="markup--anchor markup--blockquote-anchor" rel="nofollow">goimports</a> tool to have your computer do it for you.</blockquote><p name="0848" id="0848" class="graf--p graf-after--blockquote">We&#x2019;re going to write a function that returns an Adapter that will setup (and teardown) the database session for our handlers and store it in a context (import <a href="https://github.com/gorilla/context" class="markup--anchor markup--p-anchor" rel="nofollow">github.com/gorilla/context</a>) ready for our handlers to get it later.</p><p name="0f59" id="0f59" class="graf--p graf-after--p">Add the following code to main.go:</p><pre name="42bb" id="42bb" class="graf--pre graf-after--p">func withDB(db *mgo.Session) Adapter {</pre><pre name="9fab" id="9fab" class="graf--pre graf-after--pre"> // return the Adapter<br> return func(h http.Handler) http.Handler {</pre><pre name="b73d" id="b73d" class="graf--pre graf-after--pre"> // the adapter (when called) should return a new handler<br> return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {</pre><pre name="37c3" id="37c3" class="graf--pre graf-after--pre"> // copy the database session <br> dbsession := db.Copy()<br> defer dbsession.Close() // clean up </pre><pre name="7753" id="7753" class="graf--pre graf-after--pre"> // save it in the mux context<br> context.Set(r, "database", dbsession)</pre><pre name="d3fb" id="d3fb" class="graf--pre graf-after--pre"> // pass execution to the original handler<br> h.ServeHTTP(w, r)</pre><pre name="ced3" id="ced3" class="graf--pre graf-after--pre"> })<br> }<br>}</pre><p name="2e26" id="2e26" class="graf--p graf-after--pre">This is as complicated as our code is going to get, I promise. Things are a little abstract, but essentially we can use our `withDB` function to get an Adapter, which we can then use to decorate our handlers in order to give them access (via the context) to a database session through which we can interact with MongoDB. We store the copy of the database session in the context with a key of &#x201C;database&#x201D;&#x200A;&#x2014;&#x200A;which we can use later to retrieve it.</p><blockquote name="e826" id="e826" class="graf--pullquote pullquote graf-after--p">This code makes heavy use of closures in Go, whereby nearby variables (specifically `db` and `h`) are captured and made available to the other functions we define alongside them. This is a very simple way of storing state for our functions without having to add the complexity of structs or other data structures.</blockquote><p name="e8e4" id="e8e4" class="graf--p graf-after--pullquote">The key piece is the `db.Copy()` and `defer dbsession.Close()` code, which copies the `mgo.Session` and cleans up afterwards. Since we&#x2019;re calling the ServeHTTP method on the original handler (which we haven&#x2019;t written yet) we know that the request will be finished by the time execution passes back to our function, which can exit allowing the deferred `Close` call to run.</p><blockquote name="aebe" id="aebe" class="graf--blockquote graf-after--p">If you&#x2019;re really confused by what&#x2019;s going on here&#x200A;&#x2014;&#x200A;you can always add some `log.Println` lines once we&#x2019;ve got everything wired up to inspect it further.</blockquote><p name="8ac0" id="8ac0" class="graf--p graf-after--h4">Routing essentially refers to deciding which code to run in response to significant things in the request, such as the HTTP method. There are some great packages that do this for us, but for our case we can keep things very simple indeed.</p><p name="2933" id="2933" class="graf--p graf-after--p">Add the following method to main.go:</p><pre name="00b1" id="00b1" class="graf--pre graf-after--p">func handle(w http.ResponseWriter, r *http.Request) {<br> switch r.Method {<br> case "GET":<br> handleRead(w, r)<br> case "POST":<br> handleInsert(w, r)<br> default:<br> http.Error(w, &#x201C;Not supported&#x201D;, http.StatusMethodNotAllowed)<br> }<br>}</pre><p name="f9a5" id="f9a5" class="graf--p graf-after--pre">This simple router will call either `handleRead` or `handleInsert` depending on the HTTP method.</p><p name="4bcd" id="4bcd" class="graf--p graf-after--h4">Since this is the only handler our API will use, we can now modify our main function to connect to MongoDB, adapt the handle function we just added, and tell the http package to serve it on port&#xA0;:8080.</p><p name="ba83" id="ba83" class="graf--p graf-after--p">Modify the main function:</p><pre name="b820" id="b820" class="graf--pre graf-after--p">func main() {</pre><pre name="6302" id="6302" class="graf--pre graf-after--pre"> // connect to the database<br> db, err := mgo.Dial("localhost")<br> if err != nil {<br> log.Fatal("cannot dial mongo", err)<br> }<br> defer db.Close() // clean up when we&#x2019;re done</pre><pre name="e468" id="e468" class="graf--pre graf-after--pre"> // Adapt our handle function using withDB<br> h := Adapt(http.HandlerFunc(handle), withDB(db))</pre><pre name="162a" id="162a" class="graf--pre graf-after--pre"> // add the handler<br> http.Handle("/comments", context.ClearHandler(h))</pre><pre name="83ae" id="83ae" class="graf--pre graf-after--pre"> // start the server<br> if err := http.ListenAndServe(":8080", nil); err != nil {<br> log.Fatal(err)<br> }</pre><pre name="61ad" id="61ad" class="graf--pre graf-after--pre">}</pre><p name="e408" id="e408" class="graf--p graf-after--pre">The `mgo.Dial` function is how we connect to MongoDB. It returns an `mgo.Session` object, which is what we pass into `withDB`. Once we&#x2019;re connected, we defer the closing of the database connection, which will keep things nice and tidy.</p><p name="e57e" id="e57e" class="graf--p graf-after--p">We then use the Adapt helper function to adapt our `handle` function using the Adapter returned from our call to `withDB`. The `h` variable now contains an http.Handler that, when called, will copy the database session, and then call the `handle` function.</p><p name="9a79" id="9a79" class="graf--p graf-after--p">`http.Handle` allows us to tell the standard library to use our handler for all requests beginning with `/comments`.</p><p name="3dbd" id="3dbd" class="graf--p graf-after--p">`context.ClearHandler` is another Adapter provided by the context package that, after calling the handler, will clean up any memory used by the `context.Set` method.</p><p name="747d" id="747d" class="graf--p graf-after--p graf--last">Finally we `ListenAndServe` our code on port 8080.</p></div></div></section><section name="44eb" class=" section--body" score="41.25"><div class="section-content" score="31.25"><div class="section-inner layoutSingleColumn"><p name="6b18" id="6b18" class="graf--p graf-after--h3">Now that the structure for our program is in place, we are ready to write the two handlers that will actually interact with MongoDB to do the work for us.</p><p name="1c54" id="1c54" class="graf--p graf-after--h4">Now we will write our `handleInsert` function that will take the data from an http.Request, and insert it into the database. We&#x2019;re going to decode the request body manually here, but you might want to consider some <a href="https://medium.com/@matryer/patterns-for-decoding-and-validating-input-in-go-data-apis-152291ac7372" class="markup--anchor markup--p-anchor">patterns for decoding and validating input</a>. Once we&#x2019;ve decided the comment data, we&#x2019;ll set the time and a give it a unique ID before inserting it into the database. Finally, we&#x2019;ll redirect the user to a path that uniquely describes the new comment.</p><p name="7848" id="7848" class="graf--p graf-after--p">First let&#x2019;s create a type that will hold our data:</p><pre name="0af1" id="0af1" class="graf--pre graf-after--p">type comment struct {</pre><pre name="8ffd" id="8ffd" class="graf--pre graf-after--pre"> ID bson.ObjectId `json:"id" bson:"_id"`<br> Author string `json:"author" bson:"author"`<br> Text string `json:"text" bson:"text"`<br> When time.Time `json:"when" bson:"when"`</pre><pre name="f9ad" id="f9ad" class="graf--pre graf-after--pre">}</pre><p name="1ca5" id="1ca5" class="graf--p graf-after--pre">Our `comment` struct will hold the data that represents a single comment. Most of the field types are obvious, except for the ID. `bson.ObjectId` is a special type provided by the mgo package (actually by the mgo/bson package) that represents a MongoDB identifier.</p><blockquote name="bda3" id="bda3" class="graf--blockquote graf-after--p"><a href="https://en.wikipedia.org/wiki/BSON" class="markup--anchor markup--blockquote-anchor" rel="nofollow">BSON</a> is a binary JSON format that MongoDB uses.</blockquote><p name="c70f" id="c70f" class="graf--p graf-after--blockquote">The tags (in backtics) after each field definition describes how we want our data to look in different contexts. So the ID in JSON will be in a field called &#x201C;id&#x201D;, but in the database (when encoded using BSON) it will be known as &#x201C;_id&#x201D;.</p><p name="3934" id="3934" class="graf--p graf-after--p">Add the following code to main.go:</p><pre name="0ef0" id="0ef0" class="graf--pre graf-after--p">func handleInsert(w http.ResponseWriter, r *http.Request) {<br> db := context.Get(r, &#x201C;database&#x201D;).(*mgo.Session)</pre><pre name="f9ba" id="f9ba" class="graf--pre graf-after--pre"> // decode the request body<br> var c comment<br> if err := json.NewDecoder(r.Body).Decode(&amp;c); err != nil {<br> http.Error(w, err.Error(), http.StatusBadRequest)<br> return<br> }</pre><pre name="26dd" id="26dd" class="graf--pre graf-after--pre"> // give the comment a unique ID and set the time<br> c.ID = bson.NewObjectId()<br> c.When = time.Now()</pre><pre name="9a1d" id="9a1d" class="graf--pre graf-after--pre"> // insert it into the database<br> if err := db.DB(&#x201C;commentsapp&#x201D;).C(&#x201C;comments&#x201D;).Insert(&amp;c); err != nil {<br> http.Error(w, err.Error(), http.StatusBadRequest)<br> return<br> }</pre><pre name="619e" id="619e" class="graf--pre graf-after--pre"> // redirect to it<br> http.Redirect(w, r, &#x201C;/comments/&#x201D;+c.ID.Hex(), http.StatusTemporaryRedirect)</pre><pre name="4ec0" id="4ec0" class="graf--pre graf-after--pre">}</pre><p name="8b18" id="8b18" class="graf--p graf-after--pre">The first thing we do is get, from the context, the database session copy that our adapter put in there for us. Notice that we don&#x2019;t have to worry about closing the database session&#x200A;&#x2014;&#x200A;our adapted handler does all that for us.</p><p name="7943" id="7943" class="graf--p graf-after--p">We then use the encoding/json package from the standard library to decode the request body into the `c` variable which has the type `comment`.</p><p name="ed6c" id="ed6c" class="graf--p graf-after--p">Assuming everything is fine, we then give the comment a unique ID (using the helpful bson.NewObjectId function) and set the When field to now.</p><p name="481a" id="481a" class="graf--p graf-after--p">Then comes the interesting piece where we actually perform the insertion.</p><p name="393f" id="393f" class="graf--p graf-after--p">The mgo package uses a fluent API; chained method calls on an object (each returning the object itself or a more specialised object) allow you to write code in a single line, usually in a way that is easy to read or even speak.</p><blockquote name="ebde" id="ebde" class="graf--blockquote graf-after--p">I would argue that this isn&#x2019;t idiomatic Go&#x200A;&#x2014;&#x200A;and actually wouldn&#x2019;t recommend you write APIs like this.</blockquote><p name="afa3" id="afa3" class="graf--p graf-after--blockquote">We use the DB function to specify that we want to deal with the &#x201C;commentsapp&#x201D; database and the C method lets us specify that we want to deal with the &#x201C;comments&#x201D; collection. We are then free to call the `Insert` method, which will communicate to the database to actually perform the insertion. It may return an error, and if it does, we&#x2019;ll pass this back to the client.</p><p name="9c4a" id="9c4a" class="graf--p graf-after--p">Finally we redirect the client to a path that includes the unique ID that we just created for our comment.</p><p name="b36e" id="b36e" class="graf--p graf-after--h4">Once we have data being inserted into the database, it seems sensible to want to read it back. Our handleRead function will get the database session copy in the same way our handleInsert did. It will then use the API to perform a Find query on the comments, sorting and limiting the output before reading it all into a slice of `comment` objects. We&#x2019;ll then respond manually using a json.Encoder type.</p><blockquote name="13c0" id="13c0" class="graf--blockquote graf-after--p">If you&#x2019;re interested in patterns that assist with responding with data, check out <a href="https://medium.com/@matryer/api-responses-in-go-1ef8f7b74997" class="markup--anchor markup--blockquote-anchor">API responses in Go</a>.</blockquote><p name="ae7a" id="ae7a" class="graf--p graf-after--blockquote">Add the `handleRead` code to main.go:</p><pre name="ed13" id="ed13" class="graf--pre graf-after--p">func handleRead(w http.ResponseWriter, r *http.Request) {</pre><pre name="8270" id="8270" class="graf--pre graf-after--pre"> db := context.Get(r, &#x201C;database&#x201D;).(*mgo.Session)</pre><pre name="be05" id="be05" class="graf--pre graf-after--pre"> // load the comments<br> var comments []*comment<br> if err := db.DB(&#x201C;commentsapp&#x201D;).C(&#x201C;comments&#x201D;).<br> Find(nil).Sort(&#x201C;-when&#x201D;).Limit(100).All(&amp;comments); err != nil {</pre><pre name="e0c6" id="e0c6" class="graf--pre graf-after--pre"> http.Error(w, err.Error(), http.StatusInternalServerError)<br> return</pre><pre name="b3ab" id="b3ab" class="graf--pre graf-after--pre"> }</pre><pre name="5a10" id="5a10" class="graf--pre graf-after--pre"> // write it out<br> if err := json.NewEncoder(w).Encode(comments); err != nil {<br> http.Error(w, err.Error(), http.StatusInternalServerError)<br> return<br> }</pre><pre name="af23" id="af23" class="graf--pre graf-after--pre">}</pre><p name="ca37" id="ca37" class="graf--p graf-after--pre">Our `comments` variable is a slice of `comment` objects, which is where we&#x2019;ll store the data once we&#x2019;ve read it from the database.</p><p name="ebe9" id="ebe9" class="graf--p graf-after--p">Where we previously called Insert, we now call Find to indicate that we want to perform a query. The nil argument we pass in means that we do not want to filter the comments in any way&#x200A;&#x2014;&#x200A;rather we want to select them all.</p><p name="c453" id="c453" class="graf--p graf-after--p">We then use Sort and Limit to indicate that we want our comments to be returned newest first, and up to a maximum of 100 comments.</p><blockquote name="4e1a" id="4e1a" class="graf--blockquote graf-after--p">More advanced APIs will implement paging which will use the URL parameters to call Skip and Limit appropriately.</blockquote><p name="487f" id="487f" class="graf--p graf-after--blockquote">Finally, the call to the `All` method will initiate the operation, loading the data into the aforementioned comments slice.</p><p name="f54c" id="f54c" class="graf--p graf-after--p graf--last">All being well, we then use the json.Encoder to write the data out through the http.ResponseWriter.</p></div></div></section><section name="3590" class=" section--body section--last" score="41.25"><div class="section-content" score="32.5"><div class="section-inner layoutSingleColumn" score="12.0"><p name="f3d9" id="f3d9" class="graf--p graf-after--h3">While we could (and indeed should) use unit tests to assert that our API is functioning correctly, we will instead use simple curl commands to see it in action.</p><p name="ec5b" id="ec5b" class="graf--p graf-after--h4">Since we have everything in one file, to execute our program we simply need to open a command line terminal and use `go run` to build and run it:</p><pre name="a275" id="a275" class="graf--pre graf-after--p">go run main.go</pre><blockquote name="3cae" id="3cae" class="graf--blockquote graf-after--pre">In reality, your APIs will grow beyond a single file&#x200A;&#x2014;&#x200A;so you should probably get used to using `go build` to build multi-file programs.</blockquote><p name="24af" id="24af" class="graf--p graf-after--blockquote">Once the program is running (provided you get no errors), we can then start to hit the endpoints that we have just created.</p><p name="4ca8" id="4ca8" class="graf--p graf-after--h4">In another terminal window, run the following (single line) command:</p><pre name="cddb" id="cddb" class="graf--pre graf-after--p">curl -i -X POST -d '{"text":"Hi there","author":"me"}' <a href="http://localhost:8080/comments" class="markup--anchor markup--pre-anchor">http://localhost:8080/comments</a></pre><p name="0d53" id="0d53" class="graf--p graf-after--pre">This will perform a POST operation to /comments, sending the specified JSON as the request body. Repeat this command a few times to insert many comments.</p><p name="c251" id="c251" class="graf--p graf-after--p">You will see output like this:</p><pre name="4c57" id="4c57" class="graf--pre graf-after--p">HTTP/1.1 307 Temporary Redirect<br>Location: /comments/564b2a3f1f3adf0bc4000001<br>Date: Tue, 17 Nov 2015 13:23:11 GMT<br>Content-Length: 0<br>Content-Type: text/plain; charset=utf-8</pre><p name="2814" id="2814" class="graf--p graf-after--pre">The above response indicates that the new comment was created, and has a unique ID of 564b2a3f1f3adf0bc4000001.</p><blockquote name="7ce6" id="7ce6" class="graf--blockquote graf-after--p">Content-Type being text/plain isn&#x2019;t right&#x200A;&#x2014;&#x200A;it should be application/json, but you can fix that yourself&#xA0;:)</blockquote><p name="0d46" id="0d46" class="graf--p graf-after--h4">Now we are ready to read the comments. This time, we&#x2019;ll use a web browser to see them. Open your favourite browser and access <a href="http://localhost:8080/comments." class="markup--anchor markup--p-anchor">http://localhost:8080/comments.</a></p><p name="8206" id="8206" class="graf--p graf-after--p">All being well, you will see a JSON array containing the most recent 100 comments.</p><p name="edc2" id="edc2" class="graf--p graf-after--h3">We have built the foundation of most web APIs backed by MongoDB. There is more work to do, but you have the basis on which to build that.</p><p name="7b2f" id="7b2f" class="graf--p graf-after--h4">If you wish to stretch yourself, then see if you can solve the following challenges by tweaking or enhancing your code.</p><ol class="postList"><li name="8f3a" id="8f3a" class="graf--li graf-after--p">EASY: Allow the client to indicate how many comments to return using a URL parameter, like /comments?limit=10</li><li name="5762" id="5762" class="graf--li graf-after--li">EASY: Allow the client to specify the order of the comments as either ascending or descending. Perhaps with /comments?sort=asc|desc</li><li name="512d" id="512d" class="graf--li graf-after--li">MEDIUM: Implement another handler so that /comments/{commentID} actually works&#x200A;&#x2014;&#x200A;and returns only the single comment referred to</li><li name="18d1" id="18d1" class="graf--li graf-after--li">MEDIUM: Validate that incoming comments MUST have an author, or else return an error</li><li name="d778" id="d778" class="graf--li graf-after--li graf--last">HARD: Using more advanced routing (homegrown or by using an existing library) allow comments to be grouped by topic. GETting /comments/topic1 should give different comments to GETting /comments/topic2. Topics should be inserted by POSTing to /comments/{topicname}</li></ol></div></div></section></div>
</body></html>
