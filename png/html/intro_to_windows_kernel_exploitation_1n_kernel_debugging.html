<!DOCTYPE html><html><head><title>Intro to Windows kernel exploitation 1/N: Kernel Debugging</title></head><body>
<h1>Intro to Windows kernel exploitation 1/N: Kernel Debugging</h1><p><a href="https://www.whitehatters.academy/intro-to-kernel-exploitation-part-1/" target="_new">Original URL</a></p>
<p><blockquote>By Sam Brown (@_samdb_) I've been learning Windows kernel exploitation recently and decided to turn my notes into a rough tutorial. Obviously I'm only just learning all of this myself so any&hellip;</blockquote></p>
<div><section class="post-content">
 <p>By Sam Brown (<a href="https://twitter.com/_samdb_">@_samdb_</a>)</p>

<p>I've been learning Windows kernel exploitation recently and decided to turn my notes into a rough tutorial. Obviously I'm only just learning all of this myself so any corrections, feedback or abuse is much appreciated :)</p>

<p>This part is going to run through setting up and using a kernel debugger, parts <a href="https://www.whitehatters.academy/intro-to-windows-kernel-exploitation-2-windows-drivers/">2</a> &amp; <a href="https://www.whitehatters.academy/intro-to-windows-kernel-exploitation-3-my-first-driver-exploit/">3</a> will focus on exploiting some easy vulnerabilities in a practise target driver and in parts 4 &amp; 5 we'll look at writing exploits for some old vulnerabilities.</p>

<h4 id="gettingsetup">Getting Setup</h4>

<p>In order to use WinDbg for kernel debugging we will be running it outside of the host machine, in some circumstances you can run it on your host machine but its far easier to just use VMs (especially when you'll be blue screening the machine ;)). To do this we create two Virtual Machines and use one debug the other over a virtual serial port. For this series of posts I'm using a Win10 VM for debugging and an unpatched 32 bit Win7 VM as the target machine (because well, simpler times and all that) running inside of VirtualBox.</p>

<p>Start off by setting up the VMs as normal and then install Windows Debugging tools in your debugging VM which you can get from the Windows SDK, you won't need debugging tools in the target VM. <br>
Once setup, you can enter the command 'bcdedit /debug on' in an administrator command prompt on the target VM, this makes it so that on start-up it will connect to its com1 serial port and allow another machine to connect to it and debug it. </p>

<p>Now we need to create a serial device for both of our VMs, power both of them off and then open their VM settings screens and change the contents of each machines serial port tab to look like the following:</p>

<p>Target Machine &#x2013; win7 32 bit <br>
<img src="https://raw.githubusercontent.com/sam-b/intro-to-kernel-exploitation/master/screenshots/part_1/kern_debugging_target_machine_serial_settings.PNG" alt="Target machine serial config">
Debugger Machine &#x2013; win10 <br>
<img src="https://raw.githubusercontent.com/sam-b/intro-to-kernel-exploitation/master/screenshots/part_1/kern_debugging_debugger_machine.PNG" alt="Debugging machine serial config"></p>

<p>Now both machines should connect to a host pipe on COM1 at path \.\pipe\$name on startup. The name can be anything, as long as it matches on both VMs. The only configuration difference is that your debugging machine is creating the pipe on startup and the target machine is connecting to the pipe that the debugging machine should have already created.</p>

<p>Now power on your debugging machine and start WinDbg, first we need to set our symbol path. Setting the symbol path means that Windows can download PDB (Programme Database) files containing the debug data which allows us to see object/function/etc names instead of just memory addresses, these are created by the linker at build time and aren't include in the final binaries as the symbols are only needed for debugging and excluding them allows for smaller and faster binaries. This can done in WinDBG by going to the File menu and then selecting Symbol File Path and entering 'SRV*$symbol_cache_path*<a href="http://msdl.microsoft.com/download/symbols">http://msdl.microsoft.com/download/symbols</a>' in my case I use C:\symbols as my local symbol cache directory for example:</p>

<p><img src="https://raw.githubusercontent.com/sam-b/intro-to-kernel-exploitation/master/screenshots/part_1/kern_debugging_symbols_screenshot.PNG" alt="symbol path example" title=""></p>

<p>When needed WinDbg will download the symbol file for each loaded module (executable, library etc), caching them in the C:\symbols directory. At this point simply click OK and then to start kernel debugging go to File-&gt; Kernel Debug... -&gt; COM and click OK as shown below:</p>

<p><img src="https://raw.githubusercontent.com/sam-b/intro-to-kernel-exploitation/master/screenshots/part_1/kern_debug_start_kernel_debugging.PNG" alt="Start kernel debugger" title=""></p>

<p>Now power on your target machine and once it has started you should see its details in the WinDbg output like so: <br>
<img src="https://raw.githubusercontent.com/sam-b/intro-to-kernel-exploitation/master/screenshots/part_1/kern_debug_started_screenshot.PNG" alt="Kernel debugger started"></p>

<p>With all this done, we are ready to start using our debugger.</p>

<h4 id="aquickwindbgtutorial">A quick WinDbg tutorial</h4>

<p>Start by going to the 'Debug' menu and selecting 'Break', this should pause the target host as can be seen by trying to use that VM (everything should be frozen). Now we can make sure that our symbols are loaded correctly by entering 'dt nt!_TEB' in the command box and hitting enter, the 'dt' command stands for 'display type' and can be used to see local variables, fields of structures or data type definitions. The command should give output that looks like this:</p>

<p><img src="https://raw.githubusercontent.com/sam-b/intro-to-kernel-exploitation/master/screenshots/part_1/kern_debug_dt_1.PNG" alt="data type TEB" title=""></p>

<p>You'll notice that this doesn't show the structure of substructures, for example the _NT_TID structure. We can see substructures aswell by rerunning the command with the '-r' flag to recursively print definitions and '-r $int' to recurse a chosen number of levels.</p>

<p><img src="https://raw.githubusercontent.com/sam-b/intro-to-kernel-exploitation/master/screenshots/part_1/kern_debug_dt_2.PNG" alt="data type TEB recurse" title=""></p>

<p>The TEB structure is the Thread Environment Block and it describes the state of a thread, there's a cool visualisation of how it has changed over the years at: <a href="http://terminus.rewolf.pl/terminus/structures/ntdll/_TEB_combined.html">http://terminus.rewolf.pl/terminus/structures/ntdll/_TEB_combined.html</a>, however it&#x2019;s just a random structure I chose so we don't need to know any more about it for now :)</p>

<p>Next run the command 'ba e 1 nt!ZwCreateFile', this sets a hardware breakpoint which will be triggered on the execution of the first byte of data at the address that ZwCreateFile is located in memory. I'm using hardware breakpoints because software breakpoints are unreliable while debugging kernel mode code and they also expose some extra functionality, for example we can set the type of access to be read, write or execute while software breakpoints can only be triggered on execute and we can set the granularity to be 1 to 4 bytes. On the downside on x86 we can only have four hardware breakpoints set at a time as they use the dr0-dr3 registers (where dr stands for debug register), if you have the register view open in WinDBG you should be able to see the address of nt!ZwCreateFile in the dr0 register now.</p>

<p>The ZwCreateFile function is part of the Zw prefixed family of functions inside of ntdll.dll and ntoskrnl.exe which are light weight wrappers around system calls. The Zw doesn't actually stand for anything but Nt and Zw calls are differentiated by the fact that Zw functions behave <a href="https://www.osronline.com/article.cfm?id=257">slightly differently</a> when called from kernel mode code. ZwCreateFile itself is a routine which creates a new file or opens an existing one.</p>

<p><img src="https://raw.githubusercontent.com/sam-b/intro-to-kernel-exploitation/master/screenshots/part_1/hardware_breakpoint_take_2.PNG" alt="ZwCreateFile hardware breakpoint" title=""></p>

<p>You can see I also used 'bl' to list the current breakpoints, the first value - 0 is the breakpoint ID which we can use to refer to the breakpoint in other commands. The second field is the breakpoint flag and is currently 'e' which indicates that it is enabled, the common values you will see here are 'd' if the breakpoint is disabled and 'u' which stands for unresolved and appears when a breakpoint is set on an address which doesn't match a symbol in any of the currently loaded modules. The next value (8286d340) is the memory address the breakpoint has been placed at, this should match the value in the corresponding drX register. The next 'e' indicates it is triggered on execution and the 1 is the byte granularity. The next two values represent the counter of the number of times the breakpoint must be hit again before it is triggered and in brackets the initial counter value.</p>

<p>Now we type 'go' (or &#x2018;g&#x2019; to save those precious chars) in the command window, hit enter and go back into the target VM. We then open notepad, select file then Save As and everything should freeze. Going back to our debugging VM we see that the breakpoint has been hit. We can enter the &#x2018;r&#x2019; command to see the current register state and &#x2018;u eip&#x2019; to view the instructions which triggered it. <br>
<img src="https://raw.githubusercontent.com/sam-b/intro-to-kernel-exploitation/master/screenshots/part_1/breakpoint_hit.PNG" alt="Breakpoint hit">
We can enter 'bc 0' to clear the breakpoint or 'bc *' to clear all set breakpoints if you've entered extra breakpoints and then enter 'go' again.</p>

<p>That's alllllll folks.</p>

<h4 id="furtherreading">Further Reading</h4>

<p>Windows Internals Part 1 - chapters 1 and 2 <br>
Practical Reverse Engineering - chapters 3 &amp; 4</p>
 </section>

 


</div>
</body></html>
