<!DOCTYPE html><html><head><title>Becoming fully reactive: an in-depth explanation of Mobservable</title></head><body>
<h1>Becoming fully reactive: an in-depth explanation of Mobservable</h1><p><a href="https://medium.com/@mweststrate/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254#.1ue3s24h2" target="_new">Original URL</a></p>
<p><blockquote>Due to popular demand (and to have a cool story for my grand-children), these are the inner workings of Mobservable. A lot of people are surprised how consis</blockquote></p>
<div score="36.25"><section name="9018" class=" section--body section--first" score="41.25"><div class="section-content" score="35.0"><div class="section-inner u-sizeFullWidth" score="1.25"><figure name="f813" id="f813" class="graf--figure graf--layoutFillWidth graf--first" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://cdn-images-1.medium.com/max/2000/1*Q89nqGHbuc27ucCL0vpWRQ.jpeg"></div></figure></div><div class="section-inner layoutSingleColumn" score="-10.5"><figure name="2b09" id="2b09" class="graf--figure graf-after--h3" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://cdn-images-1.medium.com/max/800/1*Ca3Wp7Huxmf2aGuAxludJA.png"></div></figure><p name="dbae" id="dbae" class="graf--p graf-after--figure">Due to popular demand (and to have a cool story for my grand-children), these are the inner workings of Mobservable. A lot of people are surprised how consistent and fast Mobservable is. But rest assured, there is no magic in play!</p><p name="b82a" id="b82a" class="graf--p graf-after--p">First, let&#x2019;s define the core concepts of Mobservable:</p><ol class="postList"><li name="5a4d" id="5a4d" class="graf--li graf-after--p"><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">Observable state</em></strong>. Any value that can be mutated and might serve as source for computed values is state. Mobservable can make most types of values (primitives, arrays, classes, objects, etc.) and even (potentially cyclic) references observable out of the box.</li><li name="0382" id="0382" class="graf--li graf-after--li"><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">Computed values.</em></strong> Any value that can be computed by using a function that purely operates on other observable values. Computed values can range from the concatenation of a few strings up to deriving complex object graphs and visualizations. Because computed values are observable themselves, even the rendering of a complete user interface can be derived from the observable state. Computed values might evaluate either lazily or in reaction to state changes.</li><li name="5138" id="5138" class="graf--li graf-after--li"><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">Reactions.</em></strong> A reaction is a bit similar to a computed value, but instead of producing a new value it produces a side effect. Reactions bridge reactive and imperative programming for things like printing to the console, making network requests, incrementally updating the React component tree to patch the DOM, etc.</li><li name="3971" id="3971" class="graf--li graf-after--li"><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">Actions.</em></strong> Actions are the primary means to modify the state. Actions are not a reaction to state changes but take sources of change, like user events or incoming web-socket connections, to modify the observable state.</li></ol><p name="447d" id="447d" class="graf--p graf-after--li"><em class="markup--em markup--p-em">Computed values </em>and <em class="markup--em markup--p-em">reactions</em> are both referred to as <em class="markup--em markup--p-em">derivations </em>in the remainder of this blog-post<em class="markup--em markup--p-em">. </em>So far, this might all sound a bit academic so let&#x2019;s make it concrete! In a spreadsheet all data cells that have values would form the <em class="markup--em markup--p-em">observable state</em>. Formulas and charts are <em class="markup--em markup--p-em">computed values</em> that can be derived from the data cells and other formulas. Drawing the output of a data cell or a formula on the screen is a <em class="markup--em markup--p-em">reaction</em>. Changing a data cell or formula is an <em class="markup--em markup--p-em">action</em>.</p><p name="e1f7" id="e1f7" class="graf--p graf-after--p">Anyway, here are all four concepts in a small example that uses Mobservable and React:</p><figure name="e25b" id="e25b" class="graf--figure graf--iframe graf-after--p" score="-13.75"><figcaption class="imageCaption">Listing 1: Observable state, computed values, reactive Reactjs component and some actions</figcaption></figure><p name="a830" id="a830" class="graf--p graf-after--figure">We could draw a dependency tree based on the above listing. Intuitively it will look as follows:</p><figure name="1c57" id="1c57" class="graf--figure graf-after--p" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://cdn-images-1.medium.com/max/800/1*YPlKuWsPrVbhxUN7YhyTpg.png"></div><figcaption class="imageCaption">Figure 1: Dependency tree of profileView component. FullName is in reactive mode, actively observing firstName and lastName.</figcaption></figure><p name="fbde" id="fbde" class="graf--p graf-after--figure">The <em class="markup--em markup--p-em">state</em> of this applications is captured in the <em class="markup--em markup--p-em">observable</em> properties (blue). The green <em class="markup--em markup--p-em">computed value</em> fullName can be derived from the state automatically by observing the firstName and the lastName. Similarly the rendering of the profileView can be derived from the nickName and the fullName. The profileView will react to state changes by producing a side effect: it updates the React component tree.</p><p name="92ed" id="92ed" class="graf--p graf-after--p">When using Mobservable the dependency tree is minimally defined. For example, as soon as the person being rendered has a nickname, the rendering will no longer be affected by the output of the fullName value, nor the first- or lastName (see listing 1). All observer relations between those values can be cleaned up and Mobservable will automatically simplify the dependency tree accordingly:</p><figure name="87f4" id="87f4" class="graf--figure graf-after--p" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://cdn-images-1.medium.com/max/800/1*SXiDJ_mQ0ctEj2QEurLpqA.png"></div><figcaption class="imageCaption">Figure 2: Dependency tree of the profileView component if the user has a nickname (see listing 1). In contrast to figure 1, fullName is now in lazy mode and does not observe firstName and lastName</figcaption></figure><p name="d435" id="d435" class="graf--p graf-after--figure">Mobservable will always try to minimize the number of computations that are needed to produce a consistent state. In the rest of this blog post, I will describe several strategies used to achieve this goal. But before diving into the magic of how computed values and reactions are kept in sync with the state, let&#x2019;s first describe the principle behind Mobservable:</p><figure name="4dd1" id="4dd1" class="graf--figure graf--iframe graf-after--h3" score="-13.75"></figure><p name="b9b6" id="b9b6" class="graf--p graf-after--figure">Any imperative action that an application takes in response to a state change usually creates or updates some values. In other words, most actions manage a <a href="https://medium.com/@mweststrate/pure-rendering-in-the-light-of-time-and-state-4b537d8d40b1#.6pt68lack" class="markup--anchor markup--p-anchor">local cache</a>. Triggering the user interface to update? Updating aggregated values? Notifying the back-end? These can all be thought of as cache invalidations in disguise. To ensure these caches will stay in sync, you need to subscribe to future state changes that will enable your actions to be triggered again.</p><p name="3b97" id="3b97" class="graf--p graf-after--p">But working with subscriptions (or cursors, lenses, selectors, connectors, etc) has a fundamental problem: as your app evolves, you will make mistakes in managing those subscriptions and either oversubscribe (continue subscribing to a value or store that is no longer used in a component) or undersubscribe (forgetting to listen for updates leading to subtle staleness bugs).</p><blockquote name="78a3" id="78a3" class="graf--pullquote pullquote graf-after--p">In other words; when using manual subscriptions, your app will eventually be inconsistent.</blockquote><figure name="ba1d" id="ba1d" class="graf--figure graf-after--pullquote" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://cdn-images-1.medium.com/max/800/1*1fW10m1Cu3uwJ49hMNNofg.png"></div><figcaption class="imageCaption">Figure 3: Inconsistent Twitter page after updating profile. The pinned tweet is displaying stale values for both the name and the profile picture of the author.</figcaption></figure><p name="8d44" id="8d44" class="graf--p graf-after--figure">The above image is a nice example of the Twitter UI being inconsistent. As explained in my <a href="https://www.youtube.com/watch?v=FEwLwiizlk0" class="markup--anchor markup--p-anchor" rel="nofollow">Reactive2015 talk</a>, there can only be two causes for this: Either there is no subscription that tells tweets to re-render if the profile of the associated author has changed. Or the data was normalized and the author of a tweet doesn&#x2019;t even relate to the profile of the currently logged-in user, despite the fact that both pieces of data try to describe the same properties of the same person.</p><p name="797d" id="797d" class="graf--p graf-after--p">Coarse grained subscriptions like Flux-style store subscriptions are very susceptible to oversubscribing. When using React, you can simply tell whether your components are oversubscribing by printing <a href="https://facebook.github.io/react/docs/perf.html#perf.printwastedmeasurements" class="markup--anchor markup--p-anchor" rel="nofollow">wasted renderings</a>. Mobservable will <a href="https://www.mendix.com/tech-blog/making-react-reactive-pursuit-high-performing-easily-maintainable-react-apps/" class="markup--anchor markup--p-anchor" rel="nofollow">reduce this number to zero.</a> The idea is simple yet counterintuitive: More subscriptions result in fewer recomputations. Mobservable manages many thousands of observers for you. You can effectively tradeoff memory for CPU cycles.</p><p name="8173" id="8173" class="graf--p graf-after--p">Note that oversubscribing also exists in very subtle forms. If you subscribe to data that is used, but not under <em class="markup--em markup--p-em">all</em> conditions, you are still oversubscribing. For example, if the profileView component subscribes to the fullName of a person that has a nickName, it is oversubscribing (see listing 1). So an important principle behind the design Mobservable is:</p><blockquote name="ea48" id="ea48" class="graf--pullquote pullquote graf-after--p">A minimal, consistent set of subscriptions can only be achieved if subscriptions are determined at run-time.</blockquote><p name="459b" id="459b" class="graf--p graf-after--pullquote graf--last">The second important idea behind Mobservable is that for any app that is more complex than TodoMVC, you will often need a <em class="markup--em markup--p-em">data graph</em>, instead of a normalized tree, to store the state in a <em class="markup--em markup--p-em">mentally manageable</em> yet optimal way. Graphs enable referential consistency and avoid data duplication so that it can be guaranteed that derived values are never stale.</p></div></div></section><section name="fbbc" class=" section--body" score="41.25"><div class="section-content" score="32.5"><div class="section-inner layoutSingleColumn" score="4.5"><p name="e7e3" id="e7e3" class="graf--p graf-after--h3">The solution: don&#x2019;t cache, derive instead. People ask: &#x201C;isn&#x2019;t that extremely expensive?&#x201D; No, it is actually very efficient! The reason for that is, as explained above: Mobservable doesn&#x2019;t run all derivations, but ensures that only <em class="markup--em markup--p-em">computed values</em> that are actually used by a <em class="markup--em markup--p-em">reaction</em> are kept in sync with the observable state. Those derivations are called to be <em class="markup--em markup--p-em">reactive</em>. To draw the parallel with spreadsheets again: only those formulas that are currently visible or that are used indirectly by a visible formula, need to re-compute when one of the observed data cells change.</p><p name="851c" id="851c" class="graf--p graf-after--h4">So what about computations that aren&#x2019;t used directly or indirectly by a reaction? You can still inspect the value of a computed value like fullName at any time. The solution is simple: if a computed value is not reactive, it will be evaluated lazily, just like a normal getter function. Lazy derivations (which never observe anything) can simply be garbage collected if they run out of scope. Remember that computed values should always be <em class="markup--em markup--p-em">pure functions</em> of the observable app state? This is the reason why: For pure functions it doesn&#x2019;t matter whether they are evaluated lazily or eagerly; the evaluation of the function always yields the same result given the same observable state.</p><p name="a93a" id="a93a" class="graf--p graf-after--h4">Reactions and computed values are both run by Mobservable in the same manner. When a recomputation is triggered the function is pushed onto the <em class="markup--em markup--p-em">derivation stack</em>; a function stack of currently running derivations. As long as a computation is running, every observable that is accessed will register itself as a dependency of the topmost function of the derivation stack. If the value of a computed value is needed, the value can simple be the last known value if the computed is already in the reactive state. And otherwise it will push itself on the derivation-stack, switch to reactive mode and start computing as well.</p><figure name="b94c" id="b94c" class="graf--figure graf-after--p" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://cdn-images-1.medium.com/max/800/1*Pb3Wd14BlXPgqylBN_y-hQ.png"></div><figcaption class="imageCaption">Figure 4: During the execution of the profileView reaction some observable state and some computed values are being observed. Computed values might recompute, this results in the the dependency tree as shown in figure 1.</figcaption></figure><p name="17b5" id="17b5" class="graf--p graf-after--figure">When a computation completes, it will have obtained a list of observables that were accessed during execution. In the profileView for example, this list will either just contain the nickName property, or the nickName and fullName properties. This list is diffed against the previous list of observables. Any removed items will be unobserved (computed values might go back from reactive to lazy mode at this point) and any added observables will be observed until the next computation. When the value of for example firstname is changed in the future, it knows that fullName needs to be recomputed. Which in turn will cause profile view to recomputed. The next paragraph explains this process in more detail.</p><figure name="37ce" id="37ce" class="graf--figure graf-after--h4" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://cdn-images-1.medium.com/max/800/1*Et95GdR7OeOofl_V0Od4iA.png"></div><figcaption class="imageCaption">Figure 5: The effects of changing value &#x2018;1&#x2019; on the dependency tree. The dashed border indicates the observers that will be marked as stale. Numbers indicate the order of computation.</figcaption></figure><p name="ec50" id="ec50" class="graf--p graf-after--figure">Derivations will react to state changes automatically. All reactions happen <em class="markup--em markup--p-em">synchronously</em> and more importantly <em class="markup--em markup--p-em">glitch-free</em>. When an observable value is modified the following algorithm is performed:</p><ol class="postList"><li name="d5fa" id="d5fa" class="graf--li graf-after--p">The observable value sends a <em class="markup--em markup--li-em">stale notification</em> to all its observers to indicate that it has become stale. Any affected computed values will recursively pass on the notification to their observers. As a result, a part of the dependency tree will be marked as <em class="markup--em markup--li-em">stale</em>. In the example dependency tree of figure 5, the observers that will become stale when value &#x2018;1&#x2019; is changed are marked with an orange, dashed border. These are all the derivations that <em class="markup--em markup--li-em">might</em> be affected by the changing value.</li><li name="d845" id="d845" class="graf--li graf-after--li">After sending the <em class="markup--em markup--li-em">stale notification</em> and storing the new value, a <em class="markup--em markup--li-em">ready notification</em> will be sent. This message also indicates whether the value did actually change.</li><li name="0e46" id="0e46" class="graf--li graf-after--li">As soon as a derivation has received a ready notification for every stale notification received in step 1, it knows that all the observed values are stable and it will start to recompute. Counting the number of ready / stale messages will ensure that, for example, computed value &#x2018;4&#x2019; will only re-evaluate after computed value &#x2018;3&#x2019; has become stable.</li><li name="7404" id="7404" class="graf--li graf-after--li graf--last">If none of the ready messages indicate that a value was changed, the derivation will simply tell its own observers that it is ready again, but without changing its value. Otherwise the computation will recompute and send a ready message to its own observers. This results in the order of execution as displayed in figure 5. Note that (for example) the last reaction (marked with &#x2018;-&#x2019;) will never execute if computed value &#x2018;4&#x2019; did re-evaluate but didn&#x2019;t produce a new value.</li></ol></div></div></section><section name="5583" class=" section--body" score="41.25"><div class="section-content" score="32.5"><div class="section-inner layoutSingleColumn" score="1.25"><p name="d7f1" id="d7f1" class="graf--p graf--first">The previous two paragraph summarize how dependencies between observable values and derivations are tracked at run-time and how changes are propagated through the derivations. At this point you might also realize that a <em class="markup--em markup--p-em">reaction</em> is basically a <em class="markup--em markup--p-em">computed value</em> that is always in <em class="markup--em markup--p-em">reactive</em> mode. It is important to realize that this algorithm can be implemented very efficiently without closures and just with a bunch of pointer arrays. Additionally, Mobservable applies a number of optimizations which are beyond the scope of this blog post.</p><p name="fa3e" id="fa3e" class="graf--p graf-after--h4">People are often surprised that Mobservable runs everything synchronously (like RxJs and unlike knockout). This has two big advantages: First it becomes simply impossible to ever observe stale derivations. So a derived value can be used immediately after changing a value that influences it. Secondly it makes stack-traces and debugging easier as it avoids the useless stack-traces that are typical to Promise / async libraries.</p><figure name="7d75" id="7d75" class="graf--figure graf--iframe graf-after--p" score="-13.75"><figcaption class="imageCaption">Listing 2: Example transaction. It ensures that nobody is able to observe an intermediate value like &#x201C;Mich Weststrate&#x201D;. (See also listing 1)</figcaption></figure><p name="6b40" id="6b40" class="graf--p graf-after--figure graf--last">However, synchronous execution also introduces the need for transactions. If several mutations are applied in immediate succession, it is preferable to re-evaluate all derivations after all changes has been applied. Wrapping an action in a <em class="markup--em markup--p-em">transaction</em> block achieves this. Transactions simply postpone all <em class="markup--em markup--p-em">ready notifications</em> until the transaction block has completed. Note that transactions still run &amp; update everything synchronously.</p></div></div></section><section name="4001" class=" section--body" score="41.25"><div class="section-content" score="32.5"><div class="section-inner layoutSingleColumn" score="19.0"><p name="6261" id="6261" class="graf--p graf--first">That summarizes the most essential implementation details of Mobservable. We haven&#x2019;t covered everything yet, but it is good to know for example that you can compose computed values. By <em class="markup--em markup--p-em">composing reactive computations</em> it is even possible to automatically transform one graph of data into another graph of data and keep this derivation up to date with the minimum number of patches. This makes it easy to implement complex patterns like map-reduce, state tracking using immutable shared data, or sideways data loading. But more on that in a next blog post.</p><ol class="postList"><li name="653a" id="653a" class="graf--li graf-after--h3">The application state of complex applications can best be expressed using <em class="markup--em markup--li-em">graphs</em> to achieve referential consistency and stay close to the mental model of a problem domain.</li><li name="3b6e" id="3b6e" class="graf--li graf-after--li">One should not imperatively act on state changes by using manually defined subscriptions or cursors. This will inevitably lead to bugs as a result of under- or oversubscribing.</li><li name="1930" id="1930" class="graf--li graf-after--li">Use <em class="markup--em markup--li-em">runtime analysis</em> to determine the<em class="markup--em markup--li-em"> smallest possible set</em> of observer &#x2192; observable relationships. This leads to a computational model where it can be guaranteed that the minimum amount of derivations are run without ever observing a stale value.</li><li name="634e" id="634e" class="graf--li graf-after--li">Any derivation that is not needed to achieve an active side effect can be optimized away completely.</li></ol><p name="61a9" id="61a9" class="graf--p graf-after--li">For more info on Mobservable, just check out:</p><ol class="postList"><li name="57d4" id="57d4" class="graf--li graf-after--p">My <a href="https://www.youtube.com/watch?v=FEwLwiizlk0" class="markup--anchor markup--li-anchor" rel="nofollow">talk at Reactive2015</a></li><li name="00b1" id="00b1" class="graf--li graf-after--li">The <a href="http://mweststrate.github.io/mobservable/" class="markup--anchor markup--li-anchor" rel="nofollow">official website</a> or <a href="https://github.com/mweststrate/mobservable" class="markup--anchor markup--li-anchor" rel="nofollow">repo</a></li><li name="5837" id="5837" class="graf--li graf-after--li graf--last">A boilerplate project: <a href="https://github.com/mweststrate/mobservable-react-boilerplate" class="markup--anchor markup--li-anchor" rel="nofollow">React + Babel</a>, <a href="https://github.com/mweststrate/mobservable-react-typescript" class="markup--anchor markup--li-anchor" rel="nofollow">React + TypeScript</a>, <a href="https://github.com/mweststrate/todomvc/tree/master/examples/react-mobservable" class="markup--anchor markup--li-anchor" rel="nofollow">TodoMVC</a> or the <a href="https://github.com/staltz/flux-challenge/blob/master/submissions/mweststrate/index.tsx" class="markup--anchor markup--li-anchor" rel="nofollow">Flux-Challenge</a></li></ol></div></div></section><section name="4689" class=" section--body section--last" score="41.25"><div class="section-content" score="31.25"><div class="section-inner layoutSingleColumn"><p name="e5b7" id="e5b7" class="graf--p graf--first"><em class="markup--em markup--p-em">P.s. you might find some inconsistencies between the terminology used in this blog-post and the current Mobservable implementation and API. This will be fixed in Mobservable 2.0.</em></p><p name="04e6" id="04e6" class="graf--p graf-after--p graf--last">Image by <a href="https://www.flickr.com/photos/xt0ph3r/3591236086/in/photostream/" class="markup--anchor markup--p-anchor" rel="nofollow">xt0ph3r</a></p></div></div></section></div>
</body></html>
