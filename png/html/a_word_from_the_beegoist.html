<!DOCTYPE html><html><head><title>A Word from The Beegoist</title></head><body>
<h1>A Word from The Beegoist</h1><p><a href="https://medium.com/@richardeng/a-word-from-the-beegoist-d562ff8589d7" target="_new">Original URL</a></p>
<p><blockquote>You have some familiarity with the Go language. I highly recommend you follow this Go tutorial.You&#x2019;ve installed Go and Beego on your computer. There are plenty of good online resources to help&hellip;</blockquote></p>
<div><div class="section-inner layoutSingleColumn"><p name="93f1" class="graf--p"><a id="93f1"></a>You have some familiarity with the Go language. I highly recommend you follow this <a target="_blank" href="http://tour.golang.org/" class="markup--anchor markup--p-anchor" rel="nofollow">Go tutorial</a>.</p><p name="178e" class="graf--p"><a id="178e"></a>You&#x2019;ve installed <a target="_blank" href="http://golang.org/" class="markup--anchor markup--p-anchor" rel="nofollow">Go</a> and <a target="_blank" href="http://beego.me/" class="markup--anchor markup--p-anchor" rel="nofollow">Beego</a> on your computer. There are plenty of good online resources to help you here (for <a href="https://medium.com/@richardeng/in-the-beginning-61c7e63a3ea6" class="markup--anchor markup--p-anchor">example</a>). It&#x2019;s really quite easy.</p><p name="7d53" class="graf--p"><a id="7d53"></a>You have basic knowledge of CSS, HTML, and databases. You have at least one database package installed on your computer such as <a target="_blank" href="http://www.mysql.com/" class="markup--anchor markup--p-anchor" rel="nofollow">MySQL</a> (Community Edition) or <a target="_blank" href="http://www.sqlite.org/" class="markup--anchor markup--p-anchor" rel="nofollow">SQLite</a>. I have SQLite because it&#x2019;s much easier to use.</p><p name="a6b8" class="graf--p"><a id="a6b8"></a>You have some experience writing software; basic skills are assumed. If you studied computer programming in school, then you&#x2019;re off to a good start.</p><p name="5fdd" class="graf--p"><a id="5fdd"></a>You will be using your favourite programming editor in conjunction with the command line. I use <a target="_blank" href="https://code.google.com/p/liteide/" class="markup--anchor markup--p-anchor" rel="nofollow">LiteIDE</a> (on the Mac), but I can suggest alternatives such as <a target="_blank" href="http://macromates.com/" class="markup--anchor markup--p-anchor" rel="nofollow">TextMate</a> for the Mac, <a target="_blank" href="http://notepad-plus-plus.org/" class="markup--anchor markup--p-anchor" rel="nofollow">Notepad++</a> for Windows, and <a href="https://medium.com/@richardeng/back-to-the-future-9db24d6bcee1" class="markup--anchor markup--p-anchor">vim</a> for Linux.</p><p name="66aa" class="graf--p"><a id="66aa"></a>These basic assumptions define the target audience for the tutorial. If you&#x2019;re a programming veteran, though, you&#x2019;ll breeze through it and hopefully gain much useful knowledge, as well.</p><p name="ea35" class="graf--p"><a id="ea35"></a>First, we must create a Beego project. We&#x2019;ll call it &#x2018;<a target="_blank" href="http://en.wikipedia.org/wiki/Acme_Corporation" class="markup--anchor markup--p-anchor" rel="nofollow">ACME</a>&#x2019;. From the command line, change directory (cd) to $GOPATH/src and enter:</p><pre name="cc26" class="graf--pre"><a id="cc26"></a>$ bee new acme</pre><p name="3e73" class="graf--p"><a id="3e73"></a>The following directory structure will be created:</p><pre name="8179" class="graf--pre"><a id="8179"></a>acme<br>....conf<br>....controllers<br>....models<br>....routers<br>....static<br>........css<br>........img<br>........js<br>....tests<br>....views</pre><p name="4f2e" class="graf--p"><a id="4f2e"></a>Note that Beego is a MVC framework (Model/View/Controller), which means that your application will be separated into three general sections. <em class="markup--em markup--p-em">Model</em> refers to the internal database structure of your application. <em class="markup--em markup--p-em">View</em> is all about how your application looks on the computer screen; in our case, this includes HTML and CSS code. And <em class="markup--em markup--p-em">Controller</em> is where you have your business logic and user interactions.</p><p name="b0c0" class="graf--p"><a id="b0c0"></a>You can immediately compile and run your application by changing directory (cd acme) and typing:</p><pre name="c468" class="graf--pre"><a id="c468"></a>$ bee run</pre><p name="7d81" class="graf--p"><a id="7d81"></a>In your browser, go to <a href="http://localhost:8080" class="markup--anchor markup--p-anchor">http://localhost:8080</a> to see the running application. It doesn&#x2019;t do anything fancy right now; it simply greets you. But upon this foundation, we shall raise an impressive edifice.</p><p name="6128" class="graf--p"><a id="6128"></a>To follow along, you may <a target="_blank" href="https://github.com/horrido/acme" class="markup--anchor markup--p-anchor" rel="nofollow">download the source code</a> for this tutorial. Cd to $GOPATH/src and unzip the file. This will, however, replace the project you just created, since both use the same name (&#x2018;acme&#x2019;). I suggest you defer this step till later in the tutorial. Or rename your original project.</p><p name="7046" class="graf--p"><a id="7046"></a>The user account management component provides the following functionality:</p><p name="5299" class="graf--p"><a id="5299"></a>The essence of a web application is the mapping of URLs (webpages) to the server functions that will process the HTTP requests. This mapping is what generates the work flow in the application. In Beego, the mapping is defined within the &#x2018;router&#x2019;. Here&#x2019;s the code for our router (look at router.go in the &#x2018;routers&#x2019; directory):</p><pre name="998d" class="graf--pre"><a id="998d"></a>beego.Router("/home", &amp;controllers.MainController{})<br>beego.Router("/user/login/:back", &amp;controllers.MainController{}, "get,post:Login")<br>beego.Router("/user/logout", &amp;controllers.MainController{}, "get:Logout")<br>beego.Router("/user/register", &amp;controllers.MainController{}, "get,post:Register")<br>beego.Router("/user/profile", &amp;controllers.MainController{}, "get,post:Profile")<br>beego.Router("/user/verify/:uuid({[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}})", &amp;controllers.MainController{}, "get:Verify")<br>beego.Router("/user/remove", &amp;controllers.MainController{}, "get,post:Remove")<br>beego.Router("/notice", &amp;controllers.MainController{}, "get:Notice")</pre><p name="cc96" class="graf--p"><a id="cc96"></a>For example, in the line for &#x2018;login&#x2019;, &#x201C;get,post:Login&#x201D; says that both the GET and POST operations are handled by the &#x2018;Login&#x2019; function. The &#x2018;:back&#x2019; is a request parameter; in this case, it tells us what page to return to after successful login.</p><p name="3576" class="graf--p"><a id="3576"></a>In the line for &#x2018;verify&#x2019;, the &#x2018;:uuid&#x2019; is a request parameter that must match the <a target="_blank" href="http://en.wikipedia.org/wiki/Regular_expression" class="markup--anchor markup--p-anchor" rel="nofollow">regular expression</a> for a Version 4 UUID. The GET operation is handled by the &#x2018;Verify&#x2019; function.</p><p name="4240" class="graf--p"><a id="4240"></a>More on this when we talk about controllers.</p><p name="6f2c" class="graf--p"><a id="6f2c"></a>Note that I&#x2019;ve added &#x2018;/home&#x2019; to the first line in the router (it was originally &#x2018;/&#x2019;). This makes it convenient to go to the home page, which we often do in our application.</p><p name="165e" class="graf--p"><a id="165e"></a>The database model for a user account is represented by the following struct:</p><pre name="c1cd" class="graf--pre"><a id="c1cd"></a>package models</pre><pre name="82ab" class="graf--pre"><a id="82ab"></a>import (<br> "github.com/astaxie/beego/orm"<br> "time"<br>)</pre><pre name="438d" class="graf--pre"><a id="438d"></a>type AuthUser struct {<br> Id int<br> First string<br> Last string<br> Email string `orm:"unique"`<br> Password string<br> Reg_key string<br> Reg_date time.Time `orm:"auto_now_add;type(datetime)"`<br>}</pre><pre name="5516" class="graf--pre"><a id="5516"></a>func init() {<br> orm.RegisterModel(new(AuthUser))<br>}</pre><p name="be66" class="graf--p"><a id="be66"></a>Place this in models.go in the &#x2018;models&#x2019; directory. Ignore the init() for the time being.</p><p name="db33" class="graf--p graf--startsWithSingleQuote"><a id="db33"></a>&#x2018;Id&#x2019; is the primary key which is auto-incremented in the database. We also have &#x2018;First&#x2019; and &#x2018;Last&#x2019; names. &#x2018;Password&#x2019; contains the <em class="markup--em markup--p-em">binary data</em> for the <a target="_blank" href="http://en.wikipedia.org/wiki/PBKDF2" class="markup--anchor markup--p-anchor" rel="nofollow">PBKDF2 hash</a> of the <em class="markup--em markup--p-em">plaintext</em> password; the &#x2018;string&#x2019; type is the most convenient way to store the value in the database.</p><p name="db75" class="graf--p graf--startsWithSingleQuote"><a id="db75"></a>&#x2018;Reg_key&#x2019; contains the <a target="_blank" href="http://en.wikipedia.org/wiki/Universally_unique_identifier" class="markup--anchor markup--p-anchor" rel="nofollow">UUID</a> string that is used for account verification (via email). &#x2018;Reg_date&#x2019; is the timestamp indicating the time of registration.</p><p name="811f" class="graf--p"><a id="811f"></a>The funny-looking string literals associated with both &#x2018;Email&#x2019; and &#x2018;Reg_date&#x2019; are used to tell the database the special requirements of these fields. &#x2018;Email&#x2019; must be a unique key. &#x2018;Reg_date&#x2019; will be automatically assigned the date and time of database insertion.</p><p name="018c" class="graf--p"><a id="018c"></a>By the way, don&#x2019;t be scared of the PBKDF2 and UUID references. PBKDF2 is simply a way to securely store a user&#x2019;s password in the database. A UUID is a unique identifier that can be used to ensure the identity of the user for verification purposes.</p><p name="adea" class="graf--p"><a id="adea"></a>For our CSS template design, I&#x2019;ve chosen the <a target="_blank" href="http://www.freewebtemplates.com/download/free-website-template/stardust-141989295/" class="markup--anchor markup--p-anchor" rel="nofollow">Stardust</a> theme (pictured at the start of this article). We will use its index.html as a basis for the view layout.</p><p name="58c0" class="graf--p"><a id="58c0"></a>Place the appropriate files from the Stardust theme into the &#x2018;css&#x2019; and &#x2018;img&#x2019; directories of &#x2018;static&#x2019; directory. The link statement in the header of index.html must be amended to:</p><pre name="2a55" class="graf--pre"><a id="2a55"></a>&lt;link href="/static/css/default.css" rel="stylesheet" type="text/css" /&gt;</pre><p name="1e05" class="graf--p"><a id="1e05"></a>And all references to image gifs and jpegs in index.html and default.css must point to &#x2018;/static/img/&#x2019;.</p><p name="f8e9" class="graf--p"><a id="f8e9"></a>The view layout contains a header section, a footer section, a sidebar section, and the central section where most of the action will take place. We will be using Go&#x2019;s templating facility which allows us to replace embedded codes, signified by &#x2018;{{&#x2018; and &#x2018;}}&#x2019;, with actual HTML. Here&#x2019;s our basic-layout.tpl (.tpl for &#x2018;template&#x2019;):</p><pre name="b5b3" class="graf--pre"><a id="b5b3"></a>{{.Header}}<br>{{.LayoutContent}}<br>{{.Sidebar}}<br>{{.Footer}}</pre><p name="a91e" class="graf--p"><a id="a91e"></a>Since every webpage in our application will need to adhere to this basic layout, we need a common method to set it up (look at default.go):</p><pre name="1a02" class="graf--pre"><a id="1a02"></a>func (this *MainController) activeContent(view string) {<br> this.Layout = "basic-layout.tpl"<br> this.LayoutSections = make(map[string]string)<br> this.LayoutSections["Header"] = "header.tpl"<br> this.LayoutSections["Sidebar"] = "sidebar.tpl"<br> this.LayoutSections["Footer"] = "footer.tpl"<br> this.TplNames = view + ".tpl"</pre><pre name="a399" class="graf--pre"><a id="a399"></a> sess := this.GetSession("acme")<br> if sess != nil {<br> this.Data["InSession"] = 1 // for login bar in header.tpl<br> m := sess.(map[string]interface{})<br> this.Data["First"] = m["first"]<br> }<br>}</pre><p name="6cb5" class="graf--p"><a id="6cb5"></a>The template parameters, such as &#x2018;.Sidebar&#x2019;, correspond to the keys used in the LayoutSections map. &#x2018;.LayoutContent&#x2019; is a special, implicit template parameter. We&#x2019;ll get to the GetSession stuff further below.</p><p name="08c8" class="graf--p"><a id="08c8"></a>Of course, we need to create the various template files (such as footer.tpl) in the &#x2018;views&#x2019; directory. From index.html, we can carve out the header section for header.tpl:</p><pre name="1abe" class="graf--pre"><a id="1abe"></a>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;meta http-equiv="content-type" content="text/html; charset=utf-8" /&gt;<br>&lt;title&gt;StarDust by Free Css Templates&lt;/title&gt;<br>&lt;meta name="keywords" content="" /&gt;<br>&lt;meta name="description" content="" /&gt;<br>&lt;link href="/static/css/default.css" rel="stylesheet" type="text/css" /&gt;<br>&lt;/head&gt;</pre><pre name="f7b6" class="graf--pre"><a id="f7b6"></a>&lt;body&gt;<br>&lt;!-- start header --&gt;<br>&lt;div id="header-bg"&gt;<br> &lt;div id="header"&gt;<br><strong class="markup--strong markup--pre-strong"> &lt;div align="right"&gt;{{if .InSession}}<br> Welcome, {{.First}} [&lt;a href="http://localhost:8080/logout"&gt;Logout&lt;/a&gt;|&lt;a href="http://localhost:8080/profile"&gt;Profile&lt;/a&gt;]<br> {{else}}<br> [&lt;a href="http://localhost:8080/login/home"&gt;Login&lt;/a&gt;]<br> {{end}}<br> &lt;/div&gt;</strong><br> &lt;div id="logo"&gt;<br> &lt;h1&gt;&lt;a href="#"&gt;StarDust&lt;sup&gt;&lt;/sup&gt;&lt;/a&gt;&lt;/h1&gt;<br> &lt;h2&gt;Designed by FreeCSSTemplates&lt;/h2&gt;<br> &lt;/div&gt;<br> &lt;div id="menu"&gt;<br> &lt;ul&gt;<br> &lt;li class="active"&gt;&lt;a href="http://localhost:8080/home"&gt;home&lt;/a&gt;&lt;/li&gt;<br> &lt;li&gt;&lt;a href="#"&gt;photos&lt;/a&gt;&lt;/li&gt;<br> &lt;li&gt;&lt;a href="#"&gt;about&lt;/a&gt;&lt;/li&gt;<br> &lt;li&gt;&lt;a href="#"&gt;links&lt;/a&gt;&lt;/li&gt;<br> &lt;li&gt;&lt;a href="#"&gt;contact &lt;/a&gt;&lt;/li&gt;<br> &lt;/ul&gt;<br> &lt;/div&gt;<br> &lt;/div&gt;<br>&lt;/div&gt;<br>&lt;!-- end header --&gt;<br>&lt;!-- start page --&gt;<br>&lt;div id="page"&gt;</pre><p name="f930" class="graf--p"><a id="f930"></a>I leave it as an exercise for you to carve out the sections for sidebar.tpl and footer.tpl.</p><p name="8127" class="graf--p"><a id="8127"></a>Note the lines in bold. I added them to facilitate a &#x201C;login bar&#x201D; at the top of every webpage. Once you&#x2019;ve logged into the application, you will see the bar as so:</p><figure name="ec41" class="graf--figure"><a id="ec41"></a><div class="aspectRatioPlaceholder is-locked"><img class="graf-image" src="https://d262ilb51hltx0.cloudfront.net/max/800/1*1OpYy1ISYGUaBy0U_RJ75w.png"></div></figure><p name="012b" class="graf--p"><a id="012b"></a>This login bar works in conjunction with the GetSession code snippet we saw in activeContent(). The logic is, if the user is logged in (ie, there is a non-nil session), then we set the InSession parameter to a value (any value), which tells the templating engine to use the &#x201C;Welcome&#x201D; bar instead of &#x201C;Login&#x201D;. We also extract the user&#x2019;s first name from the session so that we can present the friendly affectation &#x201C;Welcome, Richard&#x201D;.</p><p name="8436" class="graf--p"><a id="8436"></a>The home page, represented by index.tpl, uses the following snippet from index.html:</p><pre name="a737" class="graf--pre"><a id="a737"></a> &lt;!-- start content --&gt;<br> &lt;div id="content"&gt;<br> &lt;div class="post"&gt;<br> &lt;h1 class="title"&gt;Welcome to StarDust&lt;/h1&gt;<br> // to save space, I won't enter the remainder<br> // of the snippet<br> &lt;/div&gt;<br> &lt;!-- end content --&gt;</pre><p name="b132" class="graf--p"><a id="b132"></a>The template files for the user module reside in the &#x2018;user&#x2019; directory within &#x2018;view&#x2019;, just to keep things tidy. So, for example, the call to activeContent() for login is:</p><pre name="9fa8" class="graf--pre"><a id="9fa8"></a>this.activeContent("user/login")</pre><p name="f2a0" class="graf--p"><a id="f2a0"></a>A controller handles requests by handing them off to the appropriate function or &#x2018;method&#x2019;. We only have one controller for our application and it&#x2019;s defined in default.go. The default method Get() for handling a GET operation is associated with our home page:</p><pre name="a730" class="graf--pre"><a id="a730"></a>func (this *MainController) Get() {<br> this.activeContent("index")</pre><pre name="9612" class="graf--pre"><a id="9612"></a> //bin //boot //cdrom //dev //etc //home //initrd.img //initrd.img.old //lacie //lib //lib64 //lost+found //media //mnt //nfs //opt //proc //render //root //run //sbin //share //srv //sys //tmp //usr //var //vmlinuz //vmlinuz.old This page requires login<br> sess := this.GetSession("acme")<br> if sess == nil {<br> this.Redirect("/user/login/home", 302)<br> return<br> }<br> m := sess.(map[string]interface{})<br> fmt.Println("username is", m["username"])<br> fmt.Println("logged in at", m["timestamp"])<br>}</pre><p name="70c3" class="graf--p"><a id="70c3"></a>I&#x2019;ve made login a requirement for accessing this page. Logging in means creating a session, which by default expires after 3600 seconds of inactivity. A session is typically maintained on the client side by a &#x2018;cookie&#x2019;.</p><p name="62e3" class="graf--p"><a id="62e3"></a>In order to support sessions in the application, the &#x2018;SessionOn&#x2019; flag must be set to true. There are two ways to do this:</p><ol class="postList"><li name="dd0b" class="graf--li"><a id="dd0b"></a>Insert &#x2018;beego.SessionOn = true&#x2019; in the main program, main.go.</li><li name="37e9" class="graf--li"><a id="37e9"></a>Insert &#x2018;sessionon = true&#x2019; in the configuration file, app.conf, which can be found in the &#x2018;conf&#x2019; directory.</li></ol><p name="6058" class="graf--p"><a id="6058"></a>I chose #1. (But note that I used the configuration file to set &#x2018;EnableAdmin&#x2019; to true: &#x2018;enableadmin = true&#x2019;. EnableAdmin allows you to use the Supervisor Module in Beego that keeps track of CPU, memory, Garbage Collector, threads, etc., via port 8088: <a href="http://localhost:8088" class="markup--anchor markup--p-anchor">http://localhost:8088</a>.)</p><p name="8b95" class="graf--p"><a id="8b95"></a>The main program is also where we initialize the database to be used with the ORM (Object Relational Mapping) component. ORM makes it more convenient to perform database activities within our application. The main program&#x2019;s init():</p><pre name="3684" class="graf--pre"><a id="3684"></a>func init() {<br> orm.RegisterDriver("sqlite", orm.DR_Sqlite)<br> orm.RegisterDataBase("default", "sqlite3", "acme.db")<br> name := "default"<br> force := false<br> verbose := false<br> err := orm.RunSyncdb(name, force, verbose)<br> if err != nil {<br> fmt.Println(err)<br> }<br>}</pre><p name="1498" class="graf--p"><a id="1498"></a>To use SQLite, we must import &#x2018;go-sqlite3', which can be installed with the command:</p><pre name="5937" class="graf--pre"><a id="5937"></a>$ go get github.com/mattn/go-sqlite3</pre><p name="2d0f" class="graf--p"><a id="2d0f"></a>As you can see in the code snippet, the SQLite driver must be registered and &#x2018;acme.db&#x2019; must be registered as our SQLite database.</p><p name="d123" class="graf--p"><a id="d123"></a>Recall in models.go, there was an init() function:</p><pre name="a062" class="graf--pre"><a id="a062"></a>func init() {<br> orm.RegisterModel(new(AuthUser))<br>}</pre><p name="e748" class="graf--p"><a id="e748"></a>The database model has to be registered so that the appropriate table can be generated. To ensure that this init() function is executed, you must import &#x2018;models&#x2019; without actually using it within the main program, as follows:</p><pre name="2e80" class="graf--pre"><a id="2e80"></a>import _ "acme/models"</pre><p name="d13a" class="graf--p"><a id="d13a"></a>RunSyncdb() is used to autogenerate the tables when you start the program. (This is very handy for creating the database tables without having to <strong class="markup--strong markup--p-strong">manually</strong> do it in the database command line utility.) If you set &#x2018;force&#x2019; to true, it will drop any existing tables and recreate them.</p><p name="d496" class="graf--p"><a id="d496"></a>User.go contains all the methods for handling login, registration, profile, etc. There are several third-party packages we need to import; they provide support for email, PBKDF2, and UUID. But first we must get them into our project&#x2026;</p><pre name="c573" class="graf--pre"><a id="c573"></a>$ go get github.com/alexcesaro/mail/gomail<br>$ go get github.com/twinj/uuid</pre><p name="5f69" class="graf--p"><a id="5f69"></a>I originally got <strong class="markup--strong markup--p-strong">github.com/gokyle/pbkdf2</strong>, but this package was pulled from Github, so you can no longer get it. I&#x2019;ve incorporated this package into my source under the &#x2018;utilities&#x2019; folder, and the import is:</p><pre name="eb9f" class="graf--pre"><a id="eb9f"></a>import pk "acme/utilities/pbkdf2"</pre><p name="67b6" class="graf--p"><a id="67b6"></a>The &#x2018;pk&#x2019; is a convenient alias so that I don&#x2019;t have to type the rather unwieldy &#x2018;pbkdf2'.</p><p name="1336" class="graf--p"><a id="1336"></a>It&#x2019;s pretty straightforward to use ORM. The basic pattern is to create an ORM object, specify the &#x2018;default&#x2019; database, and select which ORM operation you want, eg,</p><pre name="f2b3" class="graf--pre"><a id="f2b3"></a>o := orm.NewOrm()<br>o.Using("default")<br>err := o.Insert(&amp;user) // or<br>err := o.Read(&amp;user, "Email") // or<br>err := o.Update(&amp;user) // or<br>err := o.Delete(&amp;user)</pre><p name="0655" class="graf--p"><a id="0655"></a>Note, however, that there is currently a bug where Insert() cannot accept &#x2018;&amp;user&#x2019;. To insert a record, then, you must pass &#x2018;user&#x2019; by value, not by reference:</p><pre name="6a9b" class="graf--pre"><a id="6a9b"></a>err := o.Insert(user)</pre><p name="d210" class="graf--p"><a id="d210"></a>Plaintext passwords should never be stored on the server. We use the PBKDF2 package to convert a password into a &#x2018;<a target="_blank" href="http://en.wikipedia.org/wiki/Cryptographic_hash_function" class="markup--anchor markup--p-anchor" rel="nofollow">hash</a>&#x2019; value to ensure security. The hash structure consists of two parts: 1) a 32-byte <em class="markup--em markup--p-em">hash</em>; and 2) a 16-byte <em class="markup--em markup--p-em">salt</em>, which is used to compute the hash.</p><p name="7831" class="graf--p"><a id="7831"></a>Comparing passwords, then, will be a matter of comparing their hash values. This is why password recovery is usually impossible at most websites; they&#x2019;ll ask you to reset your password in the event you forgot your old password.</p><p name="86a9" class="graf--p"><a id="86a9"></a>Storing large binary values (larger than, say, 64 bits) to a database is problematic. To save the password hash, which is a 48-byte value, we must first convert it to a string type&#xAA;. We use the &#x2018;bytes&#x2019; and &#x2018;binary&#x2019; packages for this. The idea is to &#x201C;write&#x201D; out the binary values for the Hash and Salt members of the <em class="markup--em markup--p-em">HashPassword</em> struct into a byte buffer, and then convert the buffer to a string type. It&#x2019;s a neat trick that takes advantage of the fact that Go strings can hold 8 bits (or one full byte) of a character, even the null character.</p><p name="aa2b" class="graf--p"><a id="aa2b"></a>[&#xAA; It&#x2019;s possible to convert the hash to a <em class="markup--em markup--p-em">textual</em> representation (ie, a string), but that would take up a lot more space and involve more complicated conversions.]</p><pre name="8eca" class="graf--pre"><a id="8eca"></a>buf := new(bytes.Buffer)<br>err := binary.Write(buf, binary.LittleEndian, h.Hash)<br>if err != nil {<br> flash.Error("Internal error")<br> flash.Store(&amp;this.Controller)<br> return<br>}<br>err = binary.Write(buf, binary.LittleEndian, h.Salt)<br>if err != nil {<br> flash.Error("Internal error")<br> flash.Store(&amp;this.Controller)<br> return<br>}<br>b := buf.Bytes()<br>fmt.Printf("password hash/salt is: %x\n", b)<br>user.Password = string(b)</pre><p name="7f76" class="graf--p"><a id="7f76"></a>Similarly, to &#x201C;read&#x201D; in the binary values for Hash and Salt from the byte buffer:</p><pre name="9f60" class="graf--pre"><a id="9f60"></a>var y hStruct</pre><pre name="3888" class="graf--pre"><a id="3888"></a>ibuf := bytes.NewReader([]byte(user.Password))<br>err = binary.Read(ibuf, binary.LittleEndian, &amp;y.Hash)<br>if err != nil {<br> flash.Error("Internal error")<br> flash.Store(&amp;this.Controller)<br> return<br>}<br>err = binary.Read(ibuf, binary.LittleEndian, &amp;y.Salt)<br>if err != nil {<br> flash.Error("Internal error")<br> flash.Store(&amp;this.Controller)<br> return<br>}</pre><p name="fbca" class="graf--p graf--startsWithSingleQuote"><a id="fbca"></a>&#x2018;hStruct&#x2019; is a struct type with Hash and Salt as byte array members. This tells binary.Read how much data to &#x201C;read&#x201D;.</p><p name="1905" class="graf--p"><a id="1905"></a>By the way, Beego provides a way to present notifications on your webpage through the use of &#x2018;flash&#x2019;. Basically, you create a &#x2018;flash&#x2019; object, give it your notification message, store the flash in the controller, and then retrieve the message in the template file, eg,</p><pre name="216d" class="graf--pre"><a id="216d"></a>flash := beego.NewFlash()<br>flash.Error("You've goofed!") // or<br>flash.Notice("Well done!")<br>flash.Store(&amp;this.Controller)</pre><p name="7ebf" class="graf--p"><a id="7ebf"></a>And in your template file, reference the Error flash with:</p><pre name="d521" class="graf--pre"><a id="d521"></a>{{if .flash.error}}<br>&lt;h3&gt;{{.flash.error}}&lt;/h3&gt;<br>&amp;nbsp;<br>{{end}}</pre><p name="2b11" class="graf--p"><a id="2b11"></a>Once the user posts a request (by pressing the Submit button, for example), our handler must extract and validate the form input. So, first, check that we have a POST operation:</p><pre name="a1c5" class="graf--pre"><a id="a1c5"></a>if this.Ctx.Input.Method() == "POST" {</pre><p name="e63b" class="graf--p"><a id="e63b"></a>Let&#x2019;s get a form element, say, email:</p><pre name="8ca0" class="graf--pre"><a id="8ca0"></a>email := this.GetString("email")</pre><p name="a008" class="graf--p"><a id="a008"></a>The string &#x201C;email&#x201D; is the same as in the HTML form:</p><pre name="c9ca" class="graf--pre"><a id="c9ca"></a>&lt;input name="email" type="text" /&gt;</pre><p name="fe3b" class="graf--p"><a id="fe3b"></a>To validate it, we create a validation object, specify the type of validation, and then check to see if there are any errors:</p><pre name="501b" class="graf--pre"><a id="501b"></a>valid := validation.Validation{}<br>valid.Email(email, "email") // must be a proper email address<br>if valid.HasErrors() {<br> for _, err := range valid.Errors {</pre><p name="f332" class="graf--p"><a id="f332"></a>What you do with the errors is up to you. I like to present all of them at once to the user, so as I go through the range of valid.Errors, I add them to a map of errors that will eventually be used in the template file. Hence, the full snippet:</p><pre name="6938" class="graf--pre"><a id="6938"></a>if this.Ctx.Input.Method() == "POST" {<br> email := this.GetString("email")<br> password := this.GetString("password")<br> valid := validation.Validation{}<br> valid.Email(email, "email")<br> valid.Required(password, "password")<br> if valid.HasErrors() {<br> errormap := []string{}<br> for _, err := range valid.Errors {<br> errormap = append(errormap, "Validation failed on "+err.Key+": "+err.Message+"\n")<br> }<br> this.Data["Errors"] = errormap<br> return<br> }</pre><p name="1ece" class="graf--p"><a id="1ece"></a>We&#x2019;ve looked at the major pieces of the controller. Now, we get to the meat of the application, the user management methods:</p><p name="d2de" class="graf--p"><a id="d2de"></a>Recall that we saw references to these functions in the router. The router associates each URL (and HTTP request) with the corresponding controller method.</p><p name="002e" class="graf--p"><a id="002e"></a>Let&#x2019;s look at the pseudocode for this method:</p><pre name="bffe" class="graf--pre"><a id="bffe"></a>if the HTTP request is "POST" then<br> Validate the form (extract the email address and password).<br> Read the password hash from the database, keying on email.<br> - this requires binary.Read()<br> Compare the submitted password with the one on record.<br> Create a session for this user.<br>endif</pre><p name="af5f" class="graf--p"><a id="af5f"></a>In order to compare passwords, we need to give pk.MatchPassword() a variable with members &#x2018;Hash&#x2019; and &#x2018;Salt&#x2019; that are <strong class="markup--strong markup--p-strong">byte slices</strong>. Hence,</p><pre name="e68e" class="graf--pre"><a id="e68e"></a>var x pk.PasswordHash</pre><pre name="d585" class="graf--pre"><a id="d585"></a>x.Hash = make([]byte, 32) // create a slice<br>copy(x.Hash, y.Hash[:32]) // copy array value from database<br>x.Salt = make([]byte, 16)<br>copy(x.Salt, y.Salt[:16])<br>if !pk.MatchPassword(password, &amp;x) {<br> flash.Error("Bad password")<br> flash.Store(&amp;this.Controller)<br> return<br>}</pre><p name="f3f9" class="graf--p"><a id="f3f9"></a>Creating a session is trivial, but we want to store some useful information in the session, as well. So we make a map and store first name, email address, and the time of login:</p><pre name="724f" class="graf--pre"><a id="724f"></a>m := make(map[string]interface{})<br>m["first"] = user.First<br>m["username"] = email<br>m["timestamp"] = time.Now()<br>this.SetSession("acme", m)<br>this.Redirect("/"+back, 302) // go to previous page after login</pre><p name="4734" class="graf--p"><a id="4734"></a>Incidentally, the name &#x201C;acme&#x201D; passed to SetSession is completely arbitrary; you just need to reference the same name to get the same session.</p><p name="31d4" class="graf--p"><a id="31d4"></a>This one is trivially easy. We delete the session and redirect to the home page.</p><pre name="e3ef" class="graf--pre"><a id="e3ef"></a>if the HTTP request is "POST" then<br> Validate the form.<br> Create the password hash for the submitted password.<br> Prepare new user record.<br> Convert the password hash to string type.<br> - this requires binary.Write()<br> Generate a UUID and insert the user into database.<br> Send a verification email.<br> Flash a message on the notification page.<br>endif</pre><p name="b4ec" class="graf--p"><a id="b4ec"></a>To send a verification email to the user, we use <strong class="markup--strong markup--p-strong">gomail</strong>&#x2026;</p><pre name="44a5" class="graf--pre"><a id="44a5"></a>link := "http://localhost:8080/user/verify/" + u // u is UUID<br>host := "smtp.gmail.com"<br>port := 587<br>msg := gomail.NewMessage()<br>msg.SetAddressHeader("From", "acmecorp@gmail.com", "ACME Corporation")<br>msg.SetHeader("To", email)<br>msg.SetHeader("Subject", "Account Verification for ACME Corporation")<br>msg.SetBody("text/html", "To verify your account, please click on the link: &lt;a href=\""+link+"\"&gt;"+link+"&lt;/a&gt;&lt;br&gt;&lt;br&gt;Best Regards,&lt;br&gt;ACME Corporation")<br>m := gomail.NewMailer(host, "youraccount@gmail.com", "YourPassword", port)<br>if err := m.Send(msg); err != nil {<br> return false<br>}</pre><p name="7fa7" class="graf--p"><a id="7fa7"></a>I chose Gmail as my email relay (you will need to open your own account). Note that Gmail ignores the &#x201C;From&#x201D; address (in our case, &#x201C;acmecorp@gmail.com&#x201D;) because Gmail does not permit you to alter the sender address in order to prevent phishing.</p><p name="2771" class="graf--p"><a id="2771"></a>This special router method is for displaying a flash message on a notification page. It&#x2019;s not really a user module function; it&#x2019;s general enough that you can use it in many other places.</p><p name="34ff" class="graf--p"><a id="34ff"></a>We&#x2019;ve already discussed all the pieces in this function. The pseudocode is:</p><pre name="5f7e" class="graf--pre"><a id="5f7e"></a>Login required; check for a session.<br>Get user record from database, keyed on email (or username).<br>if the HTTP request is "POST" then<br> Validate the form.<br> if there is a new password then<br> Validate the new password.<br> Create the password hash for the new password.<br> Convert the password hash to string type.<br> endif<br> Compare submitted current password with the one on record.<br> Update the user record.<br> - update the username stored in session<br>endif</pre><p name="8b6d" class="graf--p"><a id="8b6d"></a>The verification email contains a link which, when clicked by the recipient, causes Verify() to process the UUID. Verify() attempts to read the user record, keyed on the UUID or registration key, and if it&#x2019;s found, then the registration key is removed from the database.</p><p name="7590" class="graf--p"><a id="7590"></a>Remove() is pretty much like Login(), except that instead of creating a session, you delete the user record from the database.</p><p name="e2a4" class="graf--p"><a id="e2a4"></a>I left out one user management method: What if the user has forgotten his password? We should provide a way to reset the password. I leave this as an exercise for you. All the pieces you need are in this tutorial. (Hint: You&#x2019;ll need to do it in a way similar to Registration verification. You should add a new Reset_key to the AuthUser table. And make sure the user email address exists in the database before you send the Reset email!)</p><p name="344e" class="graf--p"><a id="344e"></a>[Okay, so I&#x2019;ll give you the <a target="_blank" href="https://github.com/horrido/acme-exercise" class="markup--anchor markup--p-anchor" rel="nofollow">exercise solution</a>. I&#x2019;m not cruel.]</p><p name="f1b9" class="graf--p"><a id="f1b9"></a>Let&#x2019;s review what we&#x2019;ve learned. We covered the mapping of URLs to request handlers in the router. We showed how to incorporate a CSS template design into our views. We discussed the ORM package, as well as the <em class="markup--em markup--p-em">bytes</em> and <em class="markup--em markup--p-em">binary</em> packages, and how they&#x2019;re used to perform database operations. We examined a number of third-party utilities useful in writing our application. The end result is a component useful in many scenarios.</p><p name="244a" class="graf--p graf--last"><a id="244a"></a>This is a great deal of material in a tutorial, but I believe it&#x2019;s the best way to get started in writing a <em class="markup--em markup--p-em">practical</em> application.</p></div></div>
</body></html>
