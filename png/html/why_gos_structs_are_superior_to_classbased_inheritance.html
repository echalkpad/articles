<!DOCTYPE html><html><head><title>Why Go’s structs are superior to class-based inheritance</title></head><body>
<h1>Why Go’s structs are superior to class-based inheritance</h1><p><a href="https://medium.com/@simplyianm/why-gos-structs-are-superior-to-class-based-inheritance-b661ba897c67" target="_new">Original URL</a></p>
<p><blockquote>Go is unique from a lot of object-oriented languages in that it doesn’t have classes. Instead, Go has two awesome features that make its model of polymorphism way more powerful than classical&hellip;</blockquote></p>
<section name="1321" class=" section--body section--first section--last" score="41.25"><div class="section-content" score="31.25"><div class="section-inner layoutSingleColumn"><p name="266f" id="266f" class="graf--p graf-after--h3">Go is unique from a lot of object-oriented languages in that it doesn’t have classes. Instead, Go has two awesome features that make its model of polymorphism way more powerful than classical inheritance: interfaces and struct embedding.</p><p name="6067" id="6067" class="graf--p graf-after--h4">Interfaces in Go are very different from, say, Java interfaces. You don’t explicitly say a data type implements an interface; rather, your data types must implement all of the methods that the interface defines, and the compiler checks to see if assignments to variables of the interface type are valid.</p><p name="9a55" id="9a55" class="graf--p graf-after--p">For example, let’s define an Animal interface as so:</p><pre name="aa52" id="aa52" class="graf--pre graf-after--p">type Animal interface {<br> Name() string<br>}</pre><p name="48c8" id="48c8" class="graf--p graf-after--pre">The following type satisfies the Animal interface since it has all the methods Animal implements:</p><pre name="84f1" id="84f1" class="graf--pre graf-after--p">type Dog struct {}</pre><pre name="0d6e" id="0d6e" class="graf--pre graf-after--pre">func (d *Dog) Name() string {<br> return “Dog”<br>}</pre><pre name="2995" id="2995" class="graf--pre graf-after--pre">func (d *Dog) Bark() {<br> fmt.Println(“Woof!”)<br>}</pre><p name="2cea" id="2cea" class="graf--p graf-after--pre">Thus, the following code is valid:</p><pre name="6588" id="6588" class="graf--pre graf-after--p">func main() {<br> var animal Animal<br> animal = &amp;Dog{} // returns a pointer to a new Dog<br> fmt.Println(animal.Name()) // Dog<br>}</pre><p name="4327" id="4327" class="graf--p graf-after--pre">However, the following does not work:</p><pre name="84cf" id="84cf" class="graf--pre graf-after--p">func main() {<br> var animal Animal<br> animal = Dog{} // compile error!<br>}</pre><p name="21b2" id="21b2" class="graf--p graf-after--pre">since `*Dog`, not `Dog`, satisfies the interface.</p><p name="0ecd" id="0ecd" class="graf--p graf-after--p">You can also compose interfaces like this:</p><pre name="3330" id="3330" class="graf--pre graf-after--p">type PartyAnimal interface {<br> Animal<br> Party()<br>}</pre><p name="3a9b" id="3a9b" class="graf--p graf-after--pre">This defines an interface `PartyAnimal` which must satisfy all methods of Animal on top of satisfying `Party()`, thus the following is equivalent:</p><pre name="fe2e" id="fe2e" class="graf--pre graf-after--p">type PartyAnimal interface {<br> Name() string<br> Party()<br>}</pre><p name="ee3f" id="ee3f" class="graf--p graf-after--h4">Let’s say we want to create a type that does everything a Dog does, but more. Let’s call it a GuideDog, and give it a method `Help(h *Human)`. We can do that like so:</p><pre name="0f16" id="0f16" class="graf--pre graf-after--p">type GuideDog struct {<br> *Dog<br>}</pre><pre name="60db" id="60db" class="graf--pre graf-after--pre">func (gd *GuideDog) Help(h *Human) {<br> fmt.Printf(“Hey human, grab %s’s leash!\n”, gd.Name())<br>}</pre><pre name="5609" id="5609" class="graf--pre graf-after--pre">func main() {<br> gd := &amp;GuideDog{}<br> gd.Help(nil) // prints “Hey human, grab Dog’s leash!”<br>}</pre><p name="ea82" id="ea82" class="graf--p graf-after--pre">This calls the `Name` method on the embedded `*Dog` to do this.</p><p name="2a28" id="2a28" class="graf--p graf-after--p">Side note: even though we didn’t initialize the `*Dog`, we won’t get a null pointer exception here. This is because `*Dog#name` doesn’t access any struct attributes. Nifty, huh?</p><p name="cf29" id="cf29" class="graf--p graf-after--p">Now what if we do something like this:</p><pre name="612e" id="612e" class="graf--pre graf-after--p">type Cat struct {}</pre><pre name="d440" id="d440" class="graf--pre graf-after--pre">func (c *Cat) Name() string {<br> return “Cat”<br>}</pre><pre name="a18c" id="a18c" class="graf--pre graf-after--pre">type CatDog struct {<br> *Cat<br> *Dog<br>}</pre><pre name="81ba" id="81ba" class="graf--pre graf-after--pre">func main() {<br> cd := &amp;CatDog{}<br> fmt.Printf(“My favorite animal is the %s!\n”, cd.Name())<br>}</pre><p name="141b" id="141b" class="graf--p graf-after--pre">This doesn’t compile! `cd.Name()` is an ambiguous call. To fix this, we must add this method:</p><pre name="2e7e" id="2e7e" class="graf--pre graf-after--p">func (cd *CatDog) Name() string {<br> return fmt.Sprintf(“%s%s”, cd.Cat.Name(), cd.Dog.Name())<br>}</pre><p name="77dc" id="77dc" class="graf--p graf-after--pre">Now the program will print the following message:</p><pre name="218e" id="218e" class="graf--pre graf-after--p">My favorite animal is the CatDog!</pre><p name="3d05" id="3d05" class="graf--p graf-after--pre">This seems kind of tricky, but in the following sections I’ll cover why this is so awesome.</p><p name="f772" id="f772" class="graf--p graf-after--h4">Go polymorphism involves creating many different data types that satisfy a common interface. This is different from Java in that Java polymorphism also allows satisfying a common base class, which can lead to many problems.</p><p name="f52d" id="f52d" class="graf--p graf-after--h4">Wikipedia defines the fragile base class problem as the following:</p><blockquote name="7728" id="7728" class="graf--blockquote graf-after--p">The fragile base class problem is a fundamental architectural problem of object-oriented programming systems where base classes (superclasses) are considered “fragile” because seemingly safe modifications to a base class, when inherited by the derived classes, may cause the derived classes to malfunction. The programmer cannot determine whether a base class change is safe simply by examining in isolation the methods of the base class.</blockquote><p name="1ed2" id="1ed2" class="graf--p graf-after--blockquote">Basically, classes are the tightest form of coupling in object-oriented programming, and this is a bad thing. Changing a base class can cause unwanted side effects all over a code base.</p><p name="8d84" id="8d84" class="graf--p graf-after--p">For example, let’s say I am building a game called MyCraft and I need to create some items, which are all derived from the Item base class. Let’s say a lot of these items are Blocks, which are derived from Item. I create two blocks, a Sponge and a Brick. But what if Brick requires a change from the Item class, e.g. it needs to handle different burn behavior, and I cannot isolate the change to the Brick class? I make my change to Item and everything but Brick breaks. These kinds of mistakes are common in class-based inheritance.</p><p name="a057" id="a057" class="graf--p graf-after--p">You need to inherit all behavior from base classes in a class based inheritance model, but often times you don’t want everything.</p><p name="96b8" id="96b8" class="graf--p graf-after--h4">There is a famous statement in object oriented programming to <a href="https://en.wikipedia.org/wiki/Composition_over_inheritance" class="markup--anchor markup--p-anchor" rel="nofollow">favor composition over inheritance</a>. Making complex, multi-tiered class inheritance structures is a bad idea in general, as it makes your code more resistance to change.</p><p name="2b22" id="2b22" class="graf--p graf-after--p">With composition, you can pick different features rather than classes. You can compose your Brick of Block and Unburnable rather than making changes to a rigid class hierarchy. Class inheritance forces you to use an existing structure that may not be the best for your use case.</p><p name="b316" id="b316" class="graf--p graf-after--h4">Go’s struct embedding is amazing. It disguises composition as inheritance and allows easily changing implementation details via its powerful interfaces. It is much more powerful than a class-based inheritance model, as it allows a much greater degree of flexibility.</p><p name="9e80" id="9e80" class="graf--p graf-after--p graf--last">This article was originally published on <a href="https://simplyian.com/2016/06/28/Why-Go-s-structs-are-superior-to-class-based-inheritance/" class="markup--anchor markup--p-anchor" rel="nofollow">Simply Ian</a>.</p></div></div></section>
</body></html>
