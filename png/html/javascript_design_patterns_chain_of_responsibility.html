<!DOCTYPE html><html><head><title>JavaScript Design Patterns: Chain of Responsibility</title></head><body>
<h1>JavaScript Design Patterns: Chain of Responsibility</h1><p><a href="http://www.joezimjs.com/javascript/javascript-design-patterns-chain-of-responsibility/" target="_new">Original URL</a></p>
<p><blockquote>We&#x2019;ve made it to the final installment in the JavaScript Design Patterns series. That&#x2019;s right, after this you&#x2019;ll no longer have any clue what post will be coming out every&hellip;</blockquote></p>
<div><div class="entry-content">
		<p>We&#8217;ve made it to the final installment in the JavaScript Design Patterns series. That&#8217;s right, after this you&#8217;ll no longer have any clue what post will be coming out every Monday! Well today, we&#8217;ll be talking about the Chain of Responsibility Pattern. This pattern decouples the sender and receiver of a request. This is done with a chain of objects, each of which can handle the request itself or pass it on to the next object. Confused? Read on.<br></p>
<p>The rest of the JavaScript Design Patterns series:<br></p><h2>Chain of Responsibility Structure</h2>
<p>There are three parts to the Chain of Responsibility pattern: sender, receiver, and request. The sender makes the request. The receiver is a chain of 1 or more objects that choose whether to handle the request or pass it on. The request itself can be an object that encapsulates all the appropriate data.</p>
<p>A sender sends the request to the first receiver object in the chain. The sender only knows about this first object and nothing about the other receivers. The first receiver either handles the request and/or passes it on to the next one in the chain. Each receiver only knows about the next receiver in the line. The request will keep going down the line until the request was handled or there are no more receivers to pass it on to, at which point either nothing happens or an error is thrown, depending on how you want it to work.</p>
<h2>Chains in the World Around Us</h2>
<p>Event handling in the DOM uses one implementation of the Chain of Responsibility (amazing how many patterns are used together in the DOM, isn&#8217;t it). Once an event is fired, it <em>bubbles </em>up the DOM hierarchy, calling every event handler it runs into until it either gets to the end of the chain or a handler tells it to stop propagating.</p>
<h2>Chain of Responsibility Example</h2>
<p>For our example today, we&#8217;ll be creating an ATM. The Chain is going to consist of different sized bills. When you ask for some cash, the machine starts at the larger bills and pulls out as many as it needs, then moves on to the smaller bills. This example is very simple, which helps show the concept more clearly without diluting the code with implementations that are specific to the example.</p>
<p><img src="http://www.joezimjs.com/wp-content/uploads/chain_of_responsibility_atm.png" alt="Chain of Responsibility:ATM" title="Chain of Responsibility:ATM" width="447" class="aligncenter size-full wp-image-545"></p>
<p>We&#8217;ll start by creating the receiver class: <code>MoneyStacks</code>. Normally this would just be an abstract class or interface that would be subclassed/implemented to create numerous different receivers, but this example is simple enough that the only variance between each of the receivers will be the size of the bills in the stack, so we can just set that number via a parameter in the constructor.</p>
<div class="geshi javascript">
</div>
<p>It&#8217;s all pretty simple math. <code>withdraw</code> is the function that uses the chaining ability by ejecting the required bills and passing the request on when appropriate.</p>
<p>Now, we&#8217;ll build the ATM. Its constructor creates all of the money stacks and puts them into their hierarchical order. When someone calls its <code>withdraw</code> method, it just passes on the responsibility to the chain of money stacks.</p>
<div class="geshi javascript">
</div>
<h2>Ending My Responsibilities</h2>
<p>That&#8217;s all there is to this pattern. It&#8217;s pretty simple. Like the <a href="http://www.joezimjs.com/javascript/javascript-design-patterns-command/" title="JavaScript Design Patterns: Command" rel="nofollow">Command</a> and <a href="http://www.joezimjs.com/javascript/javascript-design-patterns-observer/" title="JavaScript Design Patterns: Observer" rel="nofollow">Observer</a> patterns, its purpose is to decouple senders and receivers but for different reasons and with different trade-offs. Due to its hierarchy structure, it&#8217;s also similar to the <a href="http://www.joezimjs.com/javascript/javascript-design-patterns-composite/" title="JavaScript Design Patterns: Composite" rel="nofollow">Composite</a> pattern, and can also be injected within the Composite pattern to make some of the methods more efficient.</p>
<p>Well, it&#8217;s been fun taking you through all of these JavaScript design patterns. I hope you&#8217;ve learned something along the way. If you haven&#8217;t read through them all, I highly recommend that you do. The list is included below. Remember, though, that just because you know a pattern, doesn&#8217;t mean it is required for the task at hand (you know the old &#8220;when all you have is a hammer, everything looks like a nail&#8221; saying).</p>
<p>I also ask that if you found any of these design pattern posts helpful that you go ahead and let me know through a comment or spread the post around the internet to help others like us grow in JavaScript wisdom. You can do that using the links below, if you wish. As always, Happy Coding!</p>
<p id="series">JavaScript Design Patterns series:</p>
<p>Related posts:</p></div>

	</div>
</body></html>
