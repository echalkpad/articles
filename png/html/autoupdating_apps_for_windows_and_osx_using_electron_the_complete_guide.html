<!DOCTYPE html><html><head><title>Auto-updating apps for Windows and OSX using Electron: The complete guide</title></head><body>
<h1>Auto-updating apps for Windows and OSX using Electron: The complete guide</h1><p><a href="https://medium.com/@svilen/auto-updating-apps-for-windows-and-osx-using-electron-the-complete-guide-4aa7a50b904c" target="_new">Original URL</a></p>
<p><blockquote>You’ve made an amazing desktop app using Electron in no time, and you’ve just shipped it to your users. While you’re chilling like a villain, you may realise that you have missed one important bit:&hellip;</blockquote></p>
<section name="36ab" class=" section--body section--first section--last" score="41.25"><div class="section-content" score="32.5"><div class="section-inner layoutSingleColumn" score="-13.75"><p name="38dd" id="38dd" class="graf--p graf-after--h3">You’ve made an amazing desktop app using <a href="http://electron.atom.io" class="markup--anchor markup--p-anchor" rel="nofollow">Electron</a> in no time, and you’ve just shipped it to your users. While you’re chilling like a villain, you may realise that you have missed one important bit: how are users going to get the next version of that amazing piece of software that you’ve just created? Yes, of course they can uninstall/install the app, but that’s lame, isn’t it?</p><p name="2d34" id="2d34" class="graf--p graf-after--p">A quick glance at <a href="http://electron.atom.io/docs" class="markup--anchor markup--p-anchor" rel="nofollow">Electron’s documentation</a>, and you will notice that the framework ships with an <a href="http://electron.atom.io/docs/v0.36.7/api/auto-updater/" class="markup--anchor markup--p-anchor" rel="nofollow"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">auto-updater</em></strong></a> module, which is simply an interface to another framework — Squirrel. Squirrel will check for new versions in the background (or when you tell it to), download the new version, and handle the upgrade for you automagically when you start or restart the app.</p><p name="e2a5" id="e2a5" class="graf--p graf-after--p">Sadly things are not as easy as they look on paper — there are differences in how auto-updating works on OSX and Windows (there is no support for Linux as of now) and documentation is scattered across multiple repositories. I’ve spent a fair amount of time trying to make everything work, so I decided it’s worth putting what I’ve learnt into a little guide, that should (hopefully) save some of your time.</p><p name="be49" id="be49" class="graf--p graf-after--p">Although everything described should work on both Windows and OSX, for the sake of clarity—I am running everything on Mac OSX 10.11, with the exception of building the installer for Windows.</p><p name="60d7" id="60d7" class="graf--p graf-after--p">Suggestions to improve or update this guide? <a href="http://twitter.com/svileng" class="markup--anchor markup--p-anchor" rel="nofollow">Drop me a tweet</a>!</p><p name="4560" id="4560" class="graf--p graf-after--h3">Before we look at implementing auto-updating, there’s one important step — packaging. I assume that the majority of people have this working, using <a href="https://github.com/maxogden/electron-packager" class="markup--anchor markup--p-anchor" rel="nofollow">electron-packager</a>, but there are a couple of things which are easy to miss.</p><figure name="e1fd" id="e1fd" class="graf--figure graf--iframe graf-after--p" score="-13.75"><figcaption class="imageCaption">package.json</figcaption></figure><p name="5b4d" id="5b4d" class="graf--p graf-after--figure">Notice the extra <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">package.json</em></strong><em class="markup--em markup--p-em"> </em>fields — <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">productName</em></strong>, <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">author</em></strong> and <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">description </em></strong>— which are not necessary for packaging, but will be picked up by the Squirrel Installer for Windows.</p><p name="0d9c" id="0d9c" class="graf--p graf-after--p">Code-signing the application is not required for auto-updating, but is highly desirable. For OSX, you’ll need an Apple Developer Certificate, and then you just replace this parameter for the <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">pack:osx </em></strong>script:</p><pre name="ec41" id="ec41" class="graf--pre graf-after--p">--sign='Developer ID Application: My Company Ltd (ABCDEFGH10)'</pre><p name="7c5a" id="7c5a" class="graf--p graf-after--pre">with whatever you have in <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">Keychain Access &gt; My Certificates</em></strong> in OSX.</p><p name="a603" id="a603" class="graf--p graf-after--p">I haven’t got code-signing working for Windows yet, but you can have a look at <a href="http://zed.one/code-signing-a-windows-application.html" class="markup--anchor markup--p-anchor" rel="nofollow">this excellent tutorial</a> on the topic.</p><p name="343d" id="343d" class="graf--p graf-after--p">Specifically for Windows, it’s good to pass all the optional version-string parameters to electron-packager, such as company name and product name and so on. Once we generate the Squirrel installer for Windows, the app will show up with the right metadata in Windows’ start menu, instead of Atom’s default data.</p><p name="56da" id="56da" class="graf--p graf-after--p">So, let’s get started!</p><p name="d3f1" id="d3f1" class="graf--p graf-after--h3">Auto-updating for OSX is handled by <a href="https://github.com/Squirrel/Squirrel.Mac" class="markup--anchor markup--p-anchor" rel="nofollow">Squirrel.Mac</a>, which is built-in Electron. Which means that you just have to package your app, and you’re good to go!</p><p name="973f" id="973f" class="graf--p graf-after--p">Well, not quite.</p><p name="ab89" id="ab89" class="graf--p graf-after--p">The way Squirrel.Mac works is by checking a given API endpoint to see if there is a new version of the app. If there is no new version, the endpoint should return <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">HTTP</em></strong> <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">204</em>. </strong>If there is a new version, however, it will expect a <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">HTTP 200 JSON-formatted </em></strong>response, containing <strong class="markup--strong markup--p-strong">a url to a .zip file:</strong></p><pre name="ff4e" id="ff4e" class="graf--pre graf-after--p">{<br> "url": "http://mysite.com/path/to/zip/MyApp.zip"<br>}</pre><p name="0238" id="0238" class="graf--p graf-after--pre">Squirrel will make an <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">application/zip </em></strong>request using that url, download the file, and fire up the final event to let you know that the update is ready to install. Everything is handled automatically for you.</p><p name="119a" id="119a" class="graf--p graf-after--p">If you’re not quite sure how the server should like, here’s a super-minimal Node.js/Express app, which assumes the following directory structure:</p><pre name="41c3" id="41c3" class="graf--pre graf-after--p">└── releases<br> ├── darwin<br> │ ├── 1.0.0<br> │ ├── 1.0.2<br> │ └── 1.0.3<br> └── win32</pre><figure name="ebac" id="ebac" class="graf--figure graf--iframe graf-after--pre" score="-13.75"><figcaption class="imageCaption">Node update server package.json</figcaption></figure><figure name="1923" id="1923" class="graf--figure graf--iframe graf-after--figure" score="-13.75"><figcaption class="imageCaption">Simple Express server for testing Squirrel.Mac auto-updating</figcaption></figure><p name="ad2a" id="ad2a" class="graf--p graf-after--figure">It will serve files from the local filesystem, which is not ideal — I suggest getting those files on Amazon S3 instead.</p><p name="6707" id="6707" class="graf--p graf-after--p">You can call the endpoint from Electron in development like so:</p><pre name="2c1a" id="2c1a" class="graf--pre graf-after--p">http://localhost:3000/updates/latest?v=1.0.1</pre><p name="5385" id="5385" class="graf--p graf-after--pre">Where <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">?v=1.0.1 </em></strong>is your current app version.</p><p name="ade8" id="ade8" class="graf--p graf-after--p">Now that you have the server and endpoint in place, handling updating in the app is quite simple.</p><p name="7dd9" id="7dd9" class="graf--p graf-after--p">In your <strong class="markup--strong markup--p-strong">main Electron application</strong> file, require the auto-updater module, grab the current OS and your app version:</p><pre name="4843" id="4843" class="graf--pre graf-after--p">const autoUpdater = require('auto-updater');<br>const appVersion = require('./package.json').version;<br>const os = require('os').platform();</pre><p name="e605" id="e605" class="graf--p graf-after--pre">And configure the endpoint, which is going to be different for Windows and OSX (you’ll see why when we get to the Windows part):</p><figure name="b9a5" id="b9a5" class="graf--figure graf--iframe graf-after--p" score="-13.75"><figcaption class="imageCaption">Telling Electron where to look at for new versions</figcaption></figure><p name="9a67" id="9a67" class="graf--p graf-after--figure">There are a number of events fired by the <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">autoUpdater </em></strong>module, which you can implement and send to the renderer process: check <a href="http://electron.atom.io/docs/v0.36.7/api/auto-updater/#events" class="markup--anchor markup--p-anchor" rel="nofollow">auto-updater documentation page</a> for more info. Depending on how you decide to handle the event and notify the user, all you need to do in the end is</p><pre name="a31d" id="a31d" class="graf--pre graf-after--p">autoUpdater.quitAndInstall();</pre><p name="c1a5" id="c1a5" class="graf--p graf-after--pre">in the main application file, and the app will restart with the new version in place. Boom!</p><p name="e5c2" id="e5c2" class="graf--p graf-after--h3">As you would expect, auto-updating on Windows is done via <a href="https://github.com/Squirrel/Squirrel.Windows" class="markup--anchor markup--p-anchor" rel="nofollow">Squirrel.Windows</a>. The process, however, is completely different to the one for OSX.</p><p name="b92d" id="b92d" class="graf--p graf-after--p">Unlike Squirrel.Mac, Squirrel.Windows does not require an API endpoint to check for new versions — all it needs is a file server, so you can simply drop your files in an Amazon S3 bucket. The Squirrel Updater, however, is not bundled in Electron, and is a 3rd party dependency. This means that you’ll need to generate an installer for your packaged Windows app, that will include the Squirrel Updater as well.</p><p name="397b" id="397b" class="graf--p graf-after--p">The good news is that the installer and updater for Windows is quite slick—it installs and launches the app on-the-fly, when you launch the Setup.exe. No boring installer wizards and clicking Next, Next, Next, Finish, like most installers for Windows. It also generates delta packages, so you don’t have to download the whole app when you do an update, which is ace.</p><p name="d7b3" id="d7b3" class="graf--p graf-after--p">The bad news (for Mac users, at least) is that I couldn’t build the installer properly on OSX, so I suggest you <a href="https://dev.windows.com/en-us/microsoft-edge/tools/vms/mac/" class="markup--anchor markup--p-anchor" rel="nofollow">download a Windows VM</a> for <a href="https://www.virtualbox.org/" class="markup--anchor markup--p-anchor" rel="nofollow">VirtualBox</a>, and install Node.js on it.</p><p name="6d0f" id="6d0f" class="graf--p graf-after--p">Assuming that you’ve configured and set the correct update feed, using the code for OSX above, the only thing left code-wise is to handle a few Squirrel.Windows events, which are different than the ones for OSX. You can <a href="https://github.com/atom/grunt-electron-installer#handling-squirrel-events" class="markup--anchor markup--p-anchor" rel="nofollow">see an example here</a>. There is an easier way, however — just install the <a href="https://github.com/mongodb-js/electron-squirrel-startup" class="markup--anchor markup--p-anchor" rel="nofollow"><strong class="markup--strong markup--p-strong">electron-squirrel-startup</strong></a><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em"> </em></strong>npm module:</p><pre name="e4f4" id="e4f4" class="graf--pre graf-after--p">npm install electron-squirrel-startup --save-dev</pre><p name="6df6" id="6df6" class="graf--p graf-after--pre">And place that line at the top of your main Electron application file:</p><pre name="f04c" id="f04c" class="graf--pre graf-after--p">if (require('electron-squirrel-startup')) return;</pre><p name="5713" id="5713" class="graf--p graf-after--pre">Squirrel.Windows events should be handled as early as possible, apparently, so that’s the way to go.</p><p name="c9bf" id="c9bf" class="graf--p graf-after--p">Finally, to generate the installer, we’re going to use Atom’s <a href="https://github.com/atom/grunt-electron-installer" class="markup--anchor markup--p-anchor" rel="nofollow"><strong class="markup--strong markup--p-strong">grunt-electron-installer</strong></a><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">.</em></strong> Why this is a grunt plugin, instead of a simple command-line utility — I don’t know, but that’s how it is.</p><p name="114d" id="114d" class="graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Update: Turns out the Electron team are working on a stand-alone installer package called </strong><a href="https://github.com/electronjs/windows-installer" class="markup--anchor markup--p-anchor" rel="nofollow"><strong class="markup--strong markup--p-strong">electron-winstaller</strong></a><strong class="markup--strong markup--p-strong">, which has the same API as the grunt task.</strong></p><p name="a37b" id="a37b" class="graf--p graf-after--p">Zip the win32 folder, produced by electron-packager, and copy it over to the Virtual Machine. Outside that folder, you’ll need to configure the grunt task that will build the installer, so you should install all dependencies first:</p><pre name="0a0e" id="0a0e" class="graf--pre graf-after--p">npm install -g grunt-cli<br>npm install grunt grunt-electron-installer --save-dev</pre><p name="d3b6" id="d3b6" class="graf--p graf-after--pre">Assuming that the Windows compiled package is in a folder called <strong class="markup--strong markup--p-strong">MyApp-win32-ia32</strong>, here’s how the Gruntfile could look like:</p><figure name="d42b" id="d42b" class="graf--figure graf--iframe graf-after--p" score="-13.75"></figure><p name="3d5c" id="3d5c" class="graf--p graf-after--figure">Note that if you want to code-sign your files and the installer, you should supply all params to the task config, too.</p><p name="dd35" id="dd35" class="graf--p graf-after--p">Running the grunt task should produce a bunch of files in the ./<strong class="markup--strong markup--p-strong">dist </strong>folder:</p><pre name="7738" id="7738" class="graf--pre graf-after--p">grunt create-windows-installer</pre><p name="a0c5" id="a0c5" class="graf--p graf-after--pre">You expect to see something similar to</p><pre name="6700" id="6700" class="graf--pre graf-after--p">└── dist<br> ├── MyApp.1.0.0.nupkg<br> ├── MyApp-1.0.0-full.nupkg<br> ├── RELEASES<br> ├── Setup.exe</pre><p name="f0b5" id="f0b5" class="graf--p graf-after--pre">With the next release, the installer will generate a delta packages automatically, too.</p><p name="1301" id="1301" class="graf--p graf-after--p">Now the easiest part — grab all those files, and dump them in an S3 bucket. The url pointing to that folder, containing the <strong class="markup--strong markup--p-strong">RELEASES </strong>and <strong class="markup--strong markup--p-strong">nupkg </strong>files should be the <strong class="markup--strong markup--p-strong">updateFeed </strong>url given to the autoUpdater, when running on Windows (we’ve done that earlier for OSX, so go back to the main application file and update it).</p><p name="65a2" id="65a2" class="graf--p graf-after--p">Note: there is currently an issue with the installer related to node-rcedit — it throws an error when it tries to modify the .exe file to place some of the metadata and replace the default icon. You can <a href="https://github.com/atom/grunt-electron-installer/issues/96" class="markup--anchor markup--p-anchor" rel="nofollow">see the issue here</a>. Unfortunately if you want to change the icon or put the real data onto the installer file, you’ll have to do it manually with <a href="http://www.angusj.com/resourcehacker/" class="markup--anchor markup--p-anchor" rel="nofollow">ResHacker</a>.</p><p name="b3d4" id="b3d4" class="graf--p graf-after--h3">Hope this helps and serves as a good starting point to anyone who’s working on auto-updating with Electron. If you spot anything that I’ve missed, or have any suggestions for improvement (there’s definitely room for that) — feel free to <a href="http://twitter.com/svileng" class="markup--anchor markup--p-anchor" rel="nofollow">drop me a tweet</a> to let me know! Also, keep in mind that Electron is a fast-evolving framework, so always make sure you’re reading the right documentation for your version, since Electron APIs changes quite often.</p><p name="d0ac" id="d0ac" class="graf--p graf-after--p graf--last">I’m Svilen — a freelance software developer &amp; consultant based in London, UK, focusing mostly on Node.js and front-end development. You can find out more about me at <a href="http://s2g.io" class="markup--anchor markup--p-anchor" rel="nofollow">s2g.io</a> or <a href="http://twitter.com/svileng" class="markup--anchor markup--p-anchor" rel="nofollow">contact me on twitter</a>.</p></div></div></section>
</body></html>
