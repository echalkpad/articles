<!DOCTYPE html><html><head><title>Developing our first iOS App with React Native</title></head><body>
<h1>Developing our first iOS App with React Native</h1><p><a href="http://code.hireart.com/2016/02/24/react-native-ios-app/" target="_new">Original URL</a></p>
<p><blockquote>When we started talking about creating a mobile app for our candidates, we were pretty clueless about what it would actually take to build a mobile app. We knew generally that we wanted something&hellip;</blockquote></p>
<div><article class="blog-post"><p>When we started talking about creating a mobile app for our candidates, we were pretty clueless about what it would actually take to build a mobile app. We knew generally that we wanted something cool, fun to use, and really slick, but none of us had ever built a mobile app before. </p> <p>We jumped on the React Native train and we're glad we did. These are some of the things we thought about when we made the decision and some of the things we learned along the way.</p> <h2 id="reasons-to-use-react-native">Reasons to use React Native</h2> <p>We're web developers, not iOS developers. I've been to a few meetups in NYC about how cool Swift is and how Objective C is still relevant, but I'm most comfortable writing Ruby and Javascript. Our team had started using Facebook's React in early 2015 and initial react(ion) was overwhelmingly positive. When React Native came on the scene, we were initially skeptical (cross device platforms can be problematic). But the more we looked into it, the more we liked it. These are the most compelling reasons for us:</p> <ol> <li><strong>Learn once, write anywhere</strong> Cross-device platforms are generally bad. They usually satisfy the lowest common denominator and the result is almost always sub-optimal. React Native uses the same React.js framework, but writing for Android vs iOS are actually different projects with some shared code. That means code for each device can be written specifically for that device using entirely native(surprise!) components.</li> </ol> <p><img src="http://code.hireart.com/images/20160224/platform-code-b8f9d64a.png"></p> <ol> <li><p><strong>Declarative views</strong> We fell in love with React's declarative views when we used them for the web, being able to use declarative views on iOS development was a huge plus for us as it meant more predictable code and less bugginess.<br> <a href="https://en.wikipedia.org/wiki/Reactive_programming">https://en.wikipedia.org/wiki/Reactive_programming</a></p></li> <li><p><strong>Flexbox for mobile</strong> We didn't know for sure how the constraints solver works for iOS, but we weren't sure we wanted to go down that road. Lucky for us, React Native uses flexbox, which by now is supported by <em>almost</em> every browser and makes layouts much more intuitive. (in our humble opinion) <a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/">https://css-tricks.com/snippets/css/a-guide-to-flexbox/</a></p></li> </ol> <p><img title="iOS constraint solver" alt="ios constraint" src="http://www.techotopia.com/images/3/3d/Ios_8_greater_or_less_constraint.png"></p> <p>iOS constraints</p> <p><img title="flexbox" alt="flexbox" src="https://static.bocoup.com/blog/flex-pack.svg"></p> <p>flexbox</p> <ol> <li><strong>Javascript</strong> This falls into the category of what we don't know (Objective C and Swift). To state the obvious, not having to learn another language really cuts down on development time! Also, we were excited about using ES6, which react-native supports out of the box. We were avid users of coffeescript and transitioning to ES6 was easy. <a href="https://robots.thoughtbot.com/replace-coffeescript-with-es6">https://robots.thoughtbot.com/replace-coffeescript-with-es6</a></li> </ol> <h2 id="reservations-about-using-react-native">Reservations about using React Native</h2> <p>We knew from the start that initial gains in development time might be offset by limited customizability and dependency on the existence of React Native Component. Here are some reasons we were hesitant about using React Native</p> <ol> <li><p><strong>Limited to React Native Ecosystem</strong> When we initially looked at React Native in September of 2015, we saw that a lot of the iOS native elements had already been implemented and more would be on the way. However, we were still worried that a particular component we need won't be available in React Native. And later we did find that we had to build out our own React Native Bridge for certain SDKs (AWS and Mixpanel).</p></li> <li><p><strong>Bleeding Edge</strong> Updates to React Native happen quickly and code which worked on a previous build may (on rare occasions) become obsolete. We encountered this a few times during our development cycle and tried to mitigate its effects by upgrading intentionally only when we need a new feature followed by rigorous testing.</p></li> <li><p><strong>Ungoogleable</strong> Writing code for a new system often means encountering errors no one else has seen before. The number of 'ungoogleable' problems were significantly higher than we had ever encountered with Ruby on Rails. Oftentimes finding the solution required tenacity: referencing documentation and digging through source code (like the good old days). However, much credit goes to the React Native team and its ecosystem for regular updates that address unexpected behavior.</p></li> </ol> <h2 id="react-native-packages">React Native Packages</h2> <p>It turned out that component support for react-native was exceptional. Everything from ActivityIndicator (the spinner) to Alerts to Sliders worked seamlessly via Javascript. It's hard to emphasize just how effortless it was to create a native iOS app despite not knowing Objective C or Swift. Furthermore, new packages were becoming available everyday via npm. These are a few of our favorites in no particular order:</p> <ul> <li><strong>react-native-simple-store</strong> <a href="https://www.npmjs.com/package/react-native-simple-store">https://www.npmjs.com/package/react-native-simple-store</a> We started out using AsyncStorage, but found it tedious to build the same save and get functions over and over again. Simple Store was a great solution build on top of AsyncStorage that allowed us to access the device storage <em>simply</em>.</li> </ul> <pre class="highlight javascript"><code><p class="nx">Store</p><p class="nx">get</p><p class="s1">'user'</p><p class="nx">then</p><p class="nx">user</p> 
 <p class="c1">// some code</p>
<p class="p">}).</p><p class="k">catch</p><p class="nx">error</p> 
 <p class="nx">console</p><p class="nx">warn</p><p class="nx">error</p>
<p class="p">}).</p><p class="nx">done</p>
</code></pre> <ul> <li><strong>react-native-vector-icons</strong> <a href="https://www.npmjs.com/package/react-native-vector-icons">https://www.npmjs.com/package/react-native-vector-icons</a> This is the best vector icon package we found, we used a combination of FontAwesome and EvilIcons and it worked pretty flawlessly. MaterialIcons, IonIcons, and others are also available via this package.</li> </ul> <pre class="highlight plaintext"><code>&lt;Icon name='trophy' /&gt;
&lt;EvilIcon name='check' /&gt;
</code></pre> <pre class="highlight javascript"><code><p class="kd">var</p> <p class="nx">Person</p> <p class="nx">struct</p>
 <p class="na">name</p> <p class="nb">String</p> <p class="c1">// a required string</p>
 <p class="na">surname</p> <p class="nx">maybe</p><p class="nb">String</p> <p class="c1">// an optional string</p>
 <p class="na">age</p> <p class="nb">Number</p> <p class="c1">// a required number</p>
 <p class="na">rememberMe</p> <p class="nb">Boolean</p> <p class="c1">// a boolean</p>
<p class="p">});</p>
</code></pre> <pre class="highlight javascript"><code><p class="nx">Actions</p><p class="nx">dashboard</p>
</code></pre> <h2 id="weirdness">Weirdness</h2> <p>Coming from web development, we've encountered a few head-scratchers that were initially difficult to wrap our heads around. Here are some of them.</p> <ul> <li><strong>Styling</strong> Not that it isn't possible to create a stylesheet for RN, it's that styles are not cascading. This makes defining styles just a big weird. We solved it with style definitions on several levels with inline over-rides.</li> </ul> <p>Styles.js</p> <pre class="highlight javascript"><code><p class="nx">module</p><p class="nx">exports</p> <p class="nx">StyleSheet</p><p class="nx">create</p>
 <p class="na">title</p> 
 <p class="na">fontSize</p> 
 <p class="na">textAlign</p> <p class="s1">'center'</p>
 <p class="na">color</p> <p class="nx">blueText</p>
 <p class="na">fontFamily</p> <p class="s1">'Avenir'</p>
 <p class="na">fontWeight</p> <p class="s1">'700'</p>
 
 <p class="na">header</p> 
 <p class="na">padding</p> 
 <p class="na">paddingTop</p> 
 <p class="na">backgroundColor</p> <p class="s1">'#fff'</p>
 <p class="na">borderBottomWidth</p> 
 <p class="na">borderBottomColor</p> <p class="s1">'#ccc'</p>
 

</code></pre> <p>Component.js</p> <pre class="highlight plaintext"><code>...
&lt;Text style={[Styles.header, {color: 'white'}]}&gt;
 Some text
&lt;/Text&gt;
...
</code></pre> <p>Standard style would look like this:</p> <pre class="highlight plaintext"><code>style={Styles.header}
</code></pre> <p>Custom inline style looks like this:</p> <pre class="highlight plaintext"><code>style={{color: 'white'}}
</code></pre> <p>This is how we merge the two:</p> <pre class="highlight plaintext"><code>style={[Styles.header, {color: 'white'}]}
</code></pre> <p>It feels hacky and bad... There's probably a better way to do this, but it wasn't obvious to us when we were figuring this out.</p> <ul> <li><strong>Circular Requires/Navigation</strong></li> </ul> <p>This is a big no no (most circular things are bad unless it's recursion, in which case it's not circular just recursive). This can happen by accident if using NavigatorIOS. Routing for web is single-stage. You know where you are and probably where you came from, that's about it. On iOS, views are pushed and popped onto a stack. Try to push a previously pushed component will result in an error. Attempting to simply require a component that might end up pushing the current component will cause a circular require and break. Using <em>react-native-router-flux</em> solved this problem for us and helped us reason about our routes in a much more scalable way.</p> <h2 id="overall">Overall</h2> <p>React Native is a great way to build a mobile app. Not knowing Swift or Objective C makes it impossible to make a direct comparison but the experience is definitely a positive one. Even though RN is not without its nuances, it comes with the benefit of building a truly native app. We're glad that we used RN to build out our first mobile app. React Native continues to get better and the ability to quickly context switch from web to mobile for our small nimble dev team is an incredible thing.</p> <p>In the next few posts, I will go more in depth regarding how we solved particular problems. </p> <ul> <li>Login and Authentication</li> <li>API and callbacks</li> <li>iOS SDKs using RNBridge</li> </ul> <p><img src="http://code.hireart.com/images/tom-profile-effe20d7.png"></p> <p>Tom Tang leads mobile development at HireArt. Feel free to reach out: <a href="mailto:tom@hireart.com">tom@hireart.com</a></p> </article></div>
</body></html>
