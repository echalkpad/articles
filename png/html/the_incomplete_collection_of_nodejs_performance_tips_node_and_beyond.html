<!DOCTYPE html><html><head><title>The Incomplete Collection of
Node.js Performance Tips — Node and Beyond</title></head><body>
<h1>The Incomplete Collection of
Node.js Performance Tips — Node and Beyond</h1><p><a href="https://medium.com/node-and-beyond/the-incomplete-collection-of-node-js-performance-tips-94cc712661bd" target="_new">Original URL</a></p>
<p><blockquote>This is a (non-comprehensive) collection of practical advice on how to get more performance out of your Node.js application. While the points I am making below are just some of the more obvious&hellip;</blockquote></p>
<div score="17.5"><section name="5329" class=" section--body section--first" score="41.25"><div class="section-content" score="32.5"><div class="section-inner layoutSingleColumn" score="11.5"><figure name="fdbf" id="fdbf" class="graf--figure" score="-12.5"><div class="aspectRatioPlaceholder is-locked" score="6.25"><img class="graf-image" src="https://cdn-images-1.medium.com/max/800/1*1dI8vwqQTqVVhDy75ugc9A.png"></div></figure><p name="c8b4" id="c8b4" class="graf--p">This is a (non-comprehensive) collection of practical advice on how to get more performance out of your Node.js application. While the points I am making below are just some of the more obvious<strong class="markup--strong markup--p-strong"> </strong>performance boosting tips, I will try to keep a more detailed list maintained on GitHub (if people like it). But let&#x2019;s jump right into it:</p><p name="cd76" id="cd76" class="graf--p">Node.js is single threaded (duh). So an instance of Node runs in a single thread, not taking any advantage of modern multi-core CPUs. Luckily, Node&#x2019;s cluster module allows you to easily launch a whole cluster of Node child processes to better handle the load. (And child processes share the same server ports.)</p><p name="7022" id="7022" class="graf--p">Node&#x2019;s documentation gives an excellent and easy to read starting point on how to get started with clusters: <a href="https://nodejs.org/api/cluster.html" class="markup--anchor markup--p-anchor" rel="nofollow">https://nodejs.org/api/cluster.html</a></p><p name="050c" id="050c" class="graf--p"><em class="markup--em markup--p-em">Beyond better performance, clusters will have the added benefit of improving the resilience of your application. The &#x2018;master&#x2019; process knows when a child processes crashes, and routes traffic to other child processes until the crashed process gets restarted.</em></p><p name="6dd3" id="6dd3" class="graf--p">An often overlooked or forgotten middleware is you can use with express is compression. It uses <strong class="markup--strong markup--p-strong">gzip</strong> to compress your http payload sent to the client.</p><pre name="a1ce" id="a1ce" class="graf--pre">var app = require('express')();<br>var compression = require('compression');<br>app.use(compression());</pre><p name="5772" id="5772" class="graf--p"><em class="markup--em markup--p-em">Make sure that you load compression </em><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">before</em></strong><em class="markup--em markup--p-em"> any other middleware.</em></p><p name="b0f9" id="b0f9" class="graf--p">Unlike most server-based applications, Node.js apps will often be designed to run permanently. If that is the case for you, consider setting your most used variables &amp; objects just once at initialization and keep reusing them for any incoming requests down the line. Think of something like &#x201C;the top 5 articles of the week&#x201D; your users will see on your frontpage.<br>Do you really need to update that content <em class="markup--em markup--p-em">every</em> time a user visits your page? If not, you can cache it:</p><pre name="7f91" id="7f91" class="graf--pre">app.set('view cache', true);</pre><p name="2c6d" id="2c6d" class="graf--p">Do you make use of http PUT/DELETE requests? If not, disable <em class="markup--em markup--p-em">methodOverride</em>. If you don&#x2019;t even use POST requests (maybe your app does everything via sockets) you can even get rid of the <em class="markup--em markup--p-em">bodyParser </em>too.</p><p name="4f95" id="4f95" class="graf--p">Take a close look which middleware you actually need, and which you can work without of.</p><p name="545e" id="545e" class="graf--p">And some middleware might only be needed in a specific environment mode. For those cases you can do something like this:</p><pre name="364c" id="364c" class="graf--pre">if (app.get('env') !== 'production') {<br> app.use(morgan);<br>}</pre><p name="877c" id="877c" class="graf--p">Express sessions are saved in memory. Your memory footprint grows with every additional user connected. This can add quite a bit of overhead to your application.</p><p name="d490" id="d490" class="graf--p">Try to limit your use of session variables. Better to use hashed tokens and fetch user data from an alternative session store such as MongoDB or Redis.</p><p name="b84b" id="b84b" class="graf--p"><em class="markup--em markup--p-em">But if you are brave enough you might even want to consider to not store any state server-side at all, but dive into client side sessions. For that, take a look at this: </em><a href="https://github.com/mozilla/node-client-sessions" class="markup--anchor markup--p-anchor" rel="nofollow"><em class="markup--em markup--p-em">https://github.com/mozilla/node-client-sessions</em></a></p><p name="4327" id="4327" class="graf--p">Probably the single biggest advantage of Node.js (besides server side javascript execution itself of course) is it&#x2019;s asynchronous nature.</p><p name="245d" id="245d" class="graf--p">Being single-threaded, your Node.js application can easily getblocked by synchronous code execution taking too long to return. If incoming requests can&#x2019;t get processed anymore, your application is rendered de-facto useless.</p><p name="41b5" id="41b5" class="graf--p">Think about some especially time, memory, or CPU intensive tasks. For instance accessing, reading or writing large files. If there is no absolutely, critical, unavoidable reason, you should <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">always</em></strong> use async over sync.</p><p name="0e07" id="0e07" class="graf--p">But keep asynchronous support also in mind when choosing external libraries and components. Make sure they are not potentially blocking your application.</p><p name="f60f" id="f60f" class="graf--p">Revisit your codebase and find chained async callbacks and think if you can run those functions parallel. For instance: You need to read 2 files before executing a callback. This can be done way better than chaining callbacks.</p><p name="73cd" id="73cd" class="graf--p"><strong class="markup--strong markup--p-strong">The <em class="markup--em markup--p-em">async</em> module</strong> allows you to run functions parallel without the need of chaining them in callbacks. Here the code example for async.parallel:</p><pre name="b4c6" id="b4c6" class="graf--pre">async.parallel([<br> function(){ ... },<br> function(){ ... }<br>], callback);</pre><p name="3c07" id="3c07" class="graf--p">Awesome, right? You get one callback executed after all parallel running functions finished. Take a look at the documentation for more details: <a href="https://github.com/caolan/async" class="markup--anchor markup--p-anchor" rel="nofollow">https://github.com/caolan/async</a></p><p name="684e" id="684e" class="graf--p"><strong class="markup--strong markup--p-strong">Bluebird and Q</strong> are known first and foremost for giving us promises. But they also let us execute code parallel returning a promise (um.. callback-ish) after all promises (um&#xA0;.. promisified functions) returned.<br>Let&#x2019;s look at an example for bluebird:</p><pre name="6343" id="6343" class="graf--pre">Bluebird.all([promiseFunction1,promiseFunction2]) <br> .then(function(data) {<br> // will execute after all promisified functions returned<br> });</pre><p name="3740" id="3740" class="graf--p"><strong class="markup--strong markup--p-strong">ES 6</strong> has a native support for promises and likewise provide a&#xA0;<em class="markup--em markup--p-em">.all()</em> method. Depending on your Node version, you might have already support for it.</p><pre name="5a18" id="5a18" class="graf--pre">Promise.all([promiseFunction1, promiseFunction1])<br> .then(function(data) {<br> // will execute after all promisified functions returned<br> });</pre><p name="1c3c" id="1c3c" class="graf--p"><em class="markup--em markup--p-em">If for whatever reason you do not want to use any of the options above, you could also use following approach. But this does not scale well for obvious reasons. Really, you shouldn't do that.</em></p><figure name="0dc8" id="0dc8" class="graf--figure graf--iframe" score="-13.75"></figure><p name="a94b" id="a94b" class="graf--p">If you come from a traditional web development side to Node.js, you are probably used to working with libraries such as <a href="http://underscorejs.org/" class="markup--anchor markup--p-anchor" rel="nofollow">underscore</a> or <a href="https://lodash.com/" class="markup--anchor markup--p-anchor" rel="nofollow">lodash</a> to take advantage of higher order functions (think of <em class="markup--em markup--p-em">_.each</em>,<em class="markup--em markup--p-em"> _.map</em>, etc..)</p><p name="335f" id="335f" class="graf--p">Those libraries are written with the <strong class="markup--strong markup--p-strong">front-end</strong> in mind, and that means they include a sizable chunk of code that makes sure everything works as it should in a variety of browser environment: From Chrome to Safari, from Firefox to IE, plus&#xA0;.. polyfills (Yeah, we are looking at you IE).</p><p name="9494" id="9494" class="graf--p">Which is <strong class="markup--strong markup--p-strong">great</strong>, but also means those libraries contain a lot of additional code that you do not need&#x200A;&#x2014;&#x200A;not server-side anyways. So before adding yet another module and adding to your resource footprint, try taking advantage of V8 native functions instead, such as <em class="markup--em markup--p-em">forEach</em>, <em class="markup--em markup--p-em">map</em>, etc.</p><p name="6c8c" id="6c8c" class="graf--p">If you are working with MongoDB as your database of choice, I have two easy recommendations that could improve your performance quite a bit. (And you should be able to fairly easy retrofit your already existing apps)</p><ol class="postList"><li name="c15d" id="c15d" class="graf--li">limit queries in &#x2018;scope&#x2019; whenever possible, and</li><li name="a0b9" id="a0b9" class="graf--li">add indices to collections which are queried often</li></ol><p name="a8cc" id="a8cc" class="graf--p">Imagine you want to display the last 10 posts of a user whenever the user visits your site. First, it is obvious that will want to index your collections accordingly, but you should also make sure to limit your MongoDB queries in &#x2018;scope&#x2019;. This can mean 2 things: First, to limit the fields you want returned, and secondly (maybe more importantly) to limit the number of documents returned. Take a look at these example snippets from the MongoDB documentation:</p><pre name="9bec" id="9bec" class="graf--pre">db.user.find({ type: 'customer' }, { item: 10, qty: 1 } );</pre><pre name="33e4" id="33e4" class="graf--pre">db.user.find({ type: 'customer' }).limit(10);</pre><p name="182c" id="182c" class="graf--p">Makes sense? Also dig into the MongoDB&#x2019;s documentation on creating and working with indices in Node: <a href="http://docs.mongodb.org/getting-started/node/indexes/" class="markup--anchor markup--p-anchor" rel="nofollow">http://docs.mongodb.org/getting-started/node/indexes/</a></p><p name="5cd1" id="5cd1" class="graf--p"><em class="markup--em markup--p-em">Btw: I highly recommend Mongo University&#x2019;s course: &#x201C;</em><a href="https://university.mongodb.com/courses/M101JS/about" class="markup--anchor markup--p-anchor" rel="nofollow"><em class="markup--em markup--p-em">MongoDB for Node.js Developers</em></a><em class="markup--em markup--p-em">&#x201D; Believe me, it&#x2019;s </em><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">super</em></strong><em class="markup--em markup--p-em"> </em><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">awesome</em></strong><em class="markup--em markup--p-em">!</em></p><p name="80f1" id="80f1" class="graf--p">Instead of using server side rendering such Express&#x2019; Jade templating, move to client side rendering using <a href="http://facebook.github.io/react/" class="markup--anchor markup--p-anchor" rel="nofollow">React</a>, <a href="https://angularjs.org/" class="markup--anchor markup--p-anchor" rel="nofollow">AngularJS</a> or <a href="http://backbonejs.org/" class="markup--anchor markup--p-anchor" rel="nofollow">Backbone.js</a> and have the server provide only the dynamic content really needed. &#x2018;Outsourcing&#x2019; rendering to the client can <strong class="markup--strong markup--p-strong">seriously</strong> improve your application&#x2019;s performance.</p><p name="70b1" id="70b1" class="graf--p">Wherever possible you should avoid using Node.js for serving your static assets. Those include anything from Images, Videos or CSS files.</p><p name="5073" id="5073" class="graf--p">To improve both, performance of your application and client latency, I recommend a combination of a separate standard web server, such as Nginx, plus taking advantage of Content Delivery Networks (CDNs) to cache and provide those static assets as close to the user as possible.</p><p name="ed46" id="ed46" class="graf--p"><em class="markup--em markup--p-em">Personally I have had excellent experiences with Rackspace for both.<br>Check them out: </em><a href="http://www.rackspace.com" class="markup--anchor markup--p-anchor" rel="nofollow"><em class="markup--em markup--p-em">www.rackspace.com</em></a></p><p name="0d9b" id="0d9b" class="graf--p">There is a lot to be said for the beauty of clean code following <a href="https://github.com/airbnb/javascript" class="markup--anchor markup--p-anchor" rel="nofollow">fancy style guides</a>. But there is more to be said for reducing load and latency&#x200A;&#x2014;&#x200A;at least in production.</p><p name="4f3f" id="4f3f" class="graf--p">Make it a habit to use <a href="http://gulpjs.com" class="markup--anchor markup--p-anchor" rel="nofollow">Gulp</a> or <a href="http://gruntjs.com" class="markup--anchor markup--p-anchor" rel="nofollow">Grunt</a> to run tasks to <a href="https://github.com/mishoo/UglifyJS2/" class="markup--anchor markup--p-anchor" rel="nofollow">uglify your javascript</a> and <a href="https://github.com/purifycss" class="markup--anchor markup--p-anchor" rel="nofollow">purify your CSS</a>. I personally am becoming a bit of a fan of webpack to bundle everything together as well: <a href="http://webpack.github.io/" class="markup--anchor markup--p-anchor" rel="nofollow">http://webpack.github.io/</a></p><p name="03ee" id="03ee" class="graf--p">This is quite new territory for me, but it is probably fair to say that it&#x2019;s a good idea to keep close look at your application&#x2019;s performance during development. I haven't tested them all, (though I made good experiences with New Relic) but here the recommendations I got from others:</p><p name="090c" id="090c" class="graf--p graf--last"><em class="markup--em markup--p-em">Sidenote: Node.js applications in production mode run with higher performance than in development. You can run your app in production mode to get a sense of the performance once your application is deployed.</em></p></div></div></section><section name="1eb5" class=" section--body section--last" score="41.25"><div class="section-content" score="31.25"><div class="section-inner layoutSingleColumn"><blockquote name="a6cf" id="a6cf" class="graf--pullquote pullquote graf--first">If you found this post in any way useful, please leave a &#x2665;&#xA0;.</blockquote><blockquote name="7954" id="7954" class="graf--pullquote pullquote graf--last">Thanks&#xA0;:)</blockquote></div></div></section></div>
</body></html>
